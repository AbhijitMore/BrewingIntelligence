{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>"},{"location":"#brewing-intelligence","title":"Brewing Intelligence","text":"Welcome to your hub for AI knowledge! Explore free resources on AI, Machine Learning, Deep Learning, and MLOps.  Our mission is to share knowledge, foster growth, and build a collaborative community passionate  about advancing AI for everyone. Join us and start learning today!"},{"location":"#contents","title":"Contents","text":"\ud83d\udc0d Python <li>Basics</li> <li>Modules and Packages</li> <li>OOP</li> <li>Advanced Python</li> <li>Handling Database</li> <li>Network and Security</li> <li>Web Scraping</li> \ud83d\udcca Data Analysis <li>NumPy</li> <li>Scipy</li> <li>Pandas</li> <li>Polars</li> <li>Visualization</li> <li>Handling Images</li> \ud83e\udde0 Deep Learning <li>Neural Networks Basics</li> <li>Optimization Algorithms</li> <li>Training Deep Networks</li> <li>Computer Vision</li> <li>Natural Language Processing</li> \ud83d\udd22 DSA <li>Basics</li> <li>Pattern</li> \ud83d\udcda Machine Learning <li>Linear Regression</li> <li>Logistic Regression</li> <li>Naive Bayes</li> <li>K Nearest Neighbours</li> <li>Support Vector Machine</li> <li>Decision Tree</li> <li>Ensemble Techniques</li> <li>Dimensionality Reduction</li> <li>Clustering</li> <li>Recommendation Systems</li> \ud83e\udd16 Gen AI <ul> <li>GANs</li> <li>VAEs</li> <li>Diffusion Models</li> <li>Transformers</li> \ud83e\udde9 Design Pattern <li>Behavioural Patterns</li> <li>Creational Patterns</li> <li>Structural Patterns</li> \u2699\ufe0f DevOps <li>Scripting</li> <li>Package Manager and Virtual Environment</li> <li>Publishing Python Packages</li> <li>Continuous Integration</li> <li>Flask</li> <li>Docker</li> <li>Mlflow</li> <li>Logging</li> <li>Documentation, Styling and Pre Commit</li> Hello! I'm Abhijit More     I am passionate Software Engineer (AI/ML) focused on creating innovative AI solutions that solve real-world problems.    I specialize in leveraging deep learning, machine learning, and AI technologies to develop impactful products. \ud83e\udd16\ud83d\udca1    I am currently a Software Engineer (AI/ML) at Sony India Software Centre, where I work on deploying AI models on low-power, low-memory edge devices for applications like image classification and object detection. My role involves optimizing deep learning models to meet stringent hardware requirements, ensuring high performance even in resource-constrained environments. \u2699\ufe0f\ud83d\udcf1    Before Sony, I spent time at IIT Madras Pravartak, where I deepened my expertise in AI, particularly large language models and transformers, while working on several impactful projects. Additionally, I worked at HighRadius as an Associate Software Engineer, developing AI-powered solutions for financial operations, including a predictive model for invoice payment dates. \ud83d\udcbc\ud83d\udcbb"},{"location":"DSA/Basics/Binary%20Search/","title":"Binary Search","text":""},{"location":"DSA/Basics/Binary%20Search/#introductory-problems","title":"Introductory Problems","text":""},{"location":"DSA/Basics/Binary%20Search/#upper-bound-and-lower-bound","title":"Upper Bound and Lower Bound","text":""},{"location":"DSA/Basics/Binary%20Search/#search-on-matrix","title":"Search on Matrix","text":""},{"location":"DSA/Basics/Binary%20Search/#missing-and-repeating-number","title":"Missing and Repeating Number","text":""},{"location":"DSA/Basics/Binary%20Search/#binary-search-on-semi-sorted-space","title":"Binary Search on Semi-Sorted Space","text":""},{"location":"DSA/Basics/Binary%20Search/#binary-search-on-answer","title":"Binary Search On Answer","text":""},{"location":"DSA/Basics/Binary%20Search/#minmax-problems","title":"Minmax Problems","text":""},{"location":"DSA/Basics/Binary%20Search/#finding-the-k-th-element","title":"Finding the K-th Element","text":""},{"location":"DSA/Basics/Graph/","title":"Graph","text":""},{"location":"DSA/Basics/Graph/#dfs-and-bfs-on-graphs","title":"DFS and BFS on Graphs","text":""},{"location":"DSA/Basics/Graph/#cycle-detection","title":"Cycle Detection","text":""},{"location":"DSA/Basics/Graph/#topological-sort","title":"Topological Sort","text":""},{"location":"DSA/Basics/Graph/#flood-fill","title":"Flood Fill","text":""},{"location":"DSA/Basics/Graph/#multi-source-bfs","title":"Multi Source BFS","text":""},{"location":"DSA/Basics/Graph/#dijsktra-algorithm","title":"Dijsktra Algorithm","text":""},{"location":"DSA/Basics/Graph/#bellman-ford","title":"Bellman Ford","text":""},{"location":"DSA/Basics/Graph/#floyd-warshall","title":"Floyd Warshall","text":""},{"location":"DSA/Basics/Graph/#travelling-salesman-problem","title":"Travelling Salesman Problem","text":""},{"location":"DSA/Basics/Graph/#disjoint-set-union","title":"Disjoint Set Union","text":""},{"location":"DSA/Basics/Graph/#minimum-spanning-tree","title":"Minimum Spanning Tree","text":""},{"location":"DSA/Basics/Graph/#additional-graph-algorithm","title":"Additional Graph Algorithm","text":""},{"location":"DSA/Basics/Queue/","title":"Queue","text":""},{"location":"DSA/Basics/Queue/#implementation-problems","title":"Implementation Problems","text":""},{"location":"DSA/Basics/Queue/#singly-ended-queue","title":"Singly-Ended Queue","text":""},{"location":"DSA/Basics/Queue/#doubly-ended-queue","title":"Doubly-Ended Queue","text":""},{"location":"DSA/Basics/Sorting/","title":"Sorting","text":""},{"location":"DSA/Basics/Sorting/#1-bubble-sort","title":"1. Bubble Sort","text":""},{"location":"DSA/Basics/Sorting/#2-insertion-sort","title":"2. Insertion Sort","text":""},{"location":"DSA/Basics/Sorting/#3-selection-sort","title":"3. Selection Sort","text":""},{"location":"DSA/Basics/Sorting/#4-merge-sort","title":"4. Merge Sort","text":""},{"location":"DSA/Basics/Sorting/#5-quick-sort","title":"5. Quick Sort","text":""},{"location":"DSA/Basics/Sorting/#6-counting-sort","title":"6. Counting Sort","text":""},{"location":"DSA/Basics/Sorting/#7-radix-sort","title":"7. Radix Sort","text":""},{"location":"DSA/Basics/Sorting/#8-bucket-sort","title":"8. Bucket Sort","text":""},{"location":"DSA/Basics/Sorting/#9-cyclic-sort","title":"9. Cyclic Sort","text":""},{"location":"DSA/Basics/Sorting/#10-custom-sort","title":"10. Custom Sort","text":""},{"location":"DSA/Basics/Stack/","title":"Stack","text":""},{"location":"DSA/Basics/Stack/#parentheses-problem","title":"Parentheses Problem","text":""},{"location":"DSA/Basics/Stack/#design-problems","title":"Design Problems","text":""},{"location":"DSA/Basics/Stack/#advance-stack-problems","title":"Advance Stack Problems","text":""},{"location":"DSA/Basics/Stack/#monotonic-stack","title":"Monotonic Stack","text":""},{"location":"DSA/Basics/Tree/","title":"Tree","text":""},{"location":"DSA/Basics/Tree/#binary-tree","title":"Binary Tree","text":""},{"location":"DSA/Basics/Tree/#traversals","title":"Traversals","text":""},{"location":"DSA/Basics/Tree/#properties-of-trees","title":"Properties of trees","text":""},{"location":"DSA/Basics/Tree/#construction-of-tree","title":"Construction of Tree","text":""},{"location":"DSA/Basics/Tree/#two-tree-validation","title":"Two tree Validation","text":""},{"location":"DSA/Basics/Tree/#level-order-traversal","title":"Level Order Traversal","text":""},{"location":"DSA/Basics/Tree/#binary-tree-path","title":"Binary Tree Path","text":""},{"location":"DSA/Basics/Tree/#n-ary-tree","title":"N-ary Tree","text":""},{"location":"DSA/Basics/Tree/#binary-search-tree","title":"Binary Search Tree","text":""},{"location":"DSA/Basics/Tree/#basic-operations","title":"Basic Operations","text":""},{"location":"DSA/Basics/Tree/#construction-of-bst","title":"Construction of BST","text":""},{"location":"DSA/Basics/Tree/#validation-and-property","title":"Validation and Property","text":""},{"location":"DSA/Patterns/00.%20Prefix%20Sum/","title":"00. Prefix Sum &amp; Line Swipe","text":""},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#prefix-sum","title":"Prefix Sum","text":""},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#theory","title":"Theory","text":""},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#description","title":"Description","text":"<p>The prefix sum technique allows for efficient range sum queries by precomputing cumulative sums in an array.</p>"},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#steps","title":"Steps","text":"<ol> <li>Build the Prefix Sum Array: Create a new array <code>prefix</code> where each element at index <code>i</code> stores the sum of elements from the start of the array up to index <code>i</code>: <pre><code>prefix[0] = arr[0]\nprefix[1] = arr[0] + arr[1]\nprefix[2] = arr[0] + arr[1] + arr[2] \n</code></pre> And so on\u2026 Example: For <code>arr = [3, 1, 4, 1, 5, 9]</code>, the <code>prefix_sum</code> array is <code>[3, 4, 8, 9, 14, 23]</code>.  </li> <li>Answer Range Sum Queries: To find the sum of elements between indices <code>i</code> and <code>j</code>, use: <code>sum(i, j) = prefix[j] - prefix[i-1]</code> </li> </ol> <p>Example: For <code>arr = [3, 1, 4, 1, 5, 9]</code>, the sum from index <code>2</code> to <code>4</code>: <code>sum(2, 4) = prefix[4] - prefix[1] = 14 - 4 = 10</code>.</p> <p>Note</p> <p>If <code>i = 0</code>, simply return <code>prefix[j]</code>.</p>"},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#time-space-complexity","title":"Time &amp; Space Complexity","text":"<ul> <li>Time: <code>O(n)</code> for building the prefix sum array, <code>O(1)</code> per query.  </li> <li>Space: <code>O(n)</code> for storing the prefix sum array.  </li> </ul>"},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#problems","title":"Problems","text":""},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#1-range-sum-query-immutable-leetcode303","title":"1. Range Sum Query - Immutable (Leetcode:303)","text":"<p>Problem Statement Given an integer array <code>nums</code>, handle multiple queries of the following type:  </p> <p>Calculate the sum of the elements of nums between indices <code>left</code> and <code>right</code> inclusive where <code>left</code> &lt;= <code>right</code>.  </p> <p>Implement the <code>NumArray</code> class:  </p> <ul> <li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li> <li><code>int sumRange(int left, int right)</code> Returns the sum of the elements of nums between indices <code>left</code> and <code>right</code> inclusive (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right])</code>.</li> </ul> <p>Example 1: </p> <p>Input <code>[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]</code> <code>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</code> Output <code>[null, 1, -1, -3]</code> </p> <p>Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1 numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1 numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3  </p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 104</code></li> <li><code>-105 &lt;= nums[i] &lt;= 105</code></li> <li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li> <li><code>At most 104 calls will be made to sumRange.</code></li> </ul> Code &amp; Explaination <p><pre><code>class NumArray:\n\ndef __init__(self, nums: List[int]):\n    self.prefix_sum = [0] * (len(nums)+1)\n\n    for i in range(len(nums)):\n        self.prefix_sum[i+1] = self.prefix_sum[i] + nums[i]\n\ndef sumRange(self, left: int, right: int) -&gt; int:\n    return self.prefix_sum[right+1]-self.prefix_sum[left]\n</code></pre> Explaination 1. Constructor (<code>__init__</code>):     - Initializes a list <code>prefix_sum</code> where <code>prefix_sum[i]</code> stores the sum of the elements from index <code>0</code> to <code>i-1</code>.     - Builds this <code>prefix_sum</code> array by iterating over the input list <code>nums</code>. 2. Method <code>sumRange(left, right)</code> :     - Returns the sum of the subarray between indices left and right by calculating the difference: <code>prefix_sum[right+1] - prefix_sum[left].</code>     - This allows constant time <code>O(1)</code> querying of subarray sums after the initial setup.</p>"},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#2-left-and-right-sum-differences-leetcode2574","title":"2. Left and Right Sum Differences (Leetcode:2574)","text":"<p>Problem Statement Given a 0-indexed integer array <code>nums</code>, find a 0-indexed integer array <code>answer</code> where:  </p> <ul> <li><code>answer.length == nums.length</code>.  </li> <li><code>answer[i] = |leftSum[i] - rightSum[i]|</code>. </li> </ul> <p>Where:</p> <ul> <li><code>leftSum[i]</code> is the sum of elements to the left of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>leftSum[i] = 0</code>.  </li> <li><code>rightSum[i]</code> is the sum of elements to the right of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>rightSum[i] = 0</code>. Return the array <code>answer</code>.  </li> </ul> <p>Example 1:</p> <p>Input: nums = [10,4,8,3] Output: [15,1,11,22] Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0]. The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].  </p> <p>Example 2:</p> <p>Input: nums = [1] Output: [0] Explanation: The array leftSum is [0] and the array rightSum is [0]. The array answer is [|0 - 0|] = [0].  </p> <p>Constraints: </p> <ul> <li><code>1 &lt;= nums.length &lt;= 1000</code></li> <li><code>1 &lt;= nums[i] &lt;= 105</code></li> </ul> code &amp; Explanation <p><pre><code>class Solution:\ndef leftRightDifference(self, nums: List[int]) -&gt; List[int]:\n\n    left_sum  = 0\n    right_sum = sum(nums)\n    answer = []\n\n    for num in nums:\n        left_sum += num\n        answer.append(abs(left_sum-right_sum))\n        right_sum -= num\n\n    return answer\n</code></pre> Explaination 1. Initialization: - <code>left_sum = 0</code>: Tracks the sum of elements before the current index. - <code>right_sum = sum(nums)</code>: Initially holds the total sum of all elements. - <code>answer = []</code>: Stores the result. 2. Loop through nums: - For each element <code>num</code>: - Update <code>left_sum</code>: Add <code>num</code> to <code>left_sum</code>. - Calculate and append absolute difference: <code>|left_sum - right_sum|</code> is appended to <code>answer</code>. - Update <code>right_sum</code>: Subtract <code>num</code> from <code>right_sum</code>. 3. Return answer: - After the loop, return the computed differences in <code>answer</code>.</p>"},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#3-subarray-sum-equals-k-leetcode560","title":"3. Subarray Sum Equals K (Leetcode:560)","text":"<p>Problem Statement Given an array of integers <code>nums</code> and an integer <code>k</code>, return the total number of subarrays whose sum equals to <code>k</code>.  </p> <p>A subarray is a contiguous <code>non-empty</code> sequence of elements within an array.</p> <p>Example 1: </p> <p>Input: nums = [1,1,1], k = 2 Output: 2</p> <p>Example 2: </p> <p>Input: nums = [1,2,3], k = 3 Output: 2</p> <p>Constraints: </p> <ul> <li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li> <li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li> <li><code>-107 &lt;= k &lt;= 107</code></li> </ul> Code &amp; Explaination <p><pre><code>class Solution:\n    def subarraySum(self, nums: List[int], k: int) -&gt; int:\n        count = 0\n        prefix_sum = 0\n        dictionary = {0:1}  # Start with {0:1} to handle subarrays starting from the beginning\n\n        for num in nums:\n            prefix_sum += num  # Update prefix sum\n            diff = prefix_sum - k  # Find the difference between the current prefix sum and target k\n            if diff in dictionary:  # If this diff has been seen before, increment count\n                count += dictionary[diff]\n            dictionary[prefix_sum] = dictionary.get(prefix_sum, 0) + 1  # Update the dictionary\n\n        return count\n</code></pre> Explaination 1. Initialization: - <code>count = 0</code>: To store the number of valid subarrays. - <code>prefix_sum = 0</code>: To keep track of the cumulative sum as we iterate through the array. - <code>dictionary = {0: 1}</code>: This keeps track of how many times a certain prefix sum has occurred. - We start with <code>{0: 1}</code> because a sum of <code>0</code> is possible before we start processing the array. 2. Iterate through the array: - For each element <code>num</code> in the array, update the <code>prefix_sum</code> by adding <code>num</code> to it. - Compute the difference <code>diff = prefix_sum - k</code>. If <code>diff</code> exists in the dictionary, it means there are subarrays whose sum equals <code>k</code>, and their <code>count</code> is stored in the <code>dictionary</code>. - Increment <code>count</code> by the number of times <code>diff</code> has occurred. - Update the dictionary by increasing the <code>count</code> of <code>prefix_sum</code>. 3. Return the <code>count</code>: - This gives the total number of subarrays whose sum equals <code>k</code>.  </p>"},{"location":"DSA/Patterns/00.%20Prefix%20Sum/#line-sweep","title":"Line Sweep","text":""},{"location":"DSA/Patterns/01.%20Bit%20Manipulation/","title":"01. Bit Manipulation","text":""},{"location":"DSA/Patterns/01.%20Bit%20Manipulation/#basic-bit-concepts","title":"Basic Bit Concepts","text":""},{"location":"DSA/Patterns/01.%20Bit%20Manipulation/#bitwise-xor-operator","title":"Bitwise XOR operator","text":""},{"location":"DSA/Patterns/01.%20Bit%20Manipulation/#bitwise-or-operator","title":"Bitwise OR operator","text":""},{"location":"DSA/Patterns/01.%20Bit%20Manipulation/#bitwise-and-operator","title":"Bitwise AND operator","text":""},{"location":"DSA/Patterns/02.%20Two%20Pointers/","title":"02. Two Pointer","text":""},{"location":"DSA/Patterns/02.%20Two%20Pointers/#1-two-pointer-on-array","title":"1. Two Pointer on Array","text":""},{"location":"DSA/Patterns/02.%20Two%20Pointers/#2-two-pointer-on-string","title":"2. Two Pointer on String","text":""},{"location":"DSA/Patterns/03.%20Fast%20and%20Slow%20Pointers/","title":"03. Fast and Slow Pointers","text":""},{"location":"DSA/Patterns/04.%20Sliding%20Window/","title":"04.Sliding-Window","text":""},{"location":"DSA/Patterns/04.%20Sliding%20Window/#fixed-size-sliding-window","title":"Fixed Size Sliding-Window","text":""},{"location":"DSA/Patterns/04.%20Sliding%20Window/#dynamic-size-sliding-window","title":"Dynamic Size Sliding-Window","text":""},{"location":"DSA/Patterns/05.%20Merge%20Intervals/","title":"05. Merge Intervals","text":""},{"location":"DSA/Patterns/06.%20Greedy%20Algorithm/","title":"06. Greedy Algorithms","text":""},{"location":"DSA/Patterns/07.%20Divide%20and%20Conquer/","title":"07. Divide and Conquer","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/","title":"08.Dynamic Programming","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#linear-dp","title":"Linear DP","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#2-dimensional-dp","title":"2 Dimensional DP","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#dp-on-grid","title":"DP On Grid","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#knapsack-dp","title":"Knapsack DP","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#longest-increasing-subsequence","title":"Longest Increasing Subsequence","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#longest-common-subsequence","title":"Longest Common Subsequence","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#dp-on-string","title":"DP on String","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#cummulative-sum","title":"Cummulative Sum","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#matrix-chain-multiplication","title":"Matrix Chain Multiplication","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#kadane-algo","title":"Kadane Algo","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#dp-with-bitmask","title":"DP with Bitmask","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#digit-dp","title":"Digit DP","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#dp-on-trees","title":"DP on Trees","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#dp-with-math","title":"DP with Math","text":""},{"location":"DSA/Patterns/08.%20Dynamic%20Programming/#dp-with-probability","title":"Dp with Probability","text":""},{"location":"DSA/Patterns/09.%20Backtracking/","title":"09.Recursion &amp; Backtracking","text":""},{"location":"DSA/Patterns/09.%20Backtracking/#recursion-problems","title":"Recursion Problems","text":""},{"location":"DSA/Patterns/09.%20Backtracking/#permutation-problems","title":"Permutation Problems","text":""},{"location":"DSA/Patterns/09.%20Backtracking/#combination-problems","title":"Combination Problems","text":""},{"location":"DSA/Patterns/09.%20Backtracking/#subsets-problems","title":"Subsets Problems","text":""},{"location":"DSA/Patterns/09.%20Backtracking/#path-on-grid-problems","title":"Path on Grid Problems","text":""},{"location":"DSA/Patterns/10.%20Trie%20%28Prefix%20Tree%29/","title":"10. Tries","text":""},{"location":"DSA/Patterns/10.%20Trie%20%28Prefix%20Tree%29/#introductory-questions","title":"Introductory Questions","text":""},{"location":"DSA/Patterns/10.%20Trie%20%28Prefix%20Tree%29/#trie-with-bit-manipulation","title":"Trie with Bit Manipulation","text":""},{"location":"DSA/Patterns/10.%20Trie%20%28Prefix%20Tree%29/#trie-involving-string","title":"Trie involving String","text":""},{"location":"DSA/Patterns/10.%20Trie%20%28Prefix%20Tree%29/#trie-involving-recursion","title":"Trie involving Recursion","text":""},{"location":"DSA/Patterns/10.%20Trie%20%28Prefix%20Tree%29/#trie-involving-file-system","title":"Trie involving File System","text":""},{"location":"DSA/Patterns/11.%20Hashing/","title":"11. Hashing","text":""},{"location":"DSA/Patterns/11.%20Hashing/#implementary","title":"Implementary","text":""},{"location":"DSA/Patterns/11.%20Hashing/#hashing-with-prefix-sum","title":"Hashing with Prefix Sum","text":""},{"location":"DSA/Patterns/12.%20Union%20Find%20%28Disjoint%20Set%20Union%20-%20DSU%29/","title":"12. Union Find","text":""},{"location":"DSA/Patterns/13.%20Segment%20Tree/","title":"13. Segment Tree","text":""},{"location":"DSA/Patterns/14.%20Heap/","title":"14. Heap","text":""},{"location":"DSA/Patterns/14.%20Heap/#introductory-questions","title":"Introductory Questions","text":""},{"location":"DSA/Patterns/14.%20Heap/#implementary-questions","title":"Implementary Questions","text":""},{"location":"DSA/Patterns/14.%20Heap/#kth-pattern-problems","title":"Kth Pattern Problems","text":""},{"location":"DSA/Patterns/14.%20Heap/#minimize-operations","title":"Minimize Operations","text":""},{"location":"DSA/Patterns/14.%20Heap/#merge-k-sorted-patterns","title":"Merge K Sorted Patterns","text":""},{"location":"DSA/Patterns/14.%20Heap/#two-heap-pattern","title":"Two Heap Pattern","text":""},{"location":"DSA/Patterns/15.%20KMP%20Algorithm/","title":"15. KMP Algorithm","text":""},{"location":"DSA/Patterns/16.%20Rabin-Karp%20Algorithm/","title":"16. Robin-Karp Algorithm","text":""},{"location":"DSA/Patterns/17.%20Z%20Algorithm/","title":"17. Z Algorithm","text":""},{"location":"DSA/Patterns/18.%20Boyer-Moore%20Voting%20Algorithm/","title":"18. Boyer-Moore Voting Algorithm","text":""},{"location":"Design%20Patterns/Behavioural/","title":"Behavioural Design Patterns","text":"<p>Behavioral patterns focus on the interaction between objects, their communication, and the responsibilities of objects. These patterns help make complex communication between objects more flexible and efficient.</p>"},{"location":"Design%20Patterns/Behavioural/#memento-pattern","title":"Memento Pattern","text":"<p>Purpose</p> <p>Primary Purpose of Memento Pattern is to save and store previous state of an object. The Caretaker is responsible for storing and restoring the Memento without modifying it.  In this blog, we will explore how the Memento Pattern is implemented in Java through an example of a simple Graphic Editor that can save and undo shape modifications.</p> Key Components of the Memento Pattern: <p><code>Originator</code>: This is the object whose state is being saved or restored. In our case, it\u2019s the GraphicEditor class. <code>Memento</code>: This object stores the state of the Originator. In our example, it is the EditorMemento class. <code>Caretaker</code>: This class keeps the history of mementos and is responsible for saving and restoring states. In our example, the Caretaker class handles the history of shapes.</p> The GraphicEditor Class <p>The GraphicEditor class represents the originator. It stores information about the shape being drawn, such as its type, position, color, and size. It also has methods to save and restore its state using the EditorMemento class.</p> JavaPython GraphicEditor.java<pre><code>// The GraphicEditor class manages the properties of shapes and provides functionality to save and restore their state using the Memento pattern.\n\npackage Memento;\n\npublic class GraphicEditor {\n\n    private String shapeType;\n    private int x;\n    private int y;\n    private String color;\n    private int size;\n\n    public EditorMemento save() {\n        // TODO: Create and return a new memento that captures the current state of the shape attributes.\n        return new EditorMemento(shapeType, x, y, color, size);\n\n    }\n\n    public void restore(EditorMemento memento) {\n        // TODO: Restore the shape attributes from the provided memento, updating the graphic editor's state.\n        shapeType = memento.getShapeType();\n        x = memento.getX();\n        y = memento.getY();\n        color = memento.getColor();\n        size = memento.getSize();\n    }\n\n    public String getShape() {\n        return \"Shape: \" + shapeType + \", Position: (\" + x + \", \" + y + \"), Color: \" + color + \", Size: \" + size;\n    }\n\n    public void setShape(String shapeType, int x, int y, String color, int size) {\n        this.shapeType = shapeType;\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.size = size;\n    }\n}\n</code></pre> GraphicEditor.py<pre><code>from EditorMemento import EditorMemento\n\nclass GraphicEditor:\n    def __init__(self):\n        self.shape_type = None\n        self.x = 0\n        self.y = 0\n        self.color = None\n        self.size = 0\n\n    def save(self):\n        # Create and return a new memento capturing the current state\n        return EditorMemento(self.shape_type, self.x, self.y, self.color, self.size)\n\n    def restore(self, memento):\n        # Restore the state from the provided memento\n        self.shape_type = memento.shape_type\n        self.x = memento.x\n        self.y = memento.y\n        self.color = memento.color\n        self.size = memento.size\n\n    def get_shape(self):\n        return f\"Shape: {self.shape_type}, Position: ({self.x}, {self.y}), Color: {self.color}, Size: {self.size}\"\n\n    def set_shape(self, shape_type, x, y, color, size):\n        self.shape_type = shape_type\n        self.x = x\n        self.y = y\n        self.color = color\n        self.size = size\n</code></pre> The EditorMemento Class <p>The EditorMemento class captures the state of a shape. It is an immutable object that holds the shape's properties and provides getter methods to retrieve these values.</p> JavaPython EditorMemento.Java<pre><code>// The EditorMemento class stores the state of a shape, allowing for the preservation and restoration of its attributes in the Memento pattern.\n\npackage Memento;\n\npublic class EditorMemento {\n\n    private final String shapeType;\n    private final int x;\n    private final int y;\n    private final String color;\n    private final int size;\n\n    public EditorMemento(String shapeType, int x, int y, String color, int size) {\n        // TODO: Initialize the shape's attributes with the provided parameters.\n        this.shapeType = shapeType;\n        this.x = x ;\n        this.y = y ;\n        this.color = color;\n        this.size = size;\n\n\n    }\n\n    public String getShapeType() {\n        return shapeType;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public int getSize() {\n        return size;\n    }\n}\n</code></pre> EditorMemento.py<pre><code>class EditorMemento:\ndef __init__(self, shape_type, x, y, color, size):\n    # Store the shape's attributes\n    self.shape_type = shape_type\n    self.x = x\n    self.y = y\n    self.color = color\n    self.size = size\n</code></pre> The Caretaker Class <p>The Caretaker class is responsible for managing the history of saved states. It uses a Stack to keep track of the mementos. The caretaker does not modify the state of the memento, it only stores and retrieves it when necessary.</p> JavaPython Caretaker.Java<pre><code>// The Caretaker class manages the history of shape states, allowing for saving and undoing changes in the Memento pattern.\n\npackage Memento;\n\nimport java.util.Stack;\n\npublic class Caretaker {\n\n    private final Stack&lt;EditorMemento&gt; history = new Stack&lt;&gt;();\n\n    public void saveState(GraphicEditor graphicEditor) {\n        // TODO: Save the current state of the graphic editor by pushing its memento onto the history stack.\n        history.push(graphicEditor.save());\n\n    }\n\n    public void undo(GraphicEditor graphicEditor){\n        // TODO: Restore the last saved state of the graphic editor if history is not empty.\n        if (!history.empty()){\n            history.pop();\n            graphicEditor.restore(history.pop());\n        }\n\n    }\n}\n</code></pre> Caretaker.py<pre><code>class Caretaker:\ndef __init__(self):\n    # Stack to maintain history of states\n    self.history = []\n\ndef save_state(self, graphic_editor):\n    # Save the current state by appending its memento to the history\n    self.history.append(graphic_editor.save())\n\ndef undo(self, graphic_editor):\n    # Restore the last saved state if history is not empty\n    if self.history:\n        self.history.pop()  # Discard the latest state\n        if self.history:  # Check if there\u2019s another state to revert to\n            graphic_editor.restore(self.history[-1])\n</code></pre> The Exercise Class (Main Application) <p>The Exercise class is responsible for interacting with the user. It collects the shape's attributes and uses the GraphicEditor and Caretaker to manage and save the state.</p> JavaPython Exercise.java<pre><code>// The Exercise class allows users to input shape attributes and provides functionality to manage these shapes using the Memento pattern.\n\npackage Memento;\nimport java.util.Scanner;\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to gather user input and manage shape states.\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        GraphicEditor graphicEditor = new GraphicEditor();\n        Caretaker caretaker = new Caretaker();\n\n        for (int i = 0; i &lt; 3; i++) {\n            String shape = sc.next(); \n            int x = sc.nextInt();     \n            int y = sc.nextInt();     \n            String color = sc.next(); \n            int size = sc.nextInt(); \n\n            // TODO: Update the graphic editor with the new shape attributes from user input.\n            graphicEditor.setShape(shape, x, y, color, size);\n\n            // TODO: Save the current state of the graphic editor to the history\n            caretaker.saveState(graphicEditor);\n        }\n        sc.close();\n\n        // TODO: Implement the undo operation to revert to the previous shape state\n        caretaker.undo(graphicEditor);\n        // TODO: Output the current shape attributes after the undo operation to verify the restored state.\n        System.out.println(graphicEditor.getShape());\n\n    }\n}\n</code></pre> Exercise.py<pre><code>from GraphicEditor import GraphicEditor\nfrom Caretaker import Caretaker\n\nclass Exercise:\n    def run(self):\n        graphic_editor = GraphicEditor()\n        caretaker = Caretaker()\n\n        for _ in range(3):\n            # Take input from the user\n            shape = input(\"Enter shape type: \")  \n            x = int(input(\"Enter x-coordinate: \"))  \n            y = int(input(\"Enter y-coordinate: \"))  \n            color = input(\"Enter color: \")  \n            size = int(input(\"Enter size: \"))  \n\n            # Update the graphic editor with new shape attributes\n            graphic_editor.set_shape(shape, x, y, color, size)\n\n            # Save the current state to the history\n            caretaker.save_state(graphic_editor)\n\n        # Undo the last operation\n        caretaker.undo(graphic_editor)\n\n        # Print the current state after undo\n        print(graphic_editor.get_shape())\n\nif __name__ == \"__main__\":\n    Exercise().run()\n</code></pre>  How the Memento Pattern Works in This Example  <p><code>Setting the Shape:</code> The user inputs the shape's attributes (type, position, color, and size). These attributes are set in the GraphicEditor object. <code>Saving State:</code> Each time the user changes the shape, the current state is saved by calling the saveState method of the Caretaker class. This stores the state in a Stack. <code>Undo Operation:</code> The user can undo the changes by calling the undo method of the Caretaker class. This restores the previous shape state from the stack, effectively rolling back to an earlier state.</p>  Benefits of Using the Memento Pattern  <p><code>Encapsulation Preservation:</code> The state of an object is captured and stored outside of the object, allowing for state restoration without exposing the internal structure. <code>Undo/Redo Operations:</code> The Memento Pattern provides an easy way to implement undo and redo functionality. <code>Separation of Concerns:</code> The Caretaker class is responsible for managing the state history, allowing the GraphicEditor class to focus solely on the editing functionality.</p>"},{"location":"Design%20Patterns/Behavioural/#observer-pattern","title":"Observer Pattern","text":"Exercise.java<pre><code>// The Exercise class simulates stock price updates, registers investors, and removes an observer after the 4th update.\n\npackage Observer;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user input, manage stock price updates, and control the observer notification process.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        double priceChangeThreshold = sc.nextDouble();\n        StockMarket stockMarket = new StockMarket(priceChangeThreshold);\n\n        InvestorA investorA = new InvestorA();\n        InvestorB investorB = new InvestorB();\n\n        // TODO: Register Investor A as an observer to receive stock updates.\n        stockMarket.registerObserver(investorA);\n\n\n        // TODO: Register Investor B as an observer to receive stock updates.\n        stockMarket.registerObserver(investorB);\n\n        int updates = sc.nextInt();\n\n        for (int i = 1; i &lt;= updates; i++) {\n\n            if(i == 5) {\n                // TODO: Remove Investor B from receiving notifications after the 4th update.\n                stockMarket.removeObserver(investorB);\n\n            }\n\n            String stockSymbol = sc.next();\n            double newPrice = sc.nextDouble();\n            double oldPrice = sc.nextDouble();\n\n            // TODO: Update the stock price and notify observers.\n            stockMarket.setStockPrice(stockSymbol, newPrice, oldPrice);\n\n\n        }\n        sc.close();\n    }\n}\n</code></pre> StockMarket.java<pre><code>// The StockMarket class tracks stock price changes and notifies observers if the change exceeds a threshold.\n\npackage Observer;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StockMarket implements Subject {\n\n    private final List&lt;Observer&gt; observers;\n    private final double priceChangeThreshold;\n\n    public StockMarket(double priceChangeThreshold) {\n        // TODO: Initialize the list of observers to keep track of registered observers.\n        observers = new ArrayList&lt;&gt;();\n\n\n        this.priceChangeThreshold = priceChangeThreshold;\n    }\n\n    @Override\n    public void registerObserver(Observer o) {\n        // TODO: Add observer to the list of observers\n        observers.add(o);\n\n    }\n\n    @Override\n    public void removeObserver(Observer o) {\n        // TODO: Remove observer from the list of observers\n        observers.remove(o);\n\n    }\n\n    @Override\n    public void notifyObservers(String stockSymbol, double newPrice) {\n        for (Observer observer : observers) {\n            // TODO: Inform each observer about the updated stock price.\n            observer.update(stockSymbol, newPrice);\n\n        }\n    }\n\n    public void setStockPrice(String stockSymbol, double newPrice, double oldPrice) {\n        double priceChange = Math.abs(newPrice - oldPrice) / oldPrice * 100;\n        if (priceChange &gt;= priceChangeThreshold) {\n            // TODO: Notify observers if the price change exceeds the threshold\n            notifyObservers(stockSymbol, newPrice);\n\n        }\n    }\n}\n</code></pre> InvestorA.java<pre><code>// The InvestorA class implements the Observer interface and receives stock price updates.\n\npackage Observer;\n\npublic class InvestorA implements Observer {\n\n    @Override\n    public void update(String stockSymbol, double newPrice) {\n        System.out.println(\"Investor A notified: Stock \" + stockSymbol + \" has a new price: $\" + newPrice);\n    }\n}\n</code></pre> InvestorB.java<pre><code>// The InvestorB class implements the Observer interface and receives stock price updates.\n\npackage Observer;\n\npublic class InvestorB implements Observer {\n\n    @Override\n    public void update(String stockSymbol, double newPrice) {\n        System.out.println(\"Investor B notified: Stock \" + stockSymbol + \" has a new price: $\" + newPrice);\n    }\n}\n</code></pre> Subject.java<pre><code>// The Subject interface defines methods for registering, removing, and notifying observers about stock price changes.\n\npackage Observer;\n\npublic interface Subject {\n    void registerObserver(Observer o);\n    void removeObserver(Observer o);\n    void notifyObservers(String stockSymbol, double newPrice);\n}\n</code></pre> observer.java<pre><code>// The Observer interface defines the update method for receiving stock price change notifications.\n\npackage Observer;\n\npublic interface Observer {\n    void update(String stockSymbol, double newPrice);\n}\n</code></pre>"},{"location":"Design%20Patterns/Behavioural/#strategy-pattern","title":"Strategy Pattern","text":"Exercise.java<pre><code>// Exercise.java\n// This class manages the formatting process of a document using various text formatting strategies.\n\npackage Strategy;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It facilitates the formatting process of a document using different formatting strategies.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n        Document document = new Document();\n\n        String userInput = sc.nextLine();\n        document.setContent(userInput);\n\n        // Using PlainTextFormatter\n        // TODO: Set the formatter for the document to PlainTextFormatter.\n        PlainTextFormatter plainText = new PlainTextFormatter();\n        document.setFormatter(plainText);\n\n        System.out.println(\"Plain Text:\");\n        document.display();\n\n        // Using HTMLFormatter\n        // TODO: Set the formatter for the document to HTMLFormatter.\n        HTMLFormatter htmlText = new HTMLFormatter();\n        document.setFormatter(htmlText);\n\n\n        System.out.println(\"HTML Format:\");\n        document.display();\n\n        // Using MarkdownFormatter\n        // TODO: Set the formatter for the document to MarkdownFormatter.\n        MarkdownFormatter markdownText = new MarkdownFormatter();\n        document.setFormatter(markdownText);\n\n\n        System.out.println(\"Markdown Format:\");\n        document.display(); \n\n        sc.close();\n    }\n}\n</code></pre> Document.java<pre><code>// Document.java\n// This class represents a document that can have its content formatted using different strategies.\n\npackage Strategy;\n\npublic class Document {\n\n    private String content;\n    private TextFormatter formatter;\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public void setFormatter(TextFormatter formatter) {\n        this.formatter = formatter;\n    }\n\n    public void display() {\n        // TODO: Print the formatted content using the chosen formatter.\n        System.out.println(formatter.format(this.content));\n\n    }\n}\n</code></pre> PlainTextFormatter.java<pre><code>// PlainTextFormatter.java\n// This class implements the TextFormatter interface to format text as plain text.\n\npackage Strategy;\n\npublic class PlainTextFormatter implements TextFormatter {\n\n    @Override\n    public String format(String text) {\n        // TODO: Return the input text without any formatting.\n        return text;\n\n    }\n}\n</code></pre> HTMLFormatter.java<pre><code>// HTMLFormatter.java\n// This class implements the TextFormatter interface to format the text as HTML.\n\npackage Strategy;\n\npublic class HTMLFormatter implements TextFormatter {\n\n    @Override\n    public String format(String text) {\n        // TODO: Wrap the input text in HTML tags: \"&lt;html&gt;&lt;body&gt;\" and \"&lt;/body&gt;&lt;/html&gt;\".\n        return \"&lt;html&gt;&lt;body&gt;\" + text + \"&lt;/body&gt;&lt;/html&gt;\";\n    }\n}\n</code></pre> MarkdownFormatter.java<pre><code>// MarkdownFormatter.java\n// This class implements the TextFormatter interface to format text using Markdown syntax.\n\npackage Strategy;\n\npublic class MarkdownFormatter implements TextFormatter {\n\n    @Override\n    public String format(String text) {\n        // TODO: Wrap the input text in Markdown syntax: \"**\" and \"**\".\n        return \"**\" + text + \"**\";\n\n    }\n}\n</code></pre> TextFormatter.java<pre><code>// TextFormatter.java\n// This Interface defines a contract for text formatting strategies.\n\npackage Strategy;\n\npublic interface TextFormatter {\n    String format(String text);\n}\n</code></pre>"},{"location":"Design%20Patterns/Behavioural/#command-pattern","title":"Command Pattern","text":"Exercise.java<pre><code>// This class is responsible for creating devices, commands, and a remote control to demonstrate the command pattern functionality.\n\npackage Command;\n\npublic class Exercise {\n\n    //Do not modify the run method; it is designed to manage command execution and control the devices.\n    public void run () {\n\n        // Create devices\n        Light light = new Light();\n        Fan fan = new Fan();\n\n        // Create commands\n        Command lightOn = new LightCommands.LightOnCommand(light);\n        Command lightOff = new LightCommands.LightOffCommand(light);\n        Command fanOn = new FanCommands.FanOnCommand(fan);\n        Command fanOff = new FanCommands.FanOffCommand(fan);\n\n        // Create remote control\n        // TODO: Instantiate the RemoteControl object to manage commands.\n        RemoteControl remoteControl = new RemoteControl();\n\n\n        // TODO: Set the command for turning the light on using the LightOnCommand using remoteControl object.\n        remoteControl.setLightOnCommand(lightOn);\n\n\n        // TODO: Set the command for turning off the light using LightOffCommand using remoteControl object.\n        remoteControl.setLightOffCommand(lightOff);\n\n\n        // TODO: Set the command for turning on the fan using FanOnCommand using remoteControl object.\n        remoteControl.setFanOnCommand(fanOn);\n\n\n        // TODO: Set the command for turning off the fan using FanOffCommand using remoteControl object.\n        remoteControl.setFanOffCommand(fanOff);\n\n\n        // Test the functionality\n        // TODO: Press the button to turn on the light and verify the output.\n        remoteControl.pressLightOnButton();\n\n\n        // TODO: Press the button to turn off the light and verify the output.\n        remoteControl.pressLightOffButton();\n\n        // TODO: Press the button to turn on the fan and verify the output.\n        remoteControl.pressFanOnButton();\n\n        // TODO: Press the button to turn off the fan and verify the output.\n        remoteControl.pressFanOffButton();\n\n    }\n}\n</code></pre> RemoteControl.java<pre><code>// This class acts as a remote control, allowing the execution of commands for controlling devices like lights and fans.\n\npackage Command;\n\npublic class RemoteControl {\n\n    private Command lightOnCommand;\n    private Command lightOffCommand;\n    private Command fanOnCommand;\n    private Command fanOffCommand;\n\n    public void setLightOnCommand(Command command) {\n        this.lightOnCommand = command;\n    }\n\n    public void setLightOffCommand(Command command) {\n        this.lightOffCommand = command;\n    }\n\n    public void setFanOnCommand(Command command) {\n        this.fanOnCommand = command;\n    }\n\n    public void setFanOffCommand(Command command) {\n        this.fanOffCommand = command;\n    }\n\n    public void pressLightOnButton() {\n        if (lightOnCommand != null) {\n            lightOnCommand.execute();\n        }\n    }\n\n    public void pressLightOffButton() {\n        if (lightOffCommand != null) {\n            lightOffCommand.execute();\n        }\n    }\n\n    public void pressFanOnButton() {\n        if (fanOnCommand != null) {\n            fanOnCommand.execute();\n        }\n    }\n\n    public void pressFanOffButton() {\n        if (fanOffCommand != null) {\n            fanOffCommand.execute();\n        }\n    }\n}\n</code></pre> LightCommands.java<pre><code>// This class contains command implementations for controlling the light, including turning it on and off.\n\npackage Command;\n\npublic class LightCommands {\n\n    public static class LightOnCommand implements Command {\n\n        private Light light;\n\n        public LightOnCommand(Light light) {\n            this.light = light;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn on the light when this command is executed.\n        public void execute(){\n            light.turnOn();\n        }\n\n\n    }\n\n    public static class LightOffCommand implements Command {\n\n        private Light light;\n\n        public LightOffCommand(Light light) {\n            this.light = light;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn off the light when this command is executed.\n        public void execute(){\n            light.turnOff();\n        }\n\n    }\n}\n</code></pre> FanCommands.java<pre><code>// This class contains command implementations for controlling the fan, including turning it on and off.\n\npackage Command;\n\npublic class FanCommands {\n\n    public static class FanOnCommand implements Command {\n\n        private Fan fan;\n\n        public FanOnCommand(Fan fan) {\n            this.fan = fan;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn on the fan when this command is executed.\n        public void execute(){\n            fan.turnOn();\n        }\n\n\n    }\n\n    public static class FanOffCommand implements Command {\n\n        private Fan fan;\n\n        public FanOffCommand(Fan fan) {\n            this.fan = fan;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn off the fan when this command is executed.\n\n        public void execute(){\n            fan.turnOff();\n        }\n    }\n}\n</code></pre> Light.java<pre><code>// This class represents a light that can be turned on or off, providing the corresponding output.\n\npackage Command;\n\npublic class Light {\n\n    public void turnOn() {\n        System.out.println(\"The light is on.\");\n    }\n\n    public void turnOff() {\n        System.out.println(\"The light is off.\");\n    }\n}\n</code></pre> Fan.java<pre><code>// This class represents a fan that can be turned on or off, providing the corresponding output.\n\npackage Command;\n\npublic class Fan {\n\n    public void turnOn() {\n        System.out.println(\"The fan is on.\");\n    }\n\n    public void turnOff() {\n        System.out.println(\"The fan is off.\");\n    }\n}\n</code></pre> Command.java<pre><code>// This interface defines a command that can be executed, requiring an implementation of the execute method.\n\npackage Command;\n\npublic interface Command {\n    void execute();\n}\n</code></pre>"},{"location":"Design%20Patterns/Behavioural/#template-method-pattern","title":"Template Method Pattern","text":"Exercise.java<pre><code>// This class is responsible for executing the report generation process using different report types.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It manages the report generation process for various report types.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        // Generate Sales Report\n        ReportTemplate salesReport = new SalesReport(sc);\n        System.out.println(\"Generating Sales Report:\");\n\n        // TODO: Generate the Sales Report by calling the generateReport() method.\n        salesReport.generateReport();\n\n\n        // Generate Employee Report\n        ReportTemplate employeeReport = new EmployeeReport(sc);\n        System.out.println(\"Generating Employee Report:\");\n\n        // TODO: Generate the Employee Report by calling the generateReport() method.\n        employeeReport.generateReport();\n\n        // Generate Inventory Report\n        ReportTemplate inventoryReport = new InventoryReport(sc);\n        System.out.println(\"Generating Inventory Report:\");\n\n        // TODO: Generate the Inventory Report by calling the generateReport() method.\n        inventoryReport.generateReport();\n\n\n    }\n}\n</code></pre> SalesReport.java<pre><code>// This class represents a Sales Report, gathering and processing sales data from user input.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class SalesReport extends ReportTemplate {\n\n    private Scanner sc;\n\n    public SalesReport(Scanner sc) {\n        this.sc = sc;\n    }\n\n    @Override\n    protected void gatherData() {\n        String gatherData = sc.nextLine();\n        System.out.println(gatherData);\n    }\n\n    @Override\n    protected void processData() {\n        String processData = sc.nextLine();\n        System.out.println(processData);\n    }\n}\n</code></pre> EmployeeReport.java<pre><code>// This class represents a Employee Report, gathering and processing sales data from user input.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class EmployeeReport extends ReportTemplate {\n\n    private Scanner sc;\n\n    public EmployeeReport(Scanner sc) {\n        this.sc = sc;\n    }\n\n    @Override\n    protected void gatherData() {\n        String gatherData = sc.nextLine();\n        System.out.println(gatherData);\n    }\n\n    @Override\n    protected void processData() {\n        String processData = sc.nextLine();\n        System.out.println(processData);\n    }\n}\n</code></pre> InventoryReport.java<pre><code>// This class represents a Inventory Report, gathering and processing sales data from user input.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class InventoryReport extends ReportTemplate {\n\n    private Scanner sc;\n\n    public InventoryReport(Scanner sc) {\n        this.sc = sc;\n    }\n\n    @Override\n    protected void gatherData() {\n        String gatherData = sc.nextLine();\n        System.out.println(gatherData);\n    }\n\n    @Override\n    protected void processData() {\n        String processData = sc.nextLine();\n        System.out.println(processData);\n    }\n}\n</code></pre> ReportTemplate.java<pre><code>// Abstract class defining the template for report generation, enforcing the structure while allowing specific implementations for each report type.\n\npackage Template;\n\npublic abstract class ReportTemplate {\n\n    // Template method defining the skeleton of the report generation\n    public final void generateReport() {\n        gatherData(); // Specific to each report\n        processData(); // Specific to each report\n        formatReport(); // Common across all reports\n        printReport(); // Common across all reports\n    }\n\n    // Steps to be implemented by subclasses\n    protected abstract void gatherData();\n    protected abstract void processData();\n\n    // Default methods that can be common across all reports\n    protected void formatReport() {\n        System.out.println(\"Formatting the report with appropriate layout and style.\");\n    }\n\n    protected void printReport() {\n        System.out.println(\"Printing the report for final review and distribution.\");\n    }\n}\n</code></pre>"},{"location":"Design%20Patterns/Behavioural/#iterator-pattern","title":"Iterator Pattern","text":"Exercise.java<pre><code>// This class allows users to input various types of notifications and then displays them.\n\npackage Iterator;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user input and manage the notification workflow.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n        NotificationManager notificationManager = new NotificationManager();\n\n        // Add Notifications\n        for(int i=0;i &lt; 2;i++) {\n            String emailNotification = sc.nextLine();\n            String smsNotification = sc.nextLine();\n            String pushNotification = sc.nextLine();\n\n            notificationManager.addEmailNotification(emailNotification);\n            notificationManager.addSMSNotification(smsNotification);\n            notificationManager.addPushNotification(pushNotification);\n        }\n\n        // Print all notifications\n        // TODO: Use notificationManager to display all the added notifications by invoking the method that prints them.\n            notificationManager.printAllNotifications();\n\n\n        sc.close();\n    }\n}\n</code></pre> NotificationManager.java<pre><code>// This class manages different types of notifications (email, SMS, push) and provides methods to add notifications and print them using an iterator pattern.\n\npackage Iterator;\n\nimport java.util.Iterator;\n\npublic class NotificationManager {\n\n    private NotificationCollection emailNotifications;\n    private NotificationCollection smsNotifications;\n    private NotificationCollection pushNotifications;\n\n    public NotificationManager() {\n\n        // TODO: Initialize Email Notifications using the class responsible for handling Email Notifications.\n        this.emailNotifications = new EmailNotification();\n\n\n        // TODO: Initialize SMS Notifications using the class responsible for handling SMS Notifications.\n        this.smsNotifications = new SMSNotification();\n\n        // TODO: Initialize Push Notifications using the class responsible for handling Push Notifications.\n        this.pushNotifications = new PushNotification();\n\n\n    }\n\n    public void addEmailNotification(String message) {\n        ((EmailNotification) emailNotifications).addNotification(message);\n    }\n\n    public void addSMSNotification(String message) {\n        ((SMSNotification) smsNotifications).addNotification(message);\n    }\n\n    public void addPushNotification(String message) {\n        ((PushNotification) pushNotifications).addNotification(message);\n    }\n\n    public void printAllNotifications() {\n        printNotifications(emailNotifications.createIterator(), \"Email\");\n        printNotifications(smsNotifications.createIterator(), \"SMS\");\n        printNotifications(pushNotifications.createIterator(), \"Push\");\n    }\n\n    private void printNotifications(Iterator&lt;Notification&gt; iterator, String type) {\n        System.out.println(type + \" Notifications:\");\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next().getMessage());\n        }\n    }\n}\n</code></pre> EmailNotification.java<pre><code>// This class represents a collection of Email notifications and provides functionality to add notifications and create an iterator for traversing through them.\n\npackage Iterator;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class EmailNotification implements NotificationCollection {\n\n    private List&lt;Notification&gt; emailNotifications;\n\n    public EmailNotification() {\n        emailNotifications = new ArrayList&lt;&gt;();\n    }\n\n    public void addNotification(String message) {\n        emailNotifications.add(new Notification(message));\n    }\n\n    @Override\n    public Iterator&lt;Notification&gt; createIterator() {\n        // TODO: Return a new iterator for the Email Notifications using the EmailNotificationIterator class.\n        return new EmailNotificationIterator(this.emailNotifications);\n\n    }\n\n    private class EmailNotificationIterator implements Iterator&lt;Notification&gt; {\n        private int position = 0;\n        private List&lt;Notification&gt; notifications;\n\n        public EmailNotificationIterator(List&lt;Notification&gt; notifications) {\n            this.notifications = notifications;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return position &lt; notifications.size();\n        }\n\n        @Override\n        public Notification next() {\n            return notifications.get(position++);\n        }\n    }\n}\n</code></pre> SMSNotification.java<pre><code>// This class represents a collection of SMS notifications and provides functionality to add notifications and create an iterator for traversing through them.\n\npackage Iterator;\n\nimport java.util.Iterator;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class SMSNotification implements NotificationCollection {\n\n    private Queue&lt;Notification&gt; smsNotifications;\n\n    public SMSNotification() {\n        smsNotifications = new ArrayDeque&lt;&gt;();\n    }\n\n    public void addNotification(String message) {\n        smsNotifications.add(new Notification(message));\n    }\n\n    @Override\n    public Iterator&lt;Notification&gt; createIterator() {\n        // TODO: Return a new iterator for the SMS Notifications using the SMSNotificationIterator class.\n        return new SMSNotificationIterator(this.smsNotifications);\n\n    }\n\n    private class SMSNotificationIterator implements Iterator&lt;Notification&gt; {\n        private Queue&lt;Notification&gt; notifications;\n\n        public SMSNotificationIterator(Queue&lt;Notification&gt; notifications) {\n            this.notifications = new ArrayDeque&lt;&gt;(notifications);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !notifications.isEmpty();\n        }\n\n        @Override\n        public Notification next() {\n            return notifications.poll();\n        }\n    }\n}\n</code></pre> PushNotification.java<pre><code>// This class represents a collection of Push notifications and provides functionality to add notifications and create an iterator for traversing through them.\n\npackage Iterator;\n\nimport java.util.LinkedHashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class PushNotification implements NotificationCollection {\n\n    private Set&lt;Notification&gt; pushNotifications;\n\n    public PushNotification() {\n        pushNotifications = new LinkedHashSet&lt;&gt;();\n    }\n\n    public void addNotification(String message) {\n        pushNotifications.add(new Notification(message));\n    }\n\n    @Override\n    public Iterator&lt;Notification&gt; createIterator() {\n        // TODO: Return a new iterator for the Push Notifications using the PushNotificationIterator class.\n        return new PushNotificationIterator(this.pushNotifications);\n\n    }\n\n    private class PushNotificationIterator implements Iterator&lt;Notification&gt; {\n        private Iterator&lt;Notification&gt; iterator;\n\n        public PushNotificationIterator(Set&lt;Notification&gt; notifications) {\n            this.iterator = notifications.iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public Notification next() {\n            return iterator.next();\n        }\n    }\n}\n</code></pre> Notification.java<pre><code>// This class represents a notification with a message for managing notifications.\n\npackage Iterator;\n\npublic class Notification {\n    private String message;\n\n    public Notification(String message) {\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\n</code></pre> NotificationCollection.java<pre><code>// This defines an interface for collections that provide an iterator for notifications.\n\npackage Iterator;\n\nimport java.util.Iterator;\n\npublic interface NotificationCollection {\n    public Iterator&lt;Notification&gt; createIterator();\n}\n</code></pre>"},{"location":"Design%20Patterns/Behavioural/#state-pattern","title":"State pattern","text":"Exercise.java<pre><code>// The Exercise class demonstrates the State Design Pattern for a Media Player.\n\npackage State;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user commands (Play, Pause, stop) for the Media Player. \n    public void run() {\n\n        MediaPlayer mediaPlayer = new MediaPlayer();\n        Scanner sc = new Scanner(System.in);\n\n        String choice = sc.next();\n\n        switch (choice) {\n            case \"Play\":\n                mediaPlayer.play();\n                break;\n            case \"Pause\":\n                // TODO: Set the Media Player state to PausedState\n                mediaPlayer.setState(new PausedState());\n\n                mediaPlayer.pause();\n                break;\n            case \"Stop\":\n                // TODO: Set the Media Player state to StoppedState\n                mediaPlayer.setState(new StoppedState());\n\n                mediaPlayer.stop();\n                break;\n            default:\n                System.out.println(\"Invalid choice.\");\n        }\n\n        // TODO: Display the current state of the Media Player\n        mediaPlayer.displayState();\n\n        sc.close();\n    }\n}\n</code></pre> MediaPlayer.java<pre><code>// The MediaPlayer class manages the current state of the Media Player using the State Design Pattern.\n\npackage State;\n\npublic class MediaPlayer {\n\n    private State state;\n\n    public MediaPlayer() {\n        // TODO: Set the initial state of the Media Player to PlayingState\n        state = new PlayingState();\n\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void play() {\n        // TODO: Implement the functionality for pressing play\n        state.pressPlay();\n    }\n\n    public void stop() {\n        // TODO: Implement the functionality for pressing stop\n        state.pressStop();\n    }\n\n    public void pause() {\n        // TODO: Implement the functionality for pressing pause\n        state.pressPause();\n    }\n\n    public void displayState() {\n        // TODO: Implement the functionality to display the current state\n        state.display();\n    }\n}\n</code></pre> PlayingState.java<pre><code>// The PlayingState class represents the playing state of the Media Player. \n\npackage State;\n\npublic class PlayingState implements State {\n\n    @Override\n    public void pressPlay() {\n        System.out.println(\"Starting playback\");\n    }\n\n    @Override\n    public void pressStop() {\n        System.out.println(\"Stopping playback\");\n    }\n\n    @Override\n    public void pressPause() {\n        System.out.println(\"Pausing playback\");\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current State: Playing\");\n    }\n}\n</code></pre> PausedState.java<pre><code>// The PausedState class represents the playing state of the Media Player.\n\npackage State;\n\npublic class PausedState implements State {\n\n    @Override\n    public void pressPlay() {\n        System.out.println(\"Resuming playback\");\n    }\n\n    @Override\n    public void pressStop() {\n        System.out.println(\"Stopping playback from pause\");\n    }\n\n    @Override\n    public void pressPause() {\n        System.out.println(\"Pausing playback\");\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current State: Paused\");\n    }\n}\n</code></pre> StoppedState.java<pre><code>// The StoppedState class represents the playing state of the Media Player. \n\npackage State;\n\npublic class StoppedState implements State {\n\n    @Override\n    public void pressPlay() {\n        System.out.println(\"Starting playback\");\n    }\n\n    @Override\n    public void pressStop() {\n        System.out.println(\"Stopping playback\");\n    }\n\n    @Override\n    public void pressPause() {\n        System.out.println(\"Can't pause. Media is already stopped\");\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current State: Stopped\");\n    }\n}\n</code></pre> State.java<pre><code>// The State interface defines the methods for different states of the Media Player. \n\npackage State;\n\npublic interface State {\n    void pressPlay();\n    void pressStop();\n    void pressPause();\n    void display();\n}\n</code></pre>"},{"location":"Design%20Patterns/Behavioural/#mediator-pattern","title":"Mediator Pattern","text":"Exercise.java<pre><code>// This class simulates the flight control system, managing airplane takeoff and landing requests through a control tower mediator.\n\npackage Mediator;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It demonstrates the functionality of the Flight Control System using the Mediator design pattern.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        ControlTower controlTower = new ControlTower();\n\n        String airplaneId1 = sc.nextLine();\n        String airplaneId2 = sc.nextLine();\n        String airplaneId3 = sc.nextLine();\n        String airplaneId4 = sc.nextLine();\n\n        // TODO: Instantiate an airplane with the first provided ID\n        Airplane airplane1 = new Airplane(airplaneId1);\n\n        // TODO: Instantiate an airplane with the second provided ID\n        Airplane airplane2 = new Airplane(airplaneId2);\n\n        // TODO: Instantiate an airplane with the third provided ID\n        Airplane airplane3 = new Airplane(airplaneId3);\n\n        // TODO: Instantiate an airplane with the fourth provided ID\n        Airplane airplane4 = new Airplane(airplaneId4);\n\n\n        // TODO: Register the first airplane with the control tower\n        controlTower.registerAirplane(airplane1);\n\n\n        // TODO: Register the second airplane with the control tower\n        controlTower.registerAirplane(airplane2);\n\n\n        // TODO: Register the third airplane with the control tower\n        controlTower.registerAirplane(airplane3);\n\n\n        // TODO: Register the fourth airplane with the control tower\n        controlTower.registerAirplane(airplane4);\n\n        airplane1.requestTakeoff();\n        airplane2.requestTakeoff();\n        airplane3.requestTakeoff();\n        airplane4.requestTakeoff();\n\n        // TODO: Mark the first airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane1);\n\n\n        // TODO: Mark the second airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane2);\n\n\n        airplane3.requestTakeoff();\n        airplane4.requestTakeoff();\n\n        // TODO: Mark the third airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane3);\n\n        // TODO: Mark the fourth airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane4);\n\n        airplane1.requestLanding();\n        airplane2.requestLanding();\n\n        // TODO: Mark the first airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane1);\n\n\n        // TODO: Mark the second airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane2);\n\n\n        airplane3.requestLanding();\n        airplane4.requestLanding();\n\n        // TODO: Mark the third airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane3);\n\n\n        // TODO: Mark the fourth airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane4);\n\n\n\n        sc.close();\n    }\n}\n</code></pre> Airplane.java<pre><code>// This class represents an airplane that interacts with the Control Tower mediator for takeoff and landing requests.\n\npackage Mediator;\n\npublic class Airplane {\n    private String id;\n    private Mediator mediator;\n\n    public Airplane(String id) {\n        this.id = id;\n    }\n\n    public void setMediator(Mediator mediator) {\n        this.mediator = mediator;\n    }\n\n    public void requestTakeoff() {\n        System.out.println(\"Airplane \" + id + \" requesting takeoff\");\n\n        // TODO: Notify the mediator to handle the takeoff request for this airplane\n        mediator.handleTakeoffRequest(this);\n\n    }\n\n    public void requestLanding() {\n        System.out.println(\"Airplane \" + id + \" requesting landing\");\n\n        // TODO: Notify the mediator to handle the landing request for this airplane\n        mediator.handleLandingRequest(this);\n\n    }\n\n    public void receiveNotification(String message) {\n        System.out.println(\"Airplane \" + id + \": \" + message);\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n</code></pre> ControlTower.java<pre><code>// This class serves as the mediator, managing communication and runway allocation between airplanes for takeoff and landing.\n\npackage Mediator;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ControlTower implements Mediator {\n\n    private List&lt;Airplane&gt; airplanes;\n    private int takeoffRunways;\n    private int landingRunways;\n\n    public ControlTower() {\n        // TODO: Initialize the list of airplanes to manage communication\n        airplanes = new ArrayList&lt;&gt;();\n\n        this.takeoffRunways = 2;\n        this.landingRunways = 2;\n    }\n\n    @Override\n    public void registerAirplane(Airplane airplane) {\n        // TODO: Add the airplane to the list of registered airplanes\n        airplanes.add(airplane);\n\n        // TODO: Set the mediator for the airplane to enable communication\n        airplane.setMediator(this);\n\n\n    }\n\n    @Override\n    public void handleTakeoffRequest(Airplane airplane) {\n        if (takeoffRunways &gt; 0) {\n            takeoffRunways--; \n            notifyAirplane(airplane, \"Takeoff approved. Runways available: \" + takeoffRunways);\n        } else {\n            notifyAirplane(airplane, \"Takeoff denied. No runways available. Please wait\");\n        }\n    }\n\n    @Override\n    public void handleLandingRequest(Airplane airplane) {\n        if (landingRunways &gt; 0) {\n            landingRunways--;\n            notifyAirplane(airplane, \"Landing approved. Runways available: \" + landingRunways);\n        } else {\n            notifyAirplane(airplane, \"Landing denied. No runways available. Please wait\");\n        }\n    }\n\n    // Simulate the completion of takeoff and free the runway\n    public void completeTakeoff(Airplane airplane) {\n        System.out.println(\"Airplane \" + airplane.getId() + \" has taken off\");\n        takeoffRunways++;\n        System.out.println(\"Runway freed. Available takeoff runways: \" + takeoffRunways);\n    }\n\n    // Simulate the completion of landing and free the runway\n    public void completeLanding(Airplane airplane) {\n        System.out.println(\"Airplane \" + airplane.getId() + \" has landed\");\n        landingRunways++;\n        System.out.println(\"Runway freed. Available landing runways: \" + landingRunways);\n    }\n\n    private void notifyAirplane(Airplane airplane, String message) {\n        // TODO: Notify the airplane of the status message from the control tower\n        airplane.receiveNotification(message);\n    }\n}\n</code></pre> Mediator.java<pre><code>// This interface defines the contract for the mediator responsible for managing airplane communication and requests for takeoff and landing.\n\npackage Mediator;\n\npublic interface Mediator {\n    void registerAirplane(Airplane airplane);\n    void handleTakeoffRequest(Airplane airplane);\n    void handleLandingRequest(Airplane airplane);\n}\n</code></pre>"},{"location":"Design%20Patterns/Creational/","title":"Creational Design Patterns","text":"<p>Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. These patterns help abstract the instantiation process, making it more flexible and dynamic.</p>"},{"location":"Design%20Patterns/Creational/#singleton-pattern","title":"Singleton Pattern","text":"Exercise.java<pre><code>// Exercise.java\n// The Exercise class demonstrates how to use the Logger class to log messages of different severity levels. \n\npackage Singleton;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It prompts the user for info, warning, and error messages and logs them accordingly. \n    public void run() {\n\n        Logger logger = Logger.getInstance();\n        Scanner sc = new Scanner(System.in);\n\n        // Get an info message from the user\n        System.out.print(\"Enter an info message: \");\n        String infoMessage = sc.nextLine();\n\n        // TODO: Log the info message using the appropriate logging method.\n        logger.info(infoMessage);\n\n\n        // Get a warning message from the user\n        System.out.print(\"Enter a warning message: \");\n        String warnMessage = sc.nextLine();\n\n        // TODO: Log the warn message using the appropriate logging method.\n        logger.warn(warnMessage);\n\n\n        // Get an error message from the user\n        System.out.print(\"Enter an error message: \");\n        String errorMessage = sc.nextLine();\n\n        // TODO: Log the error message using the appropriate logging method.\n        logger.error(errorMessage);\n\n\n\n        sc.close();\n    }\n}\n</code></pre> Logger.java<pre><code>// Logger.java\n// The Logger class implements the Singleton Pattern to provide a single point of access for logging messages throughout the application.\n\npackage Singleton;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class Logger {\n\n    private static Logger instance;\n\n    // Private constructor to prevent instantiation\n    private Logger() { \n\n    }\n\n    public static synchronized Logger getInstance() {\n        if (instance == null) {\n            instance = new Logger();\n\n        }\n        return instance;\n    }\n\n    public void info(String message) {\n        log(\"INFO\", message);\n    }\n\n    public void warn(String message) {\n        log(\"WARN\", message);\n    }\n\n    public void error(String message) {\n        log(\"ERROR\", message);\n    }\n\n    private void log(String level, String message) {\n        String timestamp = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n        System.out.println(String.format(\"%s [%s]: %s\", timestamp, level, message));\n    }\n}\n</code></pre>"},{"location":"Design%20Patterns/Creational/#builder-pattern","title":"Builder Pattern","text":"Exercise.java<pre><code>// Exercise.java\n// This file gathers meal components from user input and constructs full and simple meals using the Builder design pattern.\n\npackage Builder;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It handles the meal construction process using user input and the Builder design pattern.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        // Get full meal components from user\n        String fullMainDish = sc.nextLine();\n\n        String fullSideDish = sc.nextLine();\n\n        String fullDrink = sc.nextLine();\n\n        String fullDessert = sc.nextLine();\n\n        String fullAppetizer = sc.nextLine();\n\n        // TODO: Construct a full meal using MealBuilder with the provided components.\n        Meal meal = new MealBuilder(fullMainDish, fullSideDish, fullDrink)\n                        .setDessert(fullDessert)\n                        .setAppetizer(fullAppetizer)\n                        .build();\n\n\n        System.out.println(\"Full Meal Summary:\");\n\n        // TODO: Print the summary of the constructed full meal.\n        meal.printMealSummary();\n\n\n        // Get simple meal components from user\n        String simpleMainDish = sc.nextLine();\n\n        String simpleSideDish = sc.nextLine();\n\n        String simpleDrink = sc.nextLine();\n\n        // TODO: Construct a simple meal using MealBuilder with the provided components.\n        Meal basic_meal = new MealBuilder(fullMainDish, fullSideDish, fullDrink)\n                        .build();\n\n        System.out.println(\"Simple Meal Summary:\");\n\n        // TODO: Print the summary of the constructed simple meal.\n        basic_meal.printMealSummary();\n\n\n        sc.close();\n    }\n}\n</code></pre> MealBuilder.java<pre><code>// MealBuilder.java\n// This file constructs a Meal object by setting mandatory components (main dish, side dish, drink) and optional components (dessert, appetizer) using the Builder design pattern.\n\npackage Builder;\n\npublic class MealBuilder {\n\n    public String mainDish;\n    public String sideDish;\n    public String drink;\n    public String dessert = \"Default Dessert\";\n    public String appetizer = \"Default Appetizer\";\n\n    public MealBuilder(String mainDish, String sideDish, String drink) {\n        // TODO: Initialize MealBuilder components using the provided parameters.\n        this.mainDish = mainDish;\n        this.sideDish = sideDish;\n        this.drink = drink;\n\n    }\n\n    public MealBuilder setDessert(String dessert) {\n        // TODO: Initialize the MealBuilder dessert field with the provided dessert parameter.\n        this.dessert = dessert;\n\n        return this;\n    }\n\n    public MealBuilder setAppetizer(String appetizer) {\n        // TODO: Initialize the MealBuilder appetizer field with the provided dessert parameter.\n\n        this.appetizer = appetizer;\n        return this;\n    }\n\n    public Meal build() {\n        // TODO: Write the return statement to complete the object construction process.\n        return Meal.getInstance(this);\n    }\n}\n</code></pre> Meal.java<pre><code>// This file defines the Meal class, representing a meal's components and providing a method to print the summary.\n\npackage Builder;\n\npublic class Meal {\n\n    private String mainDish;\n    private String sideDish;\n    private String drink;\n    private String dessert;\n    private String appetizer;\n\n    private Meal(MealBuilder builder) {\n        // TODO: Implement the Meal constructor to initialize Meal components from the MealBuilder.\n            this.mainDish = builder.mainDish;\n            this.sideDish = builder.sideDish;\n            this.drink = builder.drink;\n            this.dessert = builder.dessert;\n            this.appetizer = builder.appetizer;\n    }\n\n    public static synchronized Meal getInstance(MealBuilder builder) {\n        //TODO: Return a new instance of Meal using the provided MealBuilder\n        return new Meal(builder);\n\n    }\n\n    public void printMealSummary() {\n        System.out.println(\"Main Dish: \" + mainDish);\n        System.out.println(\"Side Dish: \" + sideDish);\n        System.out.println(\"Drink: \" + drink);\n        System.out.println(\"Dessert: \" + dessert);\n        System.out.println(\"Appetizer: \" + appetizer);\n    }\n}\n</code></pre>"},{"location":"Design%20Patterns/Creational/#factory-pattern","title":"Factory Pattern","text":"Exercise.java<pre><code>// This class handles the creation of document instances based on user input.\n\npackage Factory;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user input for creating document instances based on user commands.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        String documentType = sc.nextLine();\n\n        try {\n            // TODO: Create a document instance using the DocumentFactory based on user input\n            Document document = DocumentFactory.createDocument(documentType);\n\n            // TODO: Display the type of the created document instance\n            document.displayType();\n\n\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n\n        sc.close();\n    }\n}\n</code></pre> DocumentFactory.java<pre><code>// This factory class is responsible for creating instances of different document types.\n\npackage Factory;\n\npublic class DocumentFactory {\n\n    public static Document createDocument(String type) {\n\n        switch (type.toLowerCase()) {\n            case \"pdf\":\n                // TODO: Return a new instance of PDFDocument\n\n                return new PDFDocument();\n            case \"word\":\n                // TODO: Return a new instance of WordDocument\n\n                return new WordDocument();\n            case \"html\":\n                // TODO: Return a new instance of HTMLDocument\n\n                return new HTMLDocument();\n            default:\n                throw new IllegalArgumentException(\"Unknown document type: \" + type);\n        }\n    }\n}\n</code></pre> PDFDocument.java<pre><code>// This class represents a PDF document type.\n\npackage Factory;\n\npublic class PDFDocument extends Document {\n\n    @Override\n    public void displayType() {\n        System.out.println(\"Creating a PDF Document\");\n    }\n}\n</code></pre> WordDocument.java<pre><code>// This class represents a Word document type.\n\npackage Factory;\n\npublic class WordDocument extends Document {\n\n    @Override\n    public void displayType() {\n        System.out.println(\"Creating a Word Document\");\n    }\n}\n</code></pre> HTMLDocument.java<pre><code>// This class represents a HTML document type.\n\npackage Factory;\n\npublic class HTMLDocument extends Document {\n\n    @Override\n    public void displayType() {\n        System.out.println(\"Creating an HTML Document\");\n    }\n}\n</code></pre> Document.java<pre><code>// This abstract class represents the structure for various document types.\n\npackage Factory;\n\npublic abstract class Document {\n    public abstract void displayType();\n}\n</code></pre>"},{"location":"Design%20Patterns/Creational/#abstract-factory-pattern","title":"Abstract Factory Pattern","text":""},{"location":"Design%20Patterns/Creational/#prototype-pattern","title":"Prototype Pattern","text":"Exercise.java<pre><code>// This class demonstrates the use of the Prototype Design Pattern for cloning characters.\n\npackage Prototype;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to gather user input and manage character states.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        String warriorName = sc.nextLine();\n\n        int health = sc.nextInt();\n\n        int attackPower = sc.nextInt();\n\n        int defense = sc.nextInt();\n\n        Warrior warrior = new Warrior(warriorName, health, attackPower, defense);\n\n        // TODO: Clone the original warrior character to create a new instance.\n        Warrior clonedWarrior = warrior.clone();\n\n        int clonedHealth = sc.nextInt();\n\n        int clonedAttackPower = sc.nextInt();\n\n        int clonedDefense = sc.nextInt();\n\n        clonedWarrior.setHealth(clonedHealth);\n        clonedWarrior.setAttackPower(clonedAttackPower);\n        clonedWarrior.setDefense(clonedDefense);\n\n        System.out.println(\"Original Character:\");\n\n        // TODO: Display the original warrior's attributes\n       warrior.displayAttributes();\n\n\n\n        System.out.println(\"\\nCloned Character:\");\n\n        // TODO: Display the cloned warrior's attributes\n        clonedWarrior.displayAttributes();\n\n\n        sc.close();\n    }\n}\n</code></pre> Warrior.java<pre><code>// This class represents a Warrior character in the Prototype Design Pattern.\n\npackage Prototype;\n\npublic class Warrior implements Character {\n\n    private String name;\n    private int health;\n    private int attackPower;\n    private int defense;\n\n    public Warrior(String name, int health, int attackPower, int defense) {\n        this.name = name;\n        this.health = health;\n        this.attackPower = attackPower;\n        this.defense = defense;\n    }\n\n    @Override\n    public Warrior clone() {\n        // TODO: Return a new Warrior instance with the given set of attributes.\n        return new Warrior(name, health, attackPower, defense);\n\n    }\n\n    @Override\n    public void displayAttributes() {\n        System.out.println(\"Warrior - Name: \" + name + \", Health: \" + health + \", Attack Power: \" + attackPower + \", Defense: \" + defense);\n    }\n\n    // Getters\n    public String getName() {\n        return name;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getAttackPower() {\n        return attackPower;\n    }\n\n    public int getDefense() {\n        return defense;\n    }\n\n    // Setters\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setAttackPower(int attackPower) {\n        this.attackPower = attackPower;\n    }\n\n    public void setDefense(int defense) {\n        this.defense = defense;\n    }\n}\n</code></pre> Mage.java<pre><code>// This class represents a Mage character in the Prototype Design Pattern.\n\npackage Prototype;\n\npublic class Mage implements Character {\n\n    private String name;\n    private int health;\n    private int attackPower;\n    private int defense;\n\n    public Mage(String name, int health, int attackPower, int defense) {\n        this.name = name;\n        this.health = health;\n        this.attackPower = attackPower;\n        this.defense = defense;\n    }\n\n    @Override\n    public Mage clone() {\n        // TODO: Return a new Mage instance with the given set of attributes.\n        return new Mage(name, health, attackPower, defense);\n\n    }\n\n    @Override\n    public void displayAttributes() {\n        System.out.println(\"Mage - Name: \" + name + \", Health: \" + health + \", Attack Power: \" + attackPower + \", Defense: \" + defense);\n    }\n\n    // Getters\n    public String getName() {\n        return name;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getAttackPower() {\n        return attackPower;\n    }\n\n    public int getDefense() {\n        return defense;\n    }\n\n    // Setters\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setAttackPower(int attackPower) {\n        this.attackPower = attackPower;\n    }\n\n    public void setDefense(int defense) {\n        this.defense = defense;\n    }\n}\n</code></pre> Archer.java<pre><code>// This class represents a Archer character in the Prototype Design Pattern.\n\npackage Prototype;\n\npublic class Archer implements Character {\n\n    private String name;\n    private int health;\n    private int attackPower;\n    private int defense;\n\n    public Archer(String name, int health, int attackPower, int defense) {\n        this.name = name;\n        this.health = health;\n        this.attackPower = attackPower;\n        this.defense = defense;\n    }\n\n    @Override\n    public Archer clone() {\n        // TODO: Return a new Archer instance with the given set of attributes.\n        return new Archer(name, health, attackPower, defense);\n\n    }\n\n    @Override\n    public void displayAttributes() {\n        System.out.println(\"Archer - Name: \" + name + \", Health: \" + health + \", Attack Power: \" + attackPower + \", Defense: \" + defense);\n    }\n\n    // Getters\n    public String getName() {\n        return name;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getAttackPower() {\n        return attackPower;\n    }\n\n    public int getDefense() {\n        return defense;\n    }\n\n    // Setters\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setAttackPower(int attackPower) {\n        this.attackPower = attackPower;\n    }\n\n    public void setDefense(int defense) {\n        this.defense = defense;\n    }\n}\n</code></pre> Character.java<pre><code>// This interface defines the behavior for cloning and displaying attributes of character objects.\n\npackage Prototype;\n\npublic interface Character {\n    Character clone();\n    void displayAttributes();\n}\n</code></pre>"},{"location":"Design%20Patterns/Structural/","title":"Structural Design Patterns","text":"<p>Structural patterns deal with object composition and how large structures are formed by combining classes and objects. These patterns focus on simplifying the structure by identifying relationships.</p>"},{"location":"Design%20Patterns/Structural/#adapter-pattern","title":"Adapter Pattern","text":"Exercise.java<pre><code>// This class demonstrates the usage of different weather services through the Adapter pattern.\n\npackage Adapter;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to demonstrate the usage of legacy and new weather services through the Adapter pattern.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        String legacyTemperature = sc.nextLine();\n        String legacyCondition = sc.nextLine();\n\n        // Using the legacy weather service with user input\n        WeatherService legacyService = new LegacyWeatherService(legacyTemperature, legacyCondition);\n        System.out.println(\"Legacy Weather Service Data:\");\n\n        // TODO: Print the weather data retrieved from the Legacy weather service.\n        System.out.println(legacyService.getWeatherData());\n\n        String temperature = sc.nextLine();\n        String condition = sc.nextLine();\n\n        NewWeatherService newService = new NewWeatherService(temperature, condition);\n\n        // TODO: Create an adapter for the new weather service.\n\n\n        WeatherService adaptedService = new NewWeatherServiceAdapter(newService);\n        System.out.println(\"New Weather Service Data:\");\n\n        // TODO: Print the weather data retrieved from the new weather service.\n        System.out.println(adaptedService.getWeatherData());\n\n\n        sc.close();\n    }\n}\n</code></pre> LegacyWeatherService.java<pre><code>// The Legacy class that provides weather data in XML format.\n\npackage Adapter;\n\npublic class LegacyWeatherService implements WeatherService {\n\n    private String temperature;\n    private String condition;\n\n    public LegacyWeatherService(String temperature, String condition) {\n        this.temperature = temperature;\n        this.condition = condition;\n    }\n\n    @Override\n    public String getWeatherData() {\n        return \"&lt;weather&gt;&lt;temperature&gt;\" + temperature + \"&lt;/temperature&gt;&lt;condition&gt;\" + condition + \"&lt;/condition&gt;&lt;/weather&gt;\";\n    }\n}\n</code></pre> NewWeatherService.java<pre><code>// The New class that provides weather data in JSON format.\n\npackage Adapter;\n\npublic class NewWeatherService {\n\n    private String temperature;\n    private String condition;\n\n    public NewWeatherService(String temperature, String condition) {\n        this.temperature = temperature;\n        this.condition = condition;\n    }\n\n    public String fetchWeather() {\n        return \"{\\\"temperature\\\": \" + temperature + \", \\\"condition\\\": \\\"\" + condition + \"\\\"}\";\n    }\n}\n</code></pre> NewWeatherServiceAdapter.java<pre><code>// The Adapter class that adapts the new weather service to the WeatherService interface.\n\npackage Adapter;\n\npublic class NewWeatherServiceAdapter implements WeatherService {\n\n    private NewWeatherService newWeatherService;\n\n    public NewWeatherServiceAdapter(NewWeatherService newWeatherService) {\n        this.newWeatherService = newWeatherService;\n    }\n\n    @Override\n    public String getWeatherData() {\n        // TODO: Fetch weather data from the new weather service and return the formatted data\n        String data = newWeatherService.fetchWeather();\n        return data;\n\n    }\n}\n</code></pre> WeatherService.java<pre><code>// This interface defines a consistent contract for retrieving weather data from various weather services.\n\npackage Adapter;\n\npublic interface WeatherService {\n    String getWeatherData();\n}\n</code></pre>"},{"location":"Design%20Patterns/Structural/#decorator-pattern","title":"Decorator Pattern","text":"Exercise.java<pre><code>// The Exercise class facilitates user interaction to create a customized coffee by allowing the selection of various ingredients and then outputs the final coffee description and total cost.\n\npackage Decorator;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to demonstrate the usage of the Decorator pattern for customizing coffee with various ingredients.\n    public void run(){\n\n        Scanner sc = new Scanner(System.in);\n\n        Coffee coffee = new BasicCoffee();\n\n        boolean addMoreIngredients = true;\n\n        while (addMoreIngredients) {\n\n            String choices = sc.nextLine();\n            String[] ingredients = choices.split(\" \");\n\n            for (String choice : ingredients) {\n\n                switch (choice) {\n                    case \"1\":\n                        // TODO: Complete the implementation for adding Milk to the coffee.\n                        coffee = new Milk(coffee);\n\n                        break;\n                    case \"2\":\n                        // TODO: Complete the implementation for adding Sugar to the coffee.\n                        coffee = new Sugar(coffee);\n\n                        break;\n                    case \"3\":\n                        // TODO: Complete the implementation for adding Whipped Cream to the coffee.\n\n                        coffee = new WhippedCream(coffee);\n                        break;\n                    case \"4\":\n                        addMoreIngredients = false;\n                        break;\n                    default:\n                        System.out.println(\"Invalid choice: \" + choice);\n                        break;\n                }\n            }\n\n            if (!addMoreIngredients) {\n                break;\n            }\n        }\n\n        System.out.println(\"Final Coffee Description: \" + coffee.getDescription());\n        System.out.println(\"Total Cost: $\" + coffee.getCost());\n\n        sc.close();\n    }\n}\n</code></pre> CoffeeDecorator.java<pre><code>// Abstract class for decorating Coffee objects, allowing additional features to be added while preserving core functionality.\n\npackage Decorator;\n\npublic abstract class CoffeeDecorator implements Coffee {\n    protected Coffee coffee;\n\n    public CoffeeDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n\n    @Override\n    public String getDescription() {\n        // TODO: Complete this method to return the description of the decorated coffee.\n        return coffee.getDescription();\n    }\n\n    @Override\n    public double getCost() {\n        // TODO: Complete this method to return the cost of the decorated coffee.\n        return coffee.getCost();\n    }\n}\n</code></pre> Milk.java<pre><code>// Concrete decorator class that adds Milk to a Coffee object, modifying its description and cost accordingly.\n\npackage Decorator;\n\npublic class Milk extends CoffeeDecorator {\n\n    public Milk(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Milk\";\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.50; \n    }\n}\n</code></pre> Sugar.java<pre><code>// Concrete decorator class that adds Sugar to a Coffee object, enhancing its description and adjusting its cost.\n\npackage Decorator;\n\npublic class Sugar extends CoffeeDecorator {\n\n    public Sugar(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Sugar\";\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.30; \n    }\n}\n</code></pre> WhippedCream.java<pre><code>// Concrete decorator class that adds Whipped Cream to a Coffee object, enhancing its description and adjusting its cost.\n\npackage Decorator;\n\npublic class WhippedCream extends CoffeeDecorator {\n\n    public WhippedCream(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Whipped Cream\";\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.70; \n    }\n}\n</code></pre> BasicCoffee.java<pre><code>// This class represents implementation of the Coffee interface representing a basic coffee with a fixed description and cost.\n\npackage Decorator;\n\npublic class BasicCoffee implements Coffee {\n\n    @Override\n    public String getDescription() {\n        return \"Basic Coffee\";\n    }\n\n    @Override\n    public double getCost() {\n        return 3.00; \n    }\n}\n</code></pre> Coffee.java<pre><code>// This interface defines the contract for Coffee objects, requiring methods for obtaining the description and cost.\n\npackage Decorator;\n\npublic interface Coffee {\n    String getDescription();\n    double getCost();\n}\n</code></pre>"},{"location":"Design%20Patterns/Structural/#proxy-pattern","title":"Proxy Pattern","text":"Exercise.java<pre><code>// This class demonstrates the use of the Proxy Design Pattern to manage access to a network service and cache responses.\n\npackage Proxy;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It demonstrates the usage of the Proxy Design Pattern to manage access to a network service.\n    public void run() {\n\n        NetworkService networkService = new NetworkServiceProxy();\n        Scanner sc = new Scanner(System.in);\n\n        String userInput = sc.nextLine();\n\n        // TODO: Fetch data using the networkService and print the result\n        String fetch = networkService.fetchData(userInput);\n        System.out.println(fetch);\n\n\n        // TODO: Fetch data again using the networkService (should retrieve from cache) and print the result\n        String Refetch = networkService.fetchData(userInput);\n        System.out.println(Refetch);\n\n        sc.close();\n    }\n}\n</code></pre> NetworkServiceProxy.java<pre><code>// This class implements the Proxy Design Pattern to manage access to the RealNetworkService and cache responses.\n\npackage Proxy;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NetworkServiceProxy implements NetworkService {\n\n    private RealNetworkService realNetworkService;\n    private Map&lt;String, String&gt; cache;\n\n    public NetworkServiceProxy() {\n        // TODO: Initialize the cache to store fetched data.\n        cache = new HashMap&lt;&gt;();\n    }\n\n    @Override\n    public String fetchData(String input) {\n\n        if (cache.containsKey(input)) {\n            System.out.println(\"Fetching data from cache\");\n\n            // TODO: Return the cached data for the given input.\n            return cache.get(input);\n\n        }\n\n        if (realNetworkService == null) {\n            // TODO: Initialize the RealNetworkService if it has not been created yet.\n            realNetworkService = new RealNetworkService();\n\n        }\n\n        // TODO: Fetch data from the real network service using the provided input.\n        String data = realNetworkService.fetchData(input);\n\n        // TODO: Cache the fetched data with the input as the key for future access.\n        cache.put(input, data);\n\n        // TODO: Return the fetched data to the client.\n        return data;\n\n    }\n}\n</code></pre> RealNetworkService.java<pre><code>// This class represents the actual network service that fetches data from a remote server.\n\npackage Proxy;\n\npublic class RealNetworkService implements NetworkService {\n\n    private String data;\n\n    @Override\n    public String fetchData(String input) {\n        data = \"Data fetched from remote server for input: \" + input;\n        return data;\n    }\n}\n</code></pre> NetworkService.java<pre><code>// This interface defines the contract for network services that fetch data based on user input.\n\npackage Proxy;\n\npublic interface NetworkService {\n    String fetchData(String input);\n}\n</code></pre>"},{"location":"Design%20Patterns/Structural/#composite-pattern","title":"Composite Pattern","text":""},{"location":"Design%20Patterns/Structural/#facade-pattern","title":"Facade Pattern","text":""},{"location":"Design%20Patterns/Structural/#flyweight-pattern","title":"Flyweight Pattern","text":""},{"location":"DevOps/Scripting/","title":"Scripting","text":""},{"location":"DevOps/Scripting/#shell","title":"Shell","text":""},{"location":"DevOps/Scripting/#important-commands","title":"Important Commands","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/","title":"package manager and virtual environment","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#pip","title":"PIP","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#venev","title":"venev","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#anaconda","title":"Anaconda","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#pyenv","title":"pyenv","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#uv","title":"uv","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#poetry","title":"poetry","text":""}]}