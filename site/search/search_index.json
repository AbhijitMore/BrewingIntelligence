{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>"},{"location":"#brewing-intelligence","title":"Brewing Intelligence","text":"Welcome to your hub for AI knowledge! Explore free resources on AI, Machine Learning, Deep Learning, and MLOps.  Our mission is to share knowledge, foster growth, and build a collaborative community passionate  about advancing AI for everyone. Join us and start learning today!"},{"location":"#contents","title":"Contents","text":"\ud83d\udc0d Python <li>Basics</li> <li>Modules and Packages</li> <li>OOP</li> <li>Advanced Python</li> <li>Handling Database</li> <li>Network and Security</li> <li>Web Scraping</li> \ud83d\udcca Data Analysis <li>NumPy</li> <li>Scipy</li> <li>Pandas</li> <li>Polars</li> <li>Visualization</li> <li>Handling Images</li> \ud83e\udde0 Deep Learning <li>Neural Networks Basics</li> <li>Optimization Algorithms</li> <li>Training Deep Networks</li> <li>Computer Vision</li> <li>Natural Language Processing</li> \ud83d\udd22 DSA <li>Basics</li> <li>Pattern</li> \ud83d\udcda Machine Learning <li>Linear Regression</li> <li>Logistic Regression</li> <li>Naive Bayes</li> <li>K Nearest Neighbours</li> <li>Support Vector Machine</li> <li>Decision Tree</li> <li>Ensemble Techniques</li> <li>Dimensionality Reduction</li> <li>Clustering</li> <li>Recommendation Systems</li> \ud83e\udd16 Gen AI <ul> <li>RBMs</li> <li>GANs</li> <li>VAEs</li> <li>Diffusion Models</li> <li>Transformers</li> \ud83e\udde9 Design Pattern <li>Behavioural Patterns</li> <li>Creational Patterns</li> <li>Structural Patterns</li> \u2699\ufe0f DevOps <li>Scripting</li> <li>Package Manager and Virtual Environment</li> <li>Publishing Python Packages</li> <li>Continuous Integration</li> <li>Flask</li> <li>Docker</li> <li>Mlflow</li> <li>Logging</li> <li>Documentation, Styling and Pre Commit</li> Hello! I'm Abhijit More     I am passionate Software Engineer (AI/ML) focused on creating innovative AI solutions that solve real-world problems.    I specialize in leveraging deep learning, machine learning, and AI technologies to develop impactful products. \ud83e\udd16\ud83d\udca1    I am currently a Software Engineer (AI/ML) at Sony India Software Centre, where I work on deploying AI models on low-power, low-memory edge devices for applications like image classification and object detection. My role involves optimizing deep learning models to meet stringent hardware requirements, ensuring high performance even in resource-constrained environments. \u2699\ufe0f\ud83d\udcf1    Before Sony, I spent time at IIT Madras Pravartak, where I deepened my expertise in AI, particularly large language models and transformers, while working on several impactful projects. Additionally, I worked at HighRadius as an Associate Software Engineer, developing AI-powered solutions for financial operations, including a predictive model for invoice payment dates. \ud83d\udcbc\ud83d\udcbb"},{"location":"Data%20Engineering/Kafka/","title":"Kafka","text":""},{"location":"Data%20Engineering/Kafka/#introduction","title":"Introduction","text":""},{"location":"Data%20Engineering/Spark/","title":"Spark","text":""},{"location":"Data%20Engineering/Spark/#basics","title":"Basics","text":""},{"location":"Deep%20Learning/Segmentation/","title":"Segmentation","text":""},{"location":"Deep%20Learning/Segmentation/#instance-segmentation","title":"Instance Segmentation","text":""},{"location":"Deep%20Learning/Segmentation/#semantic-segmentation","title":"Semantic Segmentation","text":""},{"location":"DevOps/Build%20Systems/","title":"Build Systems","text":"<p>## make</p>"},{"location":"DevOps/Continuous%20Integration/","title":"Continuous Integration","text":""},{"location":"DevOps/Continuous%20Integration/#github-actions","title":"Github Actions","text":""},{"location":"DevOps/Git/","title":"Git","text":""},{"location":"DevOps/Git/#data-model","title":"Data Model","text":""},{"location":"DevOps/Git/#example","title":"Example","text":""},{"location":"DevOps/Shell/","title":"Shell","text":""},{"location":"DevOps/Shell/#important-commands","title":"Important Commands","text":""},{"location":"DevOps/Shell/#tools","title":"Tools","text":""},{"location":"DevOps/Shell/#rg","title":"rg","text":""},{"location":"DevOps/Shell/#tldr","title":"tldr","text":""},{"location":"DevOps/Shell/#tree","title":"tree","text":""},{"location":"DevOps/Shell/#broot","title":"broot","text":""},{"location":"DevOps/Shell/#zinit","title":"zinit","text":""},{"location":"DevOps/Shell/#tmux","title":"tmux","text":""},{"location":"DevOps/Shell/#introduction-to-tmux","title":"Introduction to tmux","text":""},{"location":"DevOps/Shell/#basic-tmux-commands","title":"Basic tmux Commands","text":""},{"location":"DevOps/Shell/#navigating-tmux","title":"Navigating tmux","text":""},{"location":"DevOps/Shell/#keybindings-and-tmux-commands","title":"Keybindings and tmux Commands","text":""},{"location":"DevOps/Shell/#session-management","title":"Session Management","text":""},{"location":"DevOps/Shell/#advanced-tmux-features","title":"Advanced tmux Features","text":""},{"location":"DevOps/Shell/#configuration-and-customization","title":"Configuration and Customization","text":""},{"location":"DevOps/Shell/#tmux-plugins-and-extensions","title":"tmux Plugins and Extensions","text":""},{"location":"DevOps/Shell/#troubleshooting-and-best-practices","title":"Troubleshooting and Best Practices","text":""},{"location":"DevOps/Shell/#dotfiles","title":"Dotfiles","text":""},{"location":"DevOps/Shell/#ssh","title":"ssh","text":""},{"location":"DevOps/Shell/#scp","title":"scp","text":""},{"location":"DevOps/ZenML/","title":"ZenML","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/","title":"package manager and virtual environment","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#pip","title":"PIP","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#venev","title":"venev","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#anaconda","title":"Anaconda","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#poetry","title":"poetry","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#pyenv","title":"pyenv","text":""},{"location":"DevOps/package%20manager%20and%20virtual%20environment/#uv","title":"uv","text":""},{"location":"Gen%20AI/Diffusion%20Models/","title":"Diffusion Models","text":""},{"location":"Gen%20AI/Diffusion%20Models/#introduction","title":"Introduction","text":""},{"location":"Gen%20AI/Diffusion%20Models/#ddpm","title":"DDPM","text":""},{"location":"Gen%20AI/Diffusion%20Models/#classifier-guided-diffusion","title":"Classifier Guided Diffusion","text":""},{"location":"Gen%20AI/Diffusion%20Models/#classifier-free-diffusion","title":"Classifier free Diffusion","text":""},{"location":"Gen%20AI/Diffusion%20Models/#stable-diffusion","title":"Stable Diffusion","text":""},{"location":"Gen%20AI/Diffusion%20Models/#flux","title":"Flux","text":""},{"location":"Gen%20AI/Diffusion%20Models/#resources","title":"Resources","text":""},{"location":"Gen%20AI/Restricted%20Boltzmann%20Machines/","title":"Restricted Boltzmann Machines","text":""},{"location":"Gen%20AI/Restricted%20Boltzmann%20Machines/#probability-recap","title":"Probability Recap","text":""},{"location":"Gen%20AI/Restricted%20Boltzmann%20Machines/#baysian-networks","title":"Baysian Networks","text":""},{"location":"Gen%20AI/Restricted%20Boltzmann%20Machines/#markov-networks","title":"Markov Networks","text":""},{"location":"Gen%20AI/Restricted%20Boltzmann%20Machines/#markov-chains","title":"Markov Chains","text":""},{"location":"Gen%20AI/Restricted%20Boltzmann%20Machines/#rbms","title":"RBMs","text":""},{"location":"Gen%20AI/Transformers/","title":"Transformers","text":""},{"location":"Gen%20AI/Transformers/#large-language-model","title":"Large Language Model","text":""},{"location":"Gen%20AI/Transformers/#vision-transformer","title":"Vision Transformer","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/","title":"Searching","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#linear-search","title":"Linear Search","text":"<pre><code>def linear_search(arr, target):\n    for index in range(len(arr)):\n        if arr[index] == target:\n            return index\n    return -1\n\nnumbers = [10, 20, 30, 40, 50]\ntarget = 30\nresult = linear_search(numbers, target)\nif result != -1:\n    print(f\"Element found at index {result}\")\nelse:\n    print(\"Element not found\")\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Searching/#binary-search","title":"Binary Search","text":"<pre><code>def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] &gt; target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n\nnumbers = [10, 20, 30, 40, 50, 60, 70]\ntarget = 30\nresult = binary_search(numbers, target)\nif result != -1:\n    print(f\"Element found at index {result}\")\nelse:\n    print(\"Element not found\")\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Searching/#problems","title":"Problems","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#introductory-problems","title":"Introductory Problems","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#upper-bound-and-lower-bound","title":"Upper Bound and Lower Bound","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#search-on-matrix","title":"Search on Matrix","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#missing-and-repeating-number","title":"Missing and Repeating Number","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#binary-search-on-semi-sorted-space","title":"Binary Search on Semi-Sorted Space","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#binary-search-on-answer","title":"Binary Search On Answer","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#minmax-problems","title":"Minmax Problems","text":""},{"location":"Programming/Algorithmic%20Concepts/Searching/#finding-the-k-th-element","title":"Finding the K-th Element","text":""},{"location":"Programming/Algorithmic%20Concepts/Sorting/","title":"Sorting","text":""},{"location":"Programming/Algorithmic%20Concepts/Sorting/#simple-comparison-based-algorithms","title":"Simple Comparison-based Algorithms","text":""},{"location":"Programming/Algorithmic%20Concepts/Sorting/#1-bubble-sort","title":"1. Bubble Sort","text":"BasicOptimized <pre><code>def bubble_sort(numbers):\n    length = len(numbers)\n    for i in range(length-1):\n        for j in range(length-i-1):\n            if numbers[j]&gt;numbers[j+1]:\n                numbers[j],numbers[j+1] = numbers[j+1], numbers[j]\n    return numbers\n\nnumbers = [60,40,70,20,50,30,90,45]\nsorted_numbers = bubble_sort(numbers)\nprint(sorted_numbers)\n</code></pre> <pre><code>def bubble_sort(numbers):\n    length = len(numbers)\n    for i in range(length-1):\n        swapped = False\n        for j in range(length-i-1):\n            if numbers[j]&gt;numbers[j+1]:\n                numbers[j],numbers[j+1] = numbers[j+1], numbers[j]\n                swapped = True\n        if not swapped:\n            break\n    return numbers\n\nnumbers = [60,40,70,20,50,30,90,45]\nsorted_numbers = bubble_sort(numbers)\nprint(sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#2-insertion-sort","title":"2. Insertion Sort","text":"<pre><code>def insertion_sort(numbers):\n    for i in range(1, len(numbers)):\n        key = numbers[i]\n        j = i - 1\n        while j &gt;= 0 and numbers[j] &gt; key:\n            numbers[j + 1] = numbers[j]\n            j -= 1\n        numbers[j + 1] = key\n    return numbers\n\nnumbers = [60,40,70,20,50,30,90,45]\nsorted_numbers = selection_sort(numbers)\nprint(sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#3-selection-sort","title":"3. Selection Sort","text":"<pre><code>def selection_sort(numbers):\n    length = len(numbers)\n    for i in range(length-1):\n        min_index = i\n        for j in range(i+1, length):\n            if numbers[j]&lt;numbers[min_index]:\n                min_index = j\n        numbers[min_index],numbers[i] = numbers[i], numbers[min_index]\n    return numbers\n\nnumbers = [60,40,70,20,50,30,90,45]\nsorted_numbers = selection_sort(numbers)\nprint(sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#efficient-comparison-based-algorithms","title":"Efficient Comparison-based Algorithms","text":""},{"location":"Programming/Algorithmic%20Concepts/Sorting/#4-merge-sort","title":"4. Merge Sort","text":"<pre><code>def merge(left, right):\n    result = []\n    i = j = 0\n\n    while i &lt; len(left) and j &lt; len(right):\n        if left[i] &lt; right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n\n    return result\n\ndef merge_sort(numbers):\n\n    if len(numbers) &lt;= 1: return numbers\n    mid = len(numbers) // 2\n\n    left_half = merge_sort(numbers[:mid])\n    right_half = merge_sort(numbers[mid:])\n\n    return merge(left_half, right_half)\n\nnumbers = [60,40,70,20,50,30,90,45]\nsorted_numbers = merge_sort(numbers)\nprint(sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#5-quick-sort","title":"5. Quick Sort","text":"Naive partitionLomuto partitionHoare partition <pre><code>def naive_partition(numbers, pivot):\n    length = len(numbers)\n    numbers[pivot], numbers[length-1] = numbers[length-1], numbers[pivot]\n    temp = []\n\n    for x in numbers:\n        if x&lt;=numbers[length-1]:\n            temp.append(x)\n    for x in numbers:\n        if x&gt;numbers[length-1]:\n            temp.append(x)\n    for i in range(length):\n        numbers[i] = temp[i]\n\ndef quick_sort(numbers):\n    if len(numbers) &lt;= 1:\n        return numbers\n    pivot_index = len(numbers) - 1\n    naive_partition(numbers, pivot_index)\n    left = [x for x in numbers if x &lt;= numbers[pivot_index] and x != numbers[pivot_index]]\n    right = [x for x in numbers if x &gt; numbers[pivot_index]]\n    return quick_sort(left) + [numbers[pivot_index]] + quick_sort(right)\n\nnumbers = [60, 40, 70, 20, 50, 30, 90, 45]\nsorted_numbers = quick_sort(numbers)\nprint(sorted_numbers)\n</code></pre> <pre><code>def lomuto_partition(numbers, low, high):\n    pivot = numbers[high]\n    i = low - 1\n    for j in range(low, high):\n        if numbers[j] &lt;= pivot:\n            i += 1\n            numbers[i], numbers[j] = numbers[j], numbers[i]\n    numbers[i + 1], numbers[high] = numbers[high], numbers[i + 1]\n    return i + 1\n\ndef lomuto_quick_sort(numbers, low, high):\n    if low &lt; high:\n        pi = lomuto_partition(numbers, low, high)\n        lomuto_quick_sort(numbers, low, pi - 1)\n        lomuto_quick_sort(numbers, pi + 1, high)\n\nnumbers = [60, 40, 70, 20, 50, 30, 90, 45]\nlomuto_quick_sort(numbers, 0, len(numbers) - 1)\nprint(\"Lomuto Quick Sort:\", numbers)\n</code></pre> <pre><code>def hoare_partition(numbers, low, high):\n    pivot = numbers[low]\n    i = low - 1\n    j = high + 1\n    while True:\n        i += 1\n        while numbers[i] &lt; pivot:\n            i += 1\n        j -= 1\n        while numbers[j] &gt; pivot:\n            j -= 1\n        if i &gt;= j:\n            return j\n        numbers[i], numbers[j] = numbers[j], numbers[i]\n\ndef hoare_quick_sort(numbers, low, high):\n    if low &lt; high:\n        pi = hoare_partition(numbers, low, high)\n        hoare_quick_sort(numbers, low, pi)\n        hoare_quick_sort(numbers, pi + 1, high)\n\nnumbers = [60, 40, 70, 20, 50, 30, 90, 45]\nhoare_quick_sort(numbers, 0, len(numbers) - 1)\nprint(\"Hoare Quick Sort:\", numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#6-heap-sort","title":"6. Heap Sort","text":"<pre><code>def heap_sort(numbers):\n    def heapify(numbers, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left &lt; n and numbers[left] &gt; numbers[largest]:\n            largest = left\n        if right &lt; n and numbers[right] &gt; numbers[largest]:\n            largest = right\n\n        if largest != i:\n            numbers[i], numbers[largest] = numbers[largest], numbers[i]\n            heapify(numbers, n, largest)\n\n    n = len(numbers)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(numbers, n, i)\n\n    for i in range(n - 1, 0, -1):\n        numbers[i], numbers[0] = numbers[0], numbers[i]\n        heapify(numbers, i, 0)\n\n    return numbers\n\nnumbers = [60, 40, 70, 20, 50, 30, 90, 45]\nsorted_numbers = heap_sort(numbers)\nprint(\"Sorted numbers:\", sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#hybrid-comparison-based-algorithms","title":"Hybrid Comparison-based Algorithms","text":""},{"location":"Programming/Algorithmic%20Concepts/Sorting/#7-tim-sort","title":"7. tim sort","text":"<pre><code>def insertion_sort(arr, left, right):\n    for i in range(left + 1, right + 1):\n        key = arr[i]\n        j = i - 1\n        while j &gt;= left and arr[j] &gt; key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef merge(arr, left, mid, right):\n    left_sub = arr[left:mid + 1]\n    right_sub = arr[mid + 1:right + 1]\n    i, j, k = 0, 0, left\n\n    while i &lt; len(left_sub) and j &lt; len(right_sub):\n        if left_sub[i] &lt;= right_sub[j]:\n            arr[k] = left_sub[i]\n            i += 1\n        else:\n            arr[k] = right_sub[j]\n            j += 1\n        k += 1\n\n    arr[k:k + len(left_sub) - i] = left_sub[i:]\n    arr[k:k + len(right_sub) - j] = right_sub[j:]\n\ndef timsort(arr):\n    n = len(arr)\n    RUN = 32\n\n    for start in range(0, n, RUN):\n        end = min(start + RUN - 1, n - 1)\n        insertion_sort(arr, start, end)\n\n    size = RUN\n    while size &lt; n:\n        for start in range(0, n, 2 * size):\n            mid = min(n - 1, start + size - 1)\n            end = min(start + 2 * size - 1, n - 1)\n            if mid &lt; end:\n                merge(arr, start, mid, end)\n        size *= 2\n\n    return arr\n\nnumbers = [60, 40, 70, 20, 50, 30, 90, 45]\nsorted_numbers = timsort(numbers)\nprint(\"Sorted array:\", sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#8-intro-sort","title":"8. Intro sort","text":"<pre><code>import math\n\ndef insertion_sort(arr, left, right):\n    for i in range(left + 1, right + 1):\n        key = arr[i]\n        j = i - 1\n        while j &gt;= left and arr[j] &gt; key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left &lt; n and arr[left] &gt; arr[largest]:\n        largest = left\n    if right &lt; n and arr[right] &gt; arr[largest]:\n        largest = right\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heapsort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\ndef quicksort(arr, left, right, depth_limit):\n    if left &lt; right:\n        if right - left &lt; 16:\n            insertion_sort(arr, left, right)\n        elif depth_limit == 0:\n            heapsort(arr[left:right+1])\n        else:\n            pivot = partition(arr, left, right)\n            quicksort(arr, left, pivot - 1, depth_limit - 1)\n            quicksort(arr, pivot + 1, right, depth_limit - 1)\n\ndef partition(arr, left, right):\n    pivot = arr[right]\n    i = left - 1\n    for j in range(left, right):\n        if arr[j] &lt;= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[right] = arr[right], arr[i + 1]\n    return i + 1\n\ndef introsort(arr):\n    depth_limit = int(math.log2(len(arr)) * 2)\n    quicksort(arr, 0, len(arr) - 1, depth_limit)\n    return arr\n\nimport random\nnumbers = [random.randint(1, 1000) for _ in range(500)]\nsorted_numbers = introsort(numbers)\nprint(\"Sorted array:\", sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#non-comparison-based-algorithms","title":"Non-Comparison-based Algorithms","text":""},{"location":"Programming/Algorithmic%20Concepts/Sorting/#9-counting-sort","title":"9. Counting Sort","text":"<pre><code>def counting_sort(numbers):\n    max_value = max(numbers)\n    count = [0] * (max_value + 1)\n\n    for num in numbers:\n        count[num] += 1\n\n    sorted_numbers = []\n    for value in range(len(count)):\n        sorted_numbers.extend([value] * count[value])\n\n    return sorted_numbers\n\nnumbers = [60, 40, 70, 20, 50, 30, 90, 45]\nsorted_numbers = counting_sort(numbers)\nprint(\"Sorted numbers:\", sorted_numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#10-radix-sort","title":"10. Radix Sort","text":"<pre><code>def counting_sort_for_radix(numbers, place):\n    size = len(numbers)\n    output = [0] * size\n    count = [0] * 10\n\n    for num in numbers:\n        index = num // place\n        count[index % 10] += 1\n\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    for num in reversed(numbers):\n        index = num // place\n        output[count[index % 10] - 1] = num\n        count[index % 10] -= 1\n\n    for i in range(size):\n        numbers[i] = output[i]\n\ndef radix_sort(numbers):\n    max_value = max(numbers)\n    place = 1\n    while max_value // place &gt; 0:\n        counting_sort_for_radix(numbers, place)\n        place *= 10\n\nnumbers = [60, 40, 70, 20, 50, 30, 90, 45]\nradix_sort(numbers)\nprint(\"Sorted numbers:\", numbers)\n</code></pre>"},{"location":"Programming/Algorithmic%20Concepts/Sorting/#11-bucket-sort","title":"11. Bucket Sort","text":"<pre><code>def insertion_sort(numbers):\n    for i in range(1, len(numbers)):\n        key = numbers[i]\n        j = i - 1\n        while j &gt;= 0 and numbers[j] &gt; key:\n            numbers[j + 1] = numbers[j]\n            j -= 1\n        numbers[j + 1] = key\n\ndef bucket_sort(numbers):\n    if not numbers:\n        return numbers\n    min_value = min(numbers)\n    max_value = max(numbers)\n    bucket_count = len(numbers)\n    buckets = [[] for _ in range(bucket_count)]\n    for num in numbers:\n        index = (num - min_value) * (bucket_count - 1) // (max_value - min_value) if max_value != min_value else 0\n        buckets[index].append(num)\n    for bucket in buckets:\n        insertion_sort(bucket)\n    return [num for bucket in buckets for num in bucket]\n\nimport random\nnumbers = [random.randint(1, 1000) for _ in range(500)]\nsorted_numbers = bucket_sort(numbers)\nprint(\"Sorted numbers:\", sorted_numbers)\n</code></pre>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/","title":"00. Prefix Sum &amp; Line Swipe","text":""},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#prefix-sum","title":"Prefix Sum","text":""},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#description","title":"Description","text":"<p>The prefix sum technique allows for efficient range sum queries by precomputing cumulative sums in an array.</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#steps","title":"Steps","text":"<ol> <li>Build the Prefix Sum Array: Create a new array <code>prefix</code> where each element at index <code>i</code> stores the sum of elements from the start of the array up to index <code>i</code>: <pre><code>prefix[0] = arr[0]\nprefix[1] = arr[0] + arr[1]\nprefix[2] = arr[0] + arr[1] + arr[2] \n</code></pre> And so on\u2026 Example: For <code>arr = [3, 1, 4, 1, 5, 9]</code>, the <code>prefix_sum</code> array is <code>[3, 4, 8, 9, 14, 23]</code>.  </li> <li>Answer Range Sum Queries: To find the sum of elements between indices <code>i</code> and <code>j</code>, use: <code>sum(i, j) = prefix[j] - prefix[i-1]</code> </li> </ol> <p>Example: For <code>arr = [3, 1, 4, 1, 5, 9]</code>, the sum from index <code>2</code> to <code>4</code>: <code>sum(2, 4) = prefix[4] - prefix[1] = 14 - 4 = 10</code>.</p> <p>Note</p> <p>If <code>i = 0</code>, simply return <code>prefix[j]</code>.</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#time-space-complexity","title":"Time &amp; Space Complexity","text":"<ul> <li>Time: <code>O(n)</code> for building the prefix sum array, <code>O(1)</code> per query.  </li> <li>Space: <code>O(n)</code> for storing the prefix sum array.  </li> </ul>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#1-range-sum-query-immutable-leetcode303","title":"1. Range Sum Query - Immutable (Leetcode:303)","text":"<p>Problem Statement Given an integer array <code>nums</code>, handle multiple queries of the following type:  </p> <p>Calculate the sum of the elements of nums between indices <code>left</code> and <code>right</code> inclusive where <code>left</code> &lt;= <code>right</code>.  </p> <p>Implement the <code>NumArray</code> class:  </p> <ul> <li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li> <li><code>int sumRange(int left, int right)</code> Returns the sum of the elements of nums between indices <code>left</code> and <code>right</code> inclusive (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right])</code>.</li> </ul> <p>Example 1: </p> <p>Input <code>[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]</code> <code>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</code> Output <code>[null, 1, -1, -3]</code> </p> <p>Explanation NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1 numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1 numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3  </p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 104</code></li> <li><code>-105 &lt;= nums[i] &lt;= 105</code></li> <li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li> <li><code>At most 104 calls will be made to sumRange.</code></li> </ul> Code &amp; Explaination <p><pre><code>class NumArray:\n\ndef __init__(self, nums: List[int]):\n    self.prefix_sum = [0] * (len(nums)+1)\n\n    for i in range(len(nums)):\n        self.prefix_sum[i+1] = self.prefix_sum[i] + nums[i]\n\ndef sumRange(self, left: int, right: int) -&gt; int:\n    return self.prefix_sum[right+1]-self.prefix_sum[left]\n</code></pre> Explaination</p> <ol> <li> <p>Constructor (<code>__init__</code>):  </p> <ul> <li>Initializes a list <code>prefix_sum</code> where <code>prefix_sum[i]</code> stores the sum of the elements from index <code>0</code> to <code>i-1</code>.  </li> <li>Builds this <code>prefix_sum</code> array by iterating over the input list <code>nums</code>.</li> </ul> </li> <li> <p>Method <code>sumRange(left, right)</code> :  </p> <ul> <li>Returns the sum of the subarray between indices left and right by calculating the difference: <code>prefix_sum[right+1] - prefix_sum[left].</code> </li> <li>This allows constant time <code>O(1)</code> querying of subarray sums after the initial setup.</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#2-left-and-right-sum-differences-leetcode2574","title":"2. Left and Right Sum Differences (Leetcode:2574)","text":"<p>Problem Statement Given a 0-indexed integer array <code>nums</code>, find a 0-indexed integer array <code>answer</code> where:  </p> <ul> <li><code>answer.length == nums.length</code>.  </li> <li><code>answer[i] = |leftSum[i] - rightSum[i]|</code>. </li> </ul> <p>Where:</p> <ul> <li><code>leftSum[i]</code> is the sum of elements to the left of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>leftSum[i] = 0</code>.  </li> <li><code>rightSum[i]</code> is the sum of elements to the right of the index <code>i</code> in the array <code>nums</code>. If there is no such element, <code>rightSum[i] = 0</code>. Return the array <code>answer</code>.  </li> </ul> <p>Example 1:</p> <p>Input: nums = [10,4,8,3] Output: [15,1,11,22] Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0]. The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].  </p> <p>Example 2:</p> <p>Input: nums = [1] Output: [0] Explanation: The array leftSum is [0] and the array rightSum is [0]. The array answer is [|0 - 0|] = [0].  </p> <p>Constraints: </p> <ul> <li><code>1 &lt;= nums.length &lt;= 1000</code></li> <li><code>1 &lt;= nums[i] &lt;= 105</code></li> </ul> code &amp; Explanation <p><pre><code>class Solution:\ndef leftRightDifference(self, nums: List[int]) -&gt; List[int]:\n\n    left_sum  = 0\n    right_sum = sum(nums)\n    answer = []\n\n    for num in nums:\n        left_sum += num\n        answer.append(abs(left_sum-right_sum))\n        right_sum -= num\n\n    return answer\n</code></pre> Explaination</p> <ol> <li> <p>Initialization :  </p> <ul> <li><code>left_sum = 0</code>: Tracks the sum of elements before the current index.  </li> <li><code>right_sum = sum(nums)</code>: Initially holds the total sum of all elements.  </li> <li><code>answer = []</code>: Stores the result.</li> </ul> </li> <li> <p>Loop through nums :  </p> <ul> <li>For each element <code>num</code>:  </li> <li>Update <code>left_sum</code>: Add <code>num</code> to <code>left_sum</code>.  </li> <li>Calculate and append absolute difference: <code>|left_sum - right_sum|</code> is appended to <code>answer</code>.  </li> <li>Update <code>right_sum</code>: Subtract <code>num</code> from <code>right_sum</code>.</li> </ul> </li> <li> <p>Return answer :  </p> <ul> <li>After the loop, return the computed differences in <code>answer</code>.</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#3-xor-queries-of-a-subarray-leetcode1310","title":"3. XOR Queries of a Subarray (Leetcode:1310)","text":"<p>Problem Statement </p> <p>You are given an array <code>arr</code> of positive integers. You are also given the array <code>queries</code> where <code>queries[i] = [lefti, righti]</code>.</p> <p>For each query <code>i</code> compute the XOR of elements from <code>lefti</code> to <code>righti</code> (that is, <code>arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti]</code> ).</p> <p>Return an array <code>answer</code> where <code>answer[i]</code> is the answer to the <code>ith</code> query.</p> <p>Example 1:</p> <p>Input: <code>arr = [1,3,4,8]</code>, <code>queries = [[0,1],[1,2],[0,3],[3,3]]</code> Output: <code>[2,7,14,8]</code> Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8```  </p> <p>Example 2:</p> <p>Input: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] Output: [8,0,4,4]</p> <p>Constraints: </p> <ul> <li><code>1 &lt;= arr.length, queries.length &lt;= 3 * 104</code></li> <li><code>1 &lt;= arr[i] &lt;= 109</code></li> <li><code>queries[i].length == 2</code></li> <li><code>0 &lt;= lefti &lt;= righti &lt; arr.length</code></li> </ul> Code &amp; Explaination <p><pre><code>class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -&gt; List[int]:\n\n        prefix = [0] * (len(arr) + 1)\n        answer = []\n\n        for i in range(len(arr)):\n            prefix[i + 1] = prefix[i] ^ arr[i]\n\n        for left, right in queries:\n            answer.append(prefix[right + 1] ^ prefix[left])\n\n        return answer\n</code></pre> Explaination:</p> <ol> <li> <p>Initialization:</p> <ul> <li><code>prefix = [0] * (len(arr) + 1)</code>: Create a list <code>prefix</code> to store the cumulative XOR of elements in the array. The extra element accounts for the starting point (index 0).  </li> <li><code>answer = []</code>: This will store the result for each query.</li> </ul> </li> <li> <p>Build Prefix XOR Array:</p> <ul> <li>For each element <code>arr[i]</code> in the array, compute the cumulative XOR up to that index:</li> <li><code>prefix[i + 1] = prefix[i] ^ arr[i]</code>: This updates the <code>prefix</code> list, where each entry at <code>i + 1</code> holds the XOR of all elements from the start of the array up to index <code>i</code>.</li> </ul> </li> <li> <p>Process Queries:</p> <ul> <li>For each query <code>[left, right]</code>, calculate the XOR of elements from index <code>left</code> to <code>right</code>:</li> <li><code>answer.append(prefix[right + 1] ^ prefix[left])</code>: This uses the precomputed <code>prefix</code> array. The XOR of the subarray from <code>left</code> to <code>right</code> is found by subtracting the prefix XORs at <code>left</code> and <code>right + 1</code>.</li> </ul> </li> <li> <p>Return the Answer:</p> <ul> <li>The final <code>answer</code> list contains the result for each query, which is the XOR of the elements in the subarray defined by <code>left</code> and <code>right</code>.</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#4-subarray-sum-equals-k-leetcode560","title":"4. Subarray Sum Equals K (Leetcode:560)","text":"<p>Problem Statement Given an array of integers <code>nums</code> and an integer <code>k</code>, return the total number of subarrays whose sum equals to <code>k</code>.  </p> <p>A subarray is a contiguous <code>non-empty</code> sequence of elements within an array.</p> <p>Example 1: </p> <p>Input: nums = [1,1,1], k = 2 Output: 2</p> <p>Example 2: </p> <p>Input: nums = [1,2,3], k = 3 Output: 2</p> <p>Constraints: </p> <ul> <li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li> <li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li> <li><code>-107 &lt;= k &lt;= 107</code></li> </ul> Code &amp; Explaination <p><pre><code>class Solution:\n    def subarraySum(self, nums: List[int], k: int) -&gt; int:\n        count = 0\n        prefix_sum = 0\n        dictionary = {0:1}  # Start with {0:1} to handle subarrays starting from the beginning\n\n        for num in nums:\n            prefix_sum += num  # Update prefix sum\n            diff = prefix_sum - k  # Find the difference between the current prefix sum and target k\n            if diff in dictionary:  # If this diff has been seen before, increment count\n                count += dictionary[diff]\n            dictionary[prefix_sum] = dictionary.get(prefix_sum, 0) + 1  # Update the dictionary\n\n        return count\n</code></pre> Explaination:</p> <ol> <li> <p>Initialization:  </p> <ul> <li><code>count = 0</code>: To store the number of valid subarrays.  </li> <li><code>prefix_sum = 0</code>: To keep track of the cumulative sum as we iterate through the array.  </li> <li><code>dictionary = {0: 1}</code>: This keeps track of how many times a certain prefix sum has occurred.  </li> <li>We start with <code>{0: 1}</code> because a sum of <code>0</code> is possible before we start processing the array.</li> </ul> </li> <li> <p>Iterate through the array:  </p> <ul> <li>For each element <code>num</code> in the array, update the <code>prefix_sum</code> by adding <code>num</code> to it.  </li> <li>Compute the difference <code>diff = prefix_sum - k</code>. If <code>diff</code> exists in the dictionary, it means there are subarrays whose sum equals <code>k</code>, and their <code>count</code> is stored in the <code>dictionary</code>.  </li> <li>Increment <code>count</code> by the number of times <code>diff</code> has occurred.  </li> <li>Update the dictionary by increasing the <code>count</code> of <code>prefix_sum</code>.</li> </ul> </li> <li> <p>Return the <code>count</code>:  </p> <ul> <li>This gives the total number of subarrays whose sum equals <code>k</code>.  </li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#5-product-of-array-except-self-leetcode238","title":"5. Product of Array Except Self (Leetcode:238)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#6-increment-submatrices-by-one-leetcode2536","title":"6. Increment Submatrices by One (Leetcode:2536)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#7-range-sum-query-2d-immutable-leetcode304","title":"7. Range Sum Query 2D - Immutable (Leetcode:304)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#8-power-of-heroes-leetcode2681","title":"8. Power of Heroes (Leetcode:2681)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#9-minimum-cost-to-make-array-equal-leetcode2448","title":"9. Minimum Cost to Make Array Equal (Leetcode:2448)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#line-sweep","title":"Line Sweep","text":""},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#theory_1","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#description_1","title":"Description","text":"<p>The Line Sweep Algorithm is a powerful technique used in computational geometry. It's an efficient way to solve problems like detecting intersections, finding the closest pair of points, or calculating the convex hull. Let\u2019s break down the core concepts of this algorithm to understand how it works.</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#what-is-the-sweep-line","title":"What is the Sweep Line?","text":"<p>The sweep line is an imaginary vertical line that moves across a plane from left to right. As it moves, it sweeps through the objects in its path, processing important events at each step. Imagine it like a curtain slowly moving across a stage, revealing different parts of a scene. In the context of algorithms, this \"curtain\" moves across the plane, checking and reacting to specific points where events occur.</p> <p>The sweep line doesn\u2019t just move randomly\u2014it advances through key points, called events, which are defined based on the specific problem being solved. By focusing on these events, the algorithm can efficiently process only the relevant parts of the data.</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#what-are-events","title":"What are Events?","text":"<p>An event is a point on the plane where something significant happens as the sweep line moves. These events are the heart of the algorithm because they trigger actions like adding or removing objects, or checking for interactions. Depending on the problem you're solving, events could include:</p> <ul> <li>Start events: The beginning of an object, such as the left endpoint of a line segment or the opening of a rectangle.</li> <li>End events: The end of an object, like the right endpoint of a line segment or the closing of a rectangle.</li> <li>Intersection events: When two objects, like two line segments, intersect or overlap.</li> </ul> <p>The sweep line processes these events in order, one by one, and each event may lead to an update in the algorithm\u2019s state\u2014whether it\u2019s adding a new object, removing one, or checking for an intersection.</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#how-does-it-work","title":"How Does it Work?","text":"<p>Here\u2019s how the line sweep algorithm works in practice:</p> <ul> <li> <p>Sort the events: The first step is to sort all the events in order of their position along the x-axis (left to right). For example, if you are working with line segments, this would mean sorting by the x-coordinate of the start and end points of each segment.</p> </li> <li> <p>Process events in order: The sweep line starts at the leftmost event and moves to the right. For each event, you do something specific:</p> </li> <li>When the sweep line reaches a start event (like the left endpoint of a line segment), the segment is added to a list of active objects.</li> <li>When the sweep line reaches an end event (like the right endpoint), that segment is removed from the list of active objects.</li> <li>At each step, the algorithm may check for intersections or other interactions between active objects (e.g., checking if newly added segments intersect with others already in the list).</li> </ul> <p>By sorting and processing events in this way, the algorithm can handle complex geometric problems without having to check every possible pair of objects, which would be much slower.</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#problems_1","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#1-points-that-intersect-with-cars-leetcode2848","title":"1. Points That Intersect With Cars (Leetcode:2848)","text":"<p>Problem Statement </p> Code &amp; Explaination <p><pre><code>class Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -&gt; int:\n\n        line = [0] * 102\n        points_on_line = 0\n\n        for start,end in nums:\n            line[start] += 1\n            line[end + 1] -= 1\n\n        for i in range(1, 102):\n            line[i] += line[i - 1]\n            if line[i] != 0:\n                points_on_line += 1\n\n        return points_on_line\n</code></pre> Explaination:</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#2-check-if-all-the-integers-in-a-range-are-covered-leetcode1893","title":"2. Check if All the Integers in a Range Are Covered (Leetcode:1893)","text":"<p>Problem Statement </p> Code &amp; Explaination <p><pre><code>class Solution:\n    def isCovered(self, ranges: List[List[int]], left: int, right: int) -&gt; bool:\n        line = [0] * 52\n\n        for start,end in ranges:\n            line[start]+=1\n            line[end+1]-=1\n\n        for i in range(1, 52):\n            line[i] += line[i - 1]\n\n        for i in range(left, right+1):\n            if line[i]&lt;1:\n                return False\n\n        return True\n</code></pre> Explaination:</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#3-minimum-number-of-arrows-to-burst-balloons-leetcode452","title":"3. Minimum Number of Arrows to Burst Balloons (Leetcode:452)","text":"<p>Problem Statement </p> Code &amp; Explaination <p><pre><code>class Solution:\n    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:\n        prev = points[0][1]\n        arrows = 1\n\n        for start, end in sorted(points)[1:]:\n            if start&gt;prev :\n                prev = end\n                arrows+=1\n\n            prev = min(end, prev)\n        return arrows\n</code></pre> Explaination:</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#4car-pooling-leetcode1094","title":"4.Car Pooling (Leetcode:1094)","text":"<p>Problem Statement </p> Code &amp; Explaination <p><pre><code>class Solution(object):\n    def carPooling(self, trips: List[List[int]], capacity: int) -&gt; bool:\n        locations = [0] * 1001\n        for numPassengers, start, end in trips:\n            locations[start] += numPassengers\n            locations[end] -= numPassengers\n\n        for numPassengers in locations:\n            capacity -= numPassengers\n            if capacity &lt; 0: \n                return False\n\n        return True\n</code></pre> Explaination:</p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#5-my-calendar-ii-leetcode731","title":"5. My Calendar II (Leetcode:731)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#6-number-of-flowers-in-full-bloom-leetcode2251","title":"6. Number of Flowers in Full Bloom (Leetcode:2251)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#7-my-calendar-iii-leetcode732","title":"7. My Calendar III (Leetcode:732)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/00.%20Prefix%20Sum/#8-minimum-number-of-taps-to-open-to-water-a-garden-leetcode1326","title":"8. Minimum Number of Taps to Open to Water a Garden (Leetcode:1326)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/","title":"01. Bit Manipulation","text":""},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#description","title":"Description","text":"<p>Bit manipulation refers to using bitwise operators to work directly with the binary representations of numbers. These operations allow you to solve problems efficiently, often with a time complexity advantage compared to other methods. In many cases, bit manipulation can help reduce both time and space complexity, especially when working with binary data.</p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#common-bitwise-operators","title":"Common Bitwise Operators","text":"<ol> <li> <p>AND (<code>&amp;</code>): Sets a bit to 1 if both corresponding bits are 1.  </p> <ul> <li>Example: <code>1101 &amp; 1011 = 1001</code> (binary)</li> </ul> </li> <li> <p>OR (<code>|</code>): Sets a bit to 1 if at least one of the corresponding bits is 1.  </p> <ul> <li>Example: <code>1101 | 1011 = 1111</code></li> </ul> </li> <li> <p>XOR (<code>^</code>): Sets a bit to 1 if the corresponding bits are different.  </p> <ul> <li>Example: <code>1101 ^ 1011 = 0110</code></li> </ul> </li> <li> <p>NOT (<code>~</code>): Flips all bits (inverts 0s to 1s and 1s to 0s).  </p> <ul> <li>Example: <code>~1101 = 0010</code> (assuming 4-bit representation)</li> </ul> </li> <li> <p>Left Shift (<code>&lt;&lt;</code>): Shifts bits to the left, equivalent to multiplying the number by 2.  </p> <ul> <li>Example: <code>1010 &lt;&lt; 1 = 10100</code> (multiplies by 2)</li> </ul> </li> <li> <p>Right Shift (<code>&gt;&gt;</code>): Shifts bits to the right, equivalent to dividing the number by 2 (ignoring the remainder).  </p> <ul> <li>Example: <code>1010 &gt;&gt; 1 = 0101</code> (divides by 2)</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#key-bit-manipulation-patterns","title":"Key Bit Manipulation Patterns","text":"<ol> <li> <p>Check if a number is even or odd:</p> <ul> <li>Use <code>n &amp; 1</code>. If the result is <code>0</code>, the number is even; if the result is <code>1</code>, the number is odd.</li> <li>Example: <code>n = 5</code> \u2192 <code>5 &amp; 1 = 1</code> \u2192 Odd <code>n = 6</code> \u2192 <code>6 &amp; 1 = 0</code> \u2192 Even</li> </ul> </li> <li> <p>Get the rightmost set bit:</p> <ul> <li>To isolate the rightmost set bit (1) in a number, use <code>n &amp; (-n)</code>.</li> <li>Example: <code>n = 12</code> (binary <code>1100</code>) \u2192 <code>n &amp; (-n) = 4</code> (binary <code>0100</code>)</li> </ul> </li> <li> <p>Set the k-th bit:</p> <ul> <li>To set (turn to 1) the k-th bit(0-indexing, right to left) of a number <code>n</code>, use <code>n | (1 &lt;&lt; k)</code>.</li> <li>Example: <code>n = 4</code> (binary <code>0100</code>), set the 3nd bit: <code>4 | (1 &lt;&lt; 3) = 4 | 8 = 12</code> (binary <code>1100</code>)</li> </ul> </li> <li> <p>Clear the k-th bit:</p> <ul> <li>To clear (turn to 0) the k-th bit, use <code>n &amp; ~(1 &lt;&lt; k)</code>.</li> <li>Example: <code>n = 6</code> (binary <code>0110</code>), clear the 2nd bit: <code>6 &amp; ~(1 &lt;&lt; 2) = 6 &amp; ~4 = 6 &amp; 11 = 2</code> (binary <code>0010</code>)</li> </ul> </li> <li> <p>Toggle the k-th bit:</p> <ul> <li>To flip (toggle) the k-th bit, use <code>n ^ (1 &lt;&lt; k)</code>. This changes a 1 to 0, or a 0 to 1.</li> <li>Example: <code>n = 6</code> (binary <code>0110</code>), toggle the 2nd bit: <code>6 ^ (1 &lt;&lt; 2) = 6 ^ 4 = 2</code> (binary <code>0010</code>)</li> </ul> </li> <li> <p>Check if the k-th bit is set:</p> <ul> <li>To check if the k-th bit is 1, use <code>(n &amp; (1 &lt;&lt; k)) != 0</code>. If the result is non-zero, the k-th bit is set.</li> <li>Example: <code>n = 6</code> (binary <code>0110</code>), check if the 2nd bit is set: <code>(6 &amp; (1 &lt;&lt; 2)) != 0</code> \u2192 True</li> </ul> </li> <li> <p>Count the number of set bits (Hamming Weight):</p> <ul> <li>To count the number of set bits (1s) in a number, use the technique <code>n = n &amp; (n - 1)</code> repeatedly. This removes the rightmost set bit in each step. Count how many times you can do this until <code>n</code> becomes 0.</li> <li>Example: <code>n = 13</code> (binary <code>1101</code>):     First step: <code>n = 13 &amp; 12 = 1101 &amp; 1100 = 1100</code>     Second step: <code>n = 12 &amp; 11 = 1100 &amp; 1011 = 1000</code>     Third step: <code>n = 8 &amp; 7 = 1000 &amp; 0111 = 0000</code>     Total steps: 3 set bits.</li> </ul> </li> <li> <p>Power of 2 Check:</p> <ul> <li>A number <code>n</code> is a power of 2 if it has exactly one set bit. Check if <code>n &amp; (n - 1) == 0</code> (and <code>n &gt; 0</code> to exclude 0).</li> <li>Example: <code>n = 8</code> (binary <code>1000</code>), check if it's a power of 2: <code>8 &amp; (8 - 1) = 8 &amp; 7 = 0</code> \u2192 True (8 is a power of 2).</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#intuitive-applications-of-bit-manipulation","title":"Intuitive Applications of Bit Manipulation","text":"<ol> <li> <p>Subset Generation:</p> <ul> <li> <p>each subset of a set can be represented as a binary number. For a set with n elements, there are \\(2^n\\) subsets, and each subset corresponds to a number between 0 and \\(2^n - 1\\).</p> </li> <li> <p>Masking: Each number (mask) from 0 to \\(2^n - 1\\) is used to generate a subset. The \\( i^{th} \\) bit in the number indicates whether the i-th element is in the subset (1 for included, 0 for excluded).     <pre><code>def generate_subsets(nums):\nn = len(nums)\nsubsets = []\nfor mask in range(1 &lt;&lt; n):  # Loop over all subsets\n    subset = [nums[i] for i in range(n) if mask &amp; (1 &lt;&lt; i)]  # Build subset\n    subsets.append(subset)\nreturn subsets\n\nnums = [1, 2, 3]\nsubsets = generate_subsets(nums)\n</code></pre></p> </li> <li> <p>Example: For the set <code>{1, 2, 3}</code>, the subsets are:</p> <ul> <li><code>000</code> \u2192 <code>{}</code> (empty set)</li> <li><code>001</code> \u2192 <code>{1}</code></li> <li><code>010</code> \u2192 <code>{2}</code></li> <li><code>011</code> \u2192 <code>{1,2}</code></li> <li><code>100</code> \u2192 <code>{3}</code></li> <li><code>101</code> \u2192 <code>{1, 3}</code></li> <li><code>110</code> \u2192 <code>{2, 3}</code></li> <li><code>111</code> \u2192 <code>{1, 2, 3}</code></li> </ul> </li> </ul> </li> <li> <p>Efficient Swapping:</p> <ul> <li>You can swap two numbers using XOR without needing a temporary variable: <pre><code>    a = a ^ b\n    b = a ^ b\n    a = a ^ b\n</code></pre></li> <li>Example: If <code>a = 5</code> and <code>b = 3</code>, the values of <code>a</code> and <code>b</code> will be swapped using this XOR trick.</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#why-use-bit-manipulation","title":"Why Use Bit Manipulation?","text":"<ol> <li>Efficiency: Bitwise operations are generally faster because they directly manipulate individual bits, which is low-level and quick.</li> <li>Memory Optimization: You can use fewer resources (like using a bitmask instead of an array of booleans).</li> <li>Elegance: Many problems become simpler and cleaner when you think in terms of binary data and bitwise operations.</li> </ol>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#1-total-hamming-distance-leetcode477","title":"1. Total Hamming Distance (Leetcode:477)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def totalHammingDistance(self, nums: List[int]) -&gt; int:\n        hamming_distance = 0\n        for i in range(32):\n            ones = sum((num &gt;&gt; i) &amp; 1 for num in nums)\n            hamming_distance += ones * (len(nums) - ones)\n        return hamming_distance\n</code></pre> Explaination: This is first approach</p> <p><pre><code>class Solution:\n    def totalHammingDistance(self, nums: List[int]) -&gt; int:\n        hamming_distance = 0\n        mask =1 \n        for i in range(32):\n            zeros= sum(1 for num in nums if (num &amp; mask)==0 )\n            hamming_distance += zeros * (len(nums) - zeros)\n            mask &lt;&lt;= 1\n        return hamming_distance\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#2-bitwise-and-of-numbers-range-leetcode201","title":"2. Bitwise AND of Numbers Range (Leetcode:201)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -&gt; int:\n        count = 0\n        while left != right:\n            left &gt;&gt;= 1\n            right &gt;&gt;= 1\n            count += 1\n        return left &lt;&lt; count\n</code></pre> Explaination: This is first approach</p> <p><pre><code>class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -&gt; int:\n        while left &lt; right:\n            right = right &amp; (right - 1)\n        return right\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#3-gray-code-leetcode89","title":"3. Gray Code (Leetcode:89)","text":"<p>Problem Statement </p> Code and Explaination <p><pre><code>class Solution:\n    def grayCode(self, n: int) -&gt; List[int]:\n        return [i ^ i &gt;&gt; 1  for i in range(1 &lt;&lt; n)]\n</code></pre> Explaination: This is explaination.</p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#4-maximum-xor-product-leetcode2939","title":"4. Maximum Xor Product (Leetcode:2939)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#5-reverse-integer-leetcode7","title":"5. Reverse Integer (Leetcode:7)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#6-shortest-subarray-with-or-at-least-k-ii-leetcode3097","title":"6. Shortest Subarray With OR at Least K II (Leetcode:3097)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#7-sum-of-two-integers-leetcode371","title":"7. Sum of Two Integers (Leetcode:371)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#8-xor-queries-of-a-subarray-leetcode1310","title":"8. XOR Queries of a Subarray (Leetcode:1310)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#9-find-longest-awesome-substring-leetcode1542","title":"9. Find Longest Awesome Substring (Leetcode:1542)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#10-find-subarray-with-bitwise-or-closest-to-k-leetcode3171","title":"10. Find Subarray With Bitwise OR Closest to K (Leetcode:3171)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/01.%20Bit%20Manipulation/#11-minimize-or-of-remaining-elements-using-operations-leetcode3022","title":"11. Minimize OR of Remaining Elements Using Operations (Leetcode:3022)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/","title":"02. Two Pointer","text":""},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#description","title":"Description","text":"<p>The Two Pointer Pattern is a technique used to solve problems involving sequences (such as arrays or lists) by utilizing two pointers that traverse the sequence in different ways. This approach is particularly effective in optimizing performance by reducing time complexity, especially for problems that involve checking pairs, subarrays, or sliding windows.</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#types","title":"Types","text":"<ol> <li> <p>Running from Beginning of 2 Arrays / Merging 2 Arrays When to Use    This technique is commonly used in problems where you need to merge two sorted arrays or process two sequences simultaneously. How It Works </p> <ul> <li>One pointer is used to iterate through each of the two arrays.  </li> <li>Typically, both pointers start at the beginning of their respective arrays.  </li> <li>Compare elements at both pointers, select the smaller (or larger, depending on the problem), and move the corresponding pointer forward.  </li> <li>This is often used in merge operations (e.g., merging two sorted arrays) or problems like finding the intersection of two arrays.</li> </ul> </li> <li> <p>Pointers Moving Towards Each Other When to Use    This technique is ideal for problems where you need to find pairs that satisfy a specific condition, such as a target sum or product, especially in sorted arrays. How It Works </p> <ul> <li>One pointer starts at the beginning of the array (left pointer), and the other starts at the end (right pointer).  </li> <li>Both pointers move towards each other, adjusting based on the condition being checked.  </li> <li>If the sum of the values at both pointers meets the condition (e.g., equals a target sum), return the result.  </li> <li>If the sum is too low, move the left pointer forward; if it's too high, move the right pointer backward.  </li> <li>This method is efficient for problems like \"two-sum\" or \"pair sum\" problems in sorted arrays.</li> </ul> </li> <li> <p>Pointers Moving in the Same Direction When to Use    This technique is ideal for problems like finding unique elements, counting subarrays, or rearranging elements. How It Works </p> <ul> <li>One pointer (typically called <code>slow</code>) moves through the array, while the other pointer (called <code>fast</code>) explores further elements.  </li> <li>The <code>slow</code> pointer often keeps track of the current valid position, while the <code>fast</code> pointer scans for new valid elements.  </li> <li>This is especially useful for sliding window problems, where the window expands and shrinks by adjusting the pointers.  </li> <li>It can also be used to remove duplicates in-place in an array.</li> </ul> </li> <li> <p>One Fixed Pointer, One Moving Pointer When to Use    This approach is commonly used for problems where you need to count subarrays or combinations that satisfy certain conditions (e.g., subarrays with a sum less than a target). How It Works </p> <ul> <li>One pointer remains fixed (often at the start), while the other pointer (often called <code>end</code> or <code>right</code>) moves across the array.  </li> <li>The fixed pointer may adjust based on the condition being tracked (for example, shrinking a window to meet a target sum).  </li> <li>This approach is effective for problems where you need to track ranges or dynamic subarrays, like finding subarrays whose sum is less than or equal to a target value.</li> </ul> </li> <li> <p>Expanding/Contracting Window When to Use     This technique is ideal for problems where you need to manage subarrays or substrings that must satisfy a condition. How It Works </p> <ul> <li>One pointer expands the window by moving forward, while the other pointer contracts it to maintain the desired condition (e.g., sum or length).  </li> <li>This is particularly useful for sliding window problems where the window size adjusts dynamically based on conditions.</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#benefits","title":"Benefits","text":"<ul> <li>Efficiency: The two-pointer approach often reduces time complexity from O(n\u00b2) to O(n), making it much faster for certain problems.</li> <li>Simplicity: It simplifies complex problems (such as checking for pairs or subarrays) into a single pass through the array, resulting in cleaner and more efficient code.  </li> <li>Memory Efficiency: Unlike other approaches that may require extra space (such as hash tables), the two-pointer technique typically operates in-place, minimizing memory usage.  </li> </ul>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#1-sort-array-by-parity-ii-leetcode922","title":"1. Sort Array By Parity II (Leetcode:922)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#2-di-string-match-leetcode942","title":"2. DI String Match (Leetcode:942)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#3-two-sum-leetcode1","title":"3. Two Sum (Leetcode:1)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#4-sentence-similarity-iii-leetcode1813","title":"4. Sentence Similarity III (Leetcode:1813)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#5-reverse-words-in-a-string-leetcode151","title":"5. Reverse Words in a String (Leetcode:151)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#6-bag-of-tokens-leetcode948","title":"6. Bag of Tokens (Leetcode:948)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#7-3sum-leetcode15","title":"7. 3Sum (Leetcode:15)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#8-sort-colors-leetcode75","title":"8. Sort Colors (Leetcode:75)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#9-next-permutation-leetcode31","title":"9. Next Permutation (Leetcode:31)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#10-rotate-array-leetcode189","title":"10. Rotate Array (Leetcode:189)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#11-largest-number-leetcode179","title":"11. Largest Number (Leetcode:179)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#12-first-missing-positive-leetcode41","title":"12. First Missing Positive (Leetcode:41)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#13-contains-duplicate-iii-leetcode220","title":"13. Contains Duplicate III (Leetcode:220)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/02.%20Two%20Pointers/#14-longest-repeating-character-replacement-leetcode424","title":"14. Longest Repeating Character Replacement (Leetcode:424)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/","title":"03. Fast and Slow Pointers","text":""},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#description","title":"Description","text":"<p>The Fast and Slow Pointer technique, also called the Tortoise and Hare algorithm, is a powerful method for efficiently solving problems in linked lists and cyclic structures.  </p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#how-it-works","title":"How It Works","text":"<ul> <li>The slow pointer moves one step at a time.</li> <li>The fast pointer moves two steps at a time.</li> </ul> <p>The difference in speeds allows the fast pointer to catch up with the slow pointer if there\u2019s a cycle or to identify the middle of a structure.</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#key-insights","title":"Key Insights","text":"<ul> <li>Cycle Detection: If a cycle exists, the fast pointer will meet the slow pointer inside the cycle.</li> <li>Middle Element: The slow pointer will be at the middle when the fast pointer reaches the end.</li> <li>Pattern Matching: Helps detect patterns like palindromes by dividing the structure into two parts.</li> </ul>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#benefits","title":"Benefits","text":"<ul> <li>Time Efficient: Solves problems in O(n) time with a single traversal.</li> <li>Space Efficient: Requires O(1) space, avoiding extra data structures.</li> <li>Simple &amp; Elegant: Reduces complex problems to simple solutions.</li> </ul>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#1-linked-list-cycle-leetcode141","title":"1. Linked List Cycle (Leetcode:141)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\ndef hasCycle(self, head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head,head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n</code></pre> Explaination: This is first approach</p> <p><pre><code>\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#2-linked-list-cycle-ii-leetcode142","title":"2. Linked List Cycle II (Leetcode:142)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#3-happy-number-leetcode202","title":"3. Happy Number (Leetcode:202)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#4-middle-of-the-linked-list-leetcode876","title":"4. Middle of the Linked List (Leetcode:876)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\ndef middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow\n</code></pre> Explaination: This is first approach</p> <p><pre><code>\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#5-palindrome-linked-list-leetcode234","title":"5. Palindrome Linked List (Leetcode:234)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\ndef isPalindrome(self, head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next \n\n    prev, curr = None, slow \n\n    while curr:\n        nxt = curr.next \n        curr.next = prev \n        prev = curr\n        curr = nxt \n\n    first_half, reversed_half = head, prev \n\n    while first_half and reversed_half:\n        if first_half.val != reversed_half.val:\n            return False \n\n        first_half = first_half.next \n        reversed_half = reversed_half.next \n\n    return True\n</code></pre> Explaination: This is first approach</p> <p><pre><code>\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#6-reorder-list-leetcode143","title":"6. Reorder List (Leetcode:143)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#7-circular-array-loop-leetcode457","title":"7. Circular Array Loop (Leetcode:457)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#8-remove-nth-node-from-end-of-list-leetcode19","title":"8. Remove Nth Node From End of List (Leetcode:19)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#9-rotate-list-leetcode61","title":"9. Rotate List (Leetcode:61)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#10-find-the-duplicate-number-leetcode287","title":"10. Find the Duplicate Number (Leetcode:287)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#11-moving-stones-until-consecutive-ii-leetcode1040","title":"11. Moving Stones Until Consecutive II (Leetcode:1040)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#12-remove-duplicates-from-sorted-list-ii-leetcode82","title":"12. Remove Duplicates from Sorted List II (Leetcode:82)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#13-friends-of-appropriate-ages-leetcode825","title":"13. Friends Of Appropriate Ages (Leetcode:825)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#14-partition-labels-leetcode763","title":"14. Partition Labels (Leetcode:763)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#15-longest-mountain-in-array-leetcode845","title":"15. Longest Mountain in Array (Leetcode:845)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/03.%20Fast%20and%20Slow%20Pointers/#16-count-pairs-of-nodes-leetcode1782","title":"16. Count Pairs Of Nodes (Leetcode:1782)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/","title":"04.Sliding-Window","text":""},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#description","title":"Description","text":"<p>The Sliding Window is a popular algorithmic technique used to efficiently solve problems involving sequences (arrays or lists) or strings. It is commonly applied in problems where a contiguous block of elements in an array or a string needs to be examined, especially when the window size is either fixed or dynamic.</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#1-fixed-size-sliding-window","title":"1. Fixed Size Sliding Window","text":"<p>In a Fixed Size Sliding Window, the window size is predetermined and does not change during the traversal of the sequence. The window moves step-by-step across the sequence, adjusting its position by adding the next element into the window and removing the element that is no longer in the window's range.</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#key-idea","title":"Key Idea","text":"<ul> <li>The window size remains constant throughout the process.</li> <li>The window moves from the beginning of the sequence to the end, sliding one element at a time.</li> <li>At each step, the next element is added, and the element that is no longer within the window is removed.</li> </ul>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#example","title":"Example","text":"<p>Maximum Sum Subarray of Size <code>k</code> Given an array of integers and a number <code>k</code>, find the maximum sum of a subarray of size <code>k</code>. Input <pre><code>Array: [2, 1, 5, 1, 3, 2], k = 3\n</code></pre> Process     1. Start with the first window of size <code>k</code>. The window is <code>[2, 1, 5]</code> with sum 8.     2. <code>Slide the window one element to the right</code>: remove 2, add 1. The window is now <code>[1, 5, 1]</code> with sum 7.     3. <code>Slide the window one more time</code>: remove 1, add 3. The window is now <code>[5, 1, 3]</code> with sum 9.     4. Slide the window again: remove 5, add 2. The window is now <code>[1, 3, 2]</code> with sum 6.     5. The maximum sum of any subarray of size 3 is <code>9</code>.</p> <p>Time Complexity <code>O(n)</code>, because you only need to traverse the array once and perform constant-time operations for each slide (removing one element and adding another).</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#2-dynamic-size-sliding-window","title":"2. Dynamic Size Sliding Window","text":"<p>In a Dynamic Size Sliding Window, the size of the window can change based on some condition. The window grows or shrinks dynamically as you traverse the sequence, making it ideal for problems where the window needs to adjust based on constraints or conditions.</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#key-idea_1","title":"Key Idea","text":"<ul> <li>The window expands or contracts depending on certain conditions.</li> <li>The size of the window is not fixed and can change during traversal.</li> <li>You may expand the window when you meet a certain condition or contract it when a constraint is violated.</li> </ul>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#example_1","title":"Example","text":"<p>Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Input <pre><code>String: \"abcabcbb\"\n</code></pre> Process 1. Start with an empty set and begin with the first character <code>'a'</code>. The window is now <code>\"a\"</code>. 2. Move to the next character <code>'b'</code>. The window is now <code>\"ab\"</code>. 3. Move to the next character <code>'c'</code>. The window is now <code>\"abc\"</code>. 4. Move to the next character <code>'a'</code>. Since <code>'a'</code> is a duplicate, shrink the window from the left by removing <code>'a'</code>. The window is now <code>\"bc\"</code>. 5. Continue this process. The longest substring without repeating characters in this case is <code>\"abc\"</code>, and its length is 3.  </p> <p>Time Complexity O(n), because each character is added and removed from the window at most once.  </p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#key-differences-between-fixed-and-dynamic-sliding-windows","title":"Key Differences Between Fixed and Dynamic Sliding Windows","text":"<ol> <li> <p>Window Size:</p> <ul> <li>Fixed Size: The window size is constant throughout the problem.</li> <li>Dynamic Size: The window size can change dynamically as per the problem\u2019s requirements.</li> </ul> </li> <li> <p>Problem Types:</p> <ul> <li>Fixed Size: Problems often involve fixed-size subarrays or subsegments.</li> <li>Dynamic Size: Problems often involve adjusting the window to satisfy certain constraints or conditions.</li> </ul> </li> <li> <p>Movement of Window:</p> <ul> <li>Fixed Size: The window moves one step at a time, adding a new element and removing the old one.</li> <li>Dynamic Size: The window can both grow and shrink, depending on whether the window satisfies certain conditions.</li> </ul> </li> <li> <p>Applications:</p> <ul> <li>Fixed Size: Often used for problems involving sums, averages, or statistics on fixed-length subarrays.</li> <li>Dynamic Size: Often used for problems involving string patterns, constraints like sum or distinct elements, or longest subsequences.</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#summary","title":"Summary","text":"<ul> <li>Fixed Size Sliding Window is used when you need to consider subarrays of a fixed size as you traverse the array or string.</li> <li>Dynamic Size Sliding Window is used when the size of the window is flexible and changes depending on some condition, often involving optimization or constraint satisfaction.</li> </ul> <p>Both techniques provide an efficient way to solve problems in linear time, as they avoid recomputing sums or other calculations from scratch every time the window moves. Instead, they update values incrementally as the window slides, making them highly effective for problems involving sequences.</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#1-maximum-average-subarray-i-leetcode643","title":"1. Maximum Average Subarray I (Leetcode:643)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def findMaxAverage(self, nums: List[int], k: int) -&gt; float:\n\n        max_sum = curr_sum = sum(nums[:k])\n\n        for i in range(k,len(nums)):\n\n            curr_sum+= nums[i] - nums[i-k]\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum/k\n</code></pre> Explaination: This is first approach</p> <p><pre><code>\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#2-substrings-of-size-three-with-distinct-characters-leetcode1876","title":"2. Substrings of Size Three with Distinct Characters (Leetcode:1876)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2Approach 3 <p><pre><code>class Solution:\n    def countGoodSubstrings(self, s: str) -&gt; int:\n        l = 0\n        st = set()\n        ans = 0\n        for r in range(len(s)):\n            st.add(s[r])\n            while r-l+1 &gt; 3:\n                if s[l] != s[r] and s[l] != s[r-1] and s[l] != s[r-2]:\n                    st.remove(s[l])\n                l += 1\n            if len(st) == 3: \n                ans += 1\n        return ans\n</code></pre> Explaination: This is first approach</p> <p><pre><code>class Solution:\n    def countGoodSubstrings(self, s: str) -&gt; int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2]:\n                count += 1\n        return count\n</code></pre> Explaination: This is second approach</p> <p><pre><code>class Solution:\n    def countGoodSubstrings(self, s: str) -&gt; int:\n        count = 0\n\n        for x, y, z in zip(s, s[1:], s[2:]):\n            if x != y and y != z and x != z:\n                count += 1\n        return count\n</code></pre> Explaination: This is third approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#3-maximum-number-of-occurrences-of-a-substring-leetcode1297","title":"3. Maximum Number of Occurrences of a Substring (Leetcode:1297)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int:\n        map = {}\n        for i in range(len(s)-minSize+1):\n            substr = s[i:i+minSize]\n            if len(set(substr))&lt;=maxLetters:\n                if substr in map: \n                    map[substr] +=1\n                else: \n                    map[substr]=1\n\n        return max(map.values(), default=0)\n</code></pre> Explaination: This is first approach</p> <p><pre><code>\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#4-k-radius-subarray-averages-leetcode2090","title":"4. K Radius Subarray Averages (Leetcode:2090)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def getAverages(self, nums: List[int], k: int) -&gt; List[int]:\n\n        window_size = 2 * k + 1\n        n = len(nums)\n\n        if n &lt; window_size: return [-1]* n\n\n        curr_sum = sum(nums[:window_size])\n        avgs= [-1]*k\n        avgs.append(curr_sum//window_size)\n\n        for i in range(k+1, n-k):\n            curr_sum += nums[i+k] - nums[i-k-1]\n            avgs.append(curr_sum//window_size)\n\n        for i in range(k): avgs.append(-1)\n\n        return avgs\n</code></pre> Explaination: This is first approach</p> <p><pre><code>class Solution:\n    def getAverages(self, nums: List[int], k: int) -&gt; List[int]:\n\n        if k == 0: return nums\n\n        window_size = 2 * k + 1\n        n = len(nums)\n        avgs = [-1] * n\n\n        if n &lt; window_size: return avgs\n\n        window_sum = sum(nums[:window_size])\n        avgs[k] = window_sum // window_size\n\n        for i in range(window_size, n):\n            window_sum+= nums[i] - nums[i - window_size]\n            avgs[i - k] = window_sum // window_size\n\n        return avgs\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#5-maximum-erasure-value-leetcode1695","title":"5. Maximum Erasure Value (Leetcode:1695)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#6-arithmetic-slices-leetcode413","title":"6. Arithmetic Slices (Leetcode:413)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#7-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold-leetcode1343","title":"7. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Leetcode:1343)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#8-permutation-in-string-leetcode567","title":"8. Permutation in String (Leetcode:567)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#9-maximum-points-you-can-obtain-from-cards-leetcode1423","title":"9. Maximum Points You Can Obtain from Cards (Leetcode:1423)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#10-sliding-window-maximum-leetcode239","title":"10. Sliding Window Maximum (Leetcode:239)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#11-sliding-window-median-leetcode480","title":"11. Sliding Window Median (Leetcode:480)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#12-subarrays-with-k-different-integers-leetcode992","title":"12. Subarrays with K Different Integers (Leetcode:992)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/04.%20Sliding%20Window/#13-minimum-window-substring-leetcode76","title":"13. Minimum Window Substring (Leetcode:76)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/","title":"05. Merge Intervals","text":""},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#description","title":"Description","text":"<p>The Merge Intervals technique is commonly used when dealing with a set of intervals, particularly when we need to combine or identify overlapping ranges. </p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#types-of-interval-relationships","title":"Types of Interval Relationships","text":"<p>When two intervals, \\(a = [a_1, a_2]\\) and \\(b = [b_1, b_2]\\), are compared, they can overlap in various ways. There are six common types of relationships:  </p> <ol> <li> <p>Non-overlapping (Separate):  </p> <ul> <li>Condition: \\(a_2 &lt; b_1\\) or \\(b_2 &lt; a_1\\)</li> <li>Description: The intervals do not overlap and are entirely separate. No merging is needed.</li> </ul> </li> <li> <p>Partial Overlap (b ends after a):</p> <ul> <li>Condition: \\(a_1 \\leq b_1 \\leq a_2 \\leq b_2\\)</li> <li>Description: The interval \\(b\\) partially overlaps \\(a\\), extending beyond it. In this case, \\(b\\)'s end is after \\(a\\)'s end.</li> </ul> </li> <li> <p>Complete Overlap (a contains b):</p> <ul> <li>Condition: \\(a_1 \\leq b_1 \\leq b_2 \\leq a_2\\)</li> <li>Description: The interval \\(a\\) completely contains \\(b\\). No merging is needed because \\(a\\) already encompasses \\(b\\).</li> </ul> </li> <li> <p>Partial Overlap (a ends after b):</p> <ul> <li>Condition: \\(b_1 \\leq a_1 \\leq b_2 \\leq a_2\\)</li> <li>Description: The interval \\(a\\) partially overlaps \\(b\\), extending beyond it. Here, \\(a\\)'s end is after \\(b\\)'s end.</li> </ul> </li> <li> <p>Complete Overlap (b contains a):</p> <ul> <li>Condition: \\(b_1 \\leq a_1 \\leq a_2 \\leq b_2\\)</li> <li>Description: The interval \\(b\\) completely contains \\(a\\). Like the previous case, no merging is needed because \\(b\\) already includes \\(a\\).</li> </ul> </li> <li> <p>Identical Intervals:</p> <ul> <li>Condition: \\(a_1 = b_1\\) and \\(a_2 = b_2\\)</li> <li>Description: The two intervals are exactly the same. No merging needed since they are already identical.</li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#the-general-merge-strategy","title":"The General Merge Strategy","text":"<ol> <li>Sorting Intervals    The first step is to sort the intervals by their start points (or first elements). This is crucial because once intervals are ordered, we can easily process them in sequence and determine if any two intervals overlap. Sorting ensures that we only need to look at adjacent intervals to check for overlap, simplifying the merging process.</li> <li>Merging Intervals    After sorting, you can iterate through the list of intervals and merge overlapping intervals:<ul> <li>Start with the first interval.</li> <li>For each subsequent interval:<ul> <li>If there is no overlap (i.e., the current interval ends before the next one starts), keep both intervals as separate entities.</li> <li>If there is an overlap (i.e., the current interval ends after or exactly at the start of the next interval), merge them by extending the end of the current interval to the maximum end value of both intervals.</li> </ul> </li> </ul> </li> </ol>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#practical-example","title":"Practical Example","text":"<p>Imagine you have time slots, and you're tasked with finding the combined time frame of various meetings that might overlap.</p> <p>Given Intervals: <code>[[1, 3], [2, 6], [15, 18], [8, 10]]</code> </p> <ol> <li>Sort the intervals:       After sorting by the starting time, the intervals are <code>[[1, 3], [2, 6], [8, 10], [15, 18]]</code>.  </li> <li>Merge the intervals:  <ul> <li>Compare [1, 3] and [2, 6]: Since they overlap (3 &gt; 2), merge them into [1, 6].  </li> <li>Compare [1, 6] with [8, 10]: No overlap (6 &lt; 8), so keep both intervals.  </li> <li>Compare [8, 10] with [15, 18]: No overlap (10 &lt; 15), so keep both intervals.  </li> </ul> </li> <li>Result:     The merged intervals are <code>[[1, 6], [8, 10], [15, 18]]</code>.  </li> </ol>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#1-merge-intervals-leetcode56","title":"1. Merge Intervals (Leetcode:56)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n\n        for interval in intervals:\n            if merged[-1][1] &lt; interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n\n        return merged\n</code></pre> Explaination: This is first approach</p> <p><pre><code>class Solution:\n    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:\n        intervals.sort(key=lambda x:x[0])\n        idx = 0\n\n        for i in range(1, len(intervals)):\n            if intervals[idx][1] &gt;= intervals[i][0]:\n                intervals[idx][1] = max(intervals[idx][1], intervals[i][1])\n            else:\n                idx+=1\n                intervals[idx]=intervals[i]\n        return intervals[:idx+1]\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#2-insert-interval-leetcode57","title":"2. Insert Interval (Leetcode:57)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n        answer = []\n        i, n = 0, len(intervals)\n\n        while i &lt; n and newInterval[0] &gt; intervals[i][0]:\n            answer.append(intervals[i])\n            i += 1\n\n        if not answer or answer[-1][1]&lt;newInterval[0]:\n            answer.append(newInterval)\n        else:\n            answer[-1][1] = max(answer[-1][1], newInterval[1])\n\n        while i&lt;n:\n            if answer[-1][1] &lt; intervals[i][0]:\n                answer.append(intervals[i])\n            else:\n                answer[-1][1] = max(answer[-1][1], intervals[i][1])\n\n            i+=1\n        return answer\n</code></pre> Explaination: This is first approach</p> <p><pre><code>class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n        answer = []\n        for i in range(len(intervals)):\n            if newInterval[1] &lt; intervals[i][0]:       \n                answer.append(newInterval)\n                return answer + intervals[i:]\n            elif intervals[i][1] &lt; newInterval[0]:    \n                answer.append(intervals[i])\n            else:\n                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n\n        answer.append(newInterval)\n        return answer    \n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#3-merge-two-sorted-lists-leetcode21","title":"3. Merge Two Sorted Lists (Leetcode:21)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2Approach 3 <p><pre><code>class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if list1 and list2:\n            if list1.val &gt; list2.val:\n                list1, list2 = list2, list1\n            list1.next = self.mergeTwoLists(list1.next, list2)\n        return list1 or list2\n</code></pre> Explaination: This is not merge intervals problem. fix this later</p> <p><pre><code>class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # If one of the lists is empty, return the other list directly\n        if not list1:\n            return list2\n        if not list2:\n            return list1\n\n        # Initialize the head of the merged list\n        if list1.val &lt; list2.val:\n            merged_head = list1\n            list1 = list1.next\n        else:\n            merged_head = list2\n            list2 = list2.next\n\n        current = merged_head\n\n        # Traverse both lists and merge them\n        while list1 and list2:\n            if list1.val &lt; list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n\n        # Attach the remaining part of the non-empty list\n        if list1:\n            current.next = list1\n        elif list2:\n            current.next = list2\n\n        return merged_head\n</code></pre> Explaination: This is second approach</p> <p><pre><code>class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if not list1 or not list2:\n            return list1 if list1 else list2\n\n        if list1.val &lt; list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2\n</code></pre> Explaination: This is Third approach</p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#4-merge-two-binary-trees-leetcode617","title":"4. Merge Two Binary Trees (Leetcode:617)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#5-interval-list-intersections-leetcode986","title":"5. Interval List Intersections (Leetcode:986)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -&gt; List[List[int]]:\n        ans, i, j = [], 0, 0\n\n        while i &lt; len(firstList) and j &lt; len(secondList):\n\n            head = max(firstList[i][0], secondList[j][0])\n            tail = min(firstList[i][1], secondList[j][1])\n\n            if head &lt;= tail: \n                ans.append([head, tail])\n\n            if firstList[i][1] &lt; secondList[j][1]: \n                i += 1\n            else: \n                j += 1\n\n        return ans\n</code></pre> Explaination: This is first approach</p> <p><pre><code>\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#6-single-threaded-cpu-leetcode1834","title":"6. Single-Threaded CPU (Leetcode:1834)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p> Explaination: This is first approach</p> <p> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/05.%20Merge%20Intervals/#7-car-pooling-leetcode1094","title":"7. Car Pooling (Leetcode:1094)","text":"<p>Problem Statement </p> Code and Explaination Approach 1Approach 2 <p><pre><code>class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -&gt; bool:\n        locations = []\n        for numPassengers, start, end in trips:\n            locations.extend([(start, numPassengers), (end, -numPassengers)])\n        locations.sort()\n\n        for _, numPassengers in locations:\n            capacity -= numPassengers\n            if capacity &lt; 0: return False\n\n        return True\n</code></pre> Explaination: This is first approach</p> <p><pre><code>\n</code></pre> Explaination: This is second approach</p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/","title":"06. Greedy Algorithms","text":""},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#description","title":"Description","text":""},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#1-maximum-69-numberleetcode1323","title":"1. Maximum 69 Number(Leetcode:1323)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#2-minimum-time-to-type-word-using-special-typewriter-leetcode1974","title":"2. Minimum Time to Type Word Using Special Typewriter (Leetcode:1974)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#3-minimum-number-of-operations-to-convert-time-leetcode2224","title":"3. Minimum Number of Operations to Convert Time (Leetcode:2224)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#4-jump-game-ii-leetcode45","title":"4. Jump Game II (Leetcode:45)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#5-minimum-score-by-changing-two-elements-leetcode2567","title":"5. Minimum Score by Changing Two Elements (Leetcode:2567)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#6-maximum-bags-with-full-capacity-of-rocks-leetcode2279","title":"6. Maximum Bags With Full Capacity of Rocks (Leetcode:2279)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#7-minimum-number-of-operations-to-make-arrays-similar-leetcode2449","title":"7. Minimum Number of Operations to Make Arrays Similar (Leetcode:2449)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#8-patching-array-leetcode330","title":"8. Patching Array (Leetcode:330)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#9-minimum-cost-to-equalize-array-leetcode3139","title":"9. Minimum Cost to Equalize Array (Leetcode:3139)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#10-count-k-subsequences-of-a-string-with-maximum-beauty-leetcode2842","title":"10. Count K-Subsequences of a String With Maximum Beauty (Leetcode:2842)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/06.%20Greedy%20Algorithm/#11-boats-to-save-people-leetcode881","title":"11. Boats to save people (Leetcode:881)","text":"<p>Problem Statement </p>"},{"location":"Programming/DSA%20Patterns/07.%20Divide%20and%20Conquer/","title":"07. Divide and Conquer","text":""},{"location":"Programming/DSA%20Patterns/07.%20Divide%20and%20Conquer/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/07.%20Divide%20and%20Conquer/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/","title":"08. Dynamic Programming","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#linear-dp","title":"Linear DP","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#2-dimensional-dp","title":"2 Dimensional DP","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#dp-on-grid","title":"DP On Grid","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#knapsack-dp","title":"Knapsack DP","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#longest-increasing-subsequence","title":"Longest Increasing Subsequence","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#longest-common-subsequence","title":"Longest Common Subsequence","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#dp-on-string","title":"DP on String","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#cummulative-sum","title":"Cummulative Sum","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#matrix-chain-multiplication","title":"Matrix Chain Multiplication","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#kadane-algo","title":"Kadane Algo","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#dp-with-bitmask","title":"DP with Bitmask","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#digit-dp","title":"Digit DP","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#dp-on-trees","title":"DP on Trees","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#dp-with-math","title":"DP with Math","text":""},{"location":"Programming/DSA%20Patterns/08.%20Dynamic%20Programming/#dp-with-probability","title":"Dp with Probability","text":""},{"location":"Programming/DSA%20Patterns/09.%20Backtracking/","title":"09. Recursion &amp; Backtracking","text":""},{"location":"Programming/DSA%20Patterns/09.%20Backtracking/#recursion-problems","title":"Recursion Problems","text":""},{"location":"Programming/DSA%20Patterns/09.%20Backtracking/#permutation-problems","title":"Permutation Problems","text":""},{"location":"Programming/DSA%20Patterns/09.%20Backtracking/#combination-problems","title":"Combination Problems","text":""},{"location":"Programming/DSA%20Patterns/09.%20Backtracking/#subsets-problems","title":"Subsets Problems","text":""},{"location":"Programming/DSA%20Patterns/09.%20Backtracking/#path-on-grid-problems","title":"Path on Grid Problems","text":""},{"location":"Programming/DSA%20Patterns/10.%20Union%20Find%20%28Disjoint%20Set%20Union%20-%20DSU%29/","title":"10. Union Find","text":""},{"location":"Programming/DSA%20Patterns/11.%20Segment%20Tree/","title":"11. Segment Tree","text":""},{"location":"Programming/DSA%20Patterns/11.%20Segment%20Tree/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/11.%20Segment%20Tree/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/12.%20KMP%20Algorithm/","title":"12. KMP Algorithm","text":""},{"location":"Programming/DSA%20Patterns/12.%20KMP%20Algorithm/#theory","title":"Theory","text":""},{"location":"Programming/DSA%20Patterns/12.%20KMP%20Algorithm/#problems","title":"Problems","text":""},{"location":"Programming/DSA%20Patterns/13.%20Rabin-Karp%20Algorithm/","title":"13. Robin-Karp Algorithm","text":""},{"location":"Programming/DSA%20Patterns/13.%20Rabin-Karp%20Algorithm/#introduction","title":"introduction","text":""},{"location":"Programming/DSA%20Patterns/14.%20Z%20Algorithm/","title":"14. Z Algorithm","text":""},{"location":"Programming/DSA%20Patterns/15.%20Boyer-Moore%20Voting%20Algorithm/","title":"15. Boyer-Moore Voting Algorithm","text":""},{"location":"Programming/Data%20Structures/Binary%20Search%20Tree/","title":"Binary Search Tree","text":""},{"location":"Programming/Data%20Structures/Binary%20Search%20Tree/#implementation","title":"Implementation","text":"<pre><code>class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        def _insert(root, key):\n            if root is None:\n                return Node(key)\n            if key &lt; root.key:\n                root.left = _insert(root.left, key)\n            else:\n                root.right = _insert(root.right, key)\n            return root\n\n        self.root = _insert(self.root, key)\n\n    def search(self, key):\n        def _search(root, key):\n            if root is None or root.key == key:\n                return root\n            if key &lt; root.key:\n                return _search(root.left, key)\n            return _search(root.right, key)\n\n        return _search(self.root, key) is not None\n\n    def delete(self, key):\n        def _delete(root, key):\n            if root is None:\n                return root\n            if key &lt; root.key:\n                root.left = _delete(root.left, key)\n            elif key &gt; root.key:\n                root.right = _delete(root.right, key)\n            else:\n                if root.left is None:\n                    return root.right\n                elif root.right is None:\n                    return root.left\n                min_larger_node = self._get_min(root.right)\n                root.key = min_larger_node.key\n                root.right = _delete(root.right, min_larger_node.key)\n            return root\n\n        self.root = _delete(self.root, key)\n\n    def floor(self, key):\n        def _floor(root, key, floor_val=None):\n            if root is None:\n                return floor_val\n            if root.key == key:\n                return root.key\n            elif key &lt; root.key:\n                return _floor(root.left, key, floor_val)\n            else:\n                floor_val = root.key  # Current node could be a candidate for the floor\n                return _floor(root.right, key, floor_val)\n\n        return _floor(self.root, key)\n\n    def ceil(self, key):\n        def _ceil(root, key, ceil_val=None):\n            if root is None:\n                return ceil_val\n            if root.key == key:\n                return root.key\n            elif key &gt; root.key:\n                return _ceil(root.right, key, ceil_val)\n            else:\n                ceil_val = root.key  # Current node could be a candidate for the ceil\n                return _ceil(root.left, key, ceil_val)\n\n        return _ceil(self.root, key)\n\n    def inorder(self):\n        def _inorder(root):\n            return _inorder(root.left) + [root.key] + _inorder(root.right) if root else []\n\n        return _inorder(self.root)\n\n    def _get_min(self, root):\n        while root.left:\n            root = root.left\n        return root\n\n# Example usage:\nbst = BinarySearchTree()\nbst.insert(20)\nbst.insert(8)\nbst.insert(22)\nbst.insert(4)\nbst.insert(12)\nbst.insert(10)\nbst.insert(14)\n\n# Inorder traversal\nprint(\"Inorder traversal:\", bst.inorder())\n\n# Search for an element\nprint(\"Search 10:\", bst.search(10))  # Should return True\nprint(\"Search 25:\", bst.search(25))  # Should return False\n\n# Floor and Ceil\nprint(\"Floor of 13:\", bst.floor(13))  # Should return 12\nprint(\"Ceil of 13:\", bst.ceil(13))    # Should return 14\n\n# Deleting a node\nbst.delete(10)\nprint(\"Inorder after deleting 10:\", bst.inorder())\n\nbst.delete(8)\nprint(\"Inorder after deleting 8:\", bst.inorder())\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/","title":"Deque","text":""},{"location":"Programming/Data%20Structures/Deque/#using-linkedlist","title":"Using LinkedList","text":"<pre><code>class Node:\n    def __init__(self, value=None):\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass Deque:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size = 0\n\n    def is_empty(self):\n        \"\"\"Returns True if the deque is empty, otherwise False.\"\"\"\n        return self.size == 0\n\n    def get_size(self):\n        \"\"\"Returns the number of elements in the deque.\"\"\"\n        return self.size\n\n    def add_front(self, value):\n        \"\"\"Adds a value to the front of the deque.\"\"\"\n        new_node = Node(value)\n        if self.is_empty():\n            self.front = self.rear = new_node\n        else:\n            new_node.next = self.front\n            self.front.prev = new_node\n            self.front = new_node\n        self.size += 1\n\n    def add_rear(self, value):\n        \"\"\"Adds a value to the rear of the deque.\"\"\"\n        new_node = Node(value)\n        if self.is_empty():\n            self.front = self.rear = new_node\n        else:\n            new_node.prev = self.rear\n            self.rear.next = new_node\n            self.rear = new_node\n        self.size += 1\n\n    def remove_front(self):\n        \"\"\"Removes and returns the front element of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        value = self.front.value\n        if self.front == self.rear:\n            self.front = self.rear = None\n        else:\n            self.front = self.front.next\n            self.front.prev = None\n        self.size -= 1\n        return value\n\n    def remove_rear(self):\n        \"\"\"Removes and returns the rear element of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        value = self.rear.value\n        if self.front == self.rear:\n            self.front = self.rear = None\n        else:\n            self.rear = self.rear.prev\n            self.rear.next = None\n        self.size -= 1\n        return value\n\n    def peek_front(self):\n        \"\"\"Returns the value at the front of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.front.value\n\n    def peek_rear(self):\n        \"\"\"Returns the value at the rear of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.rear.value\n\n    def display(self):\n        \"\"\"Returns a list of all elements in the deque.\"\"\"\n        elements = []\n        current = self.front\n        while current:\n            elements.append(current.value)\n            current = current.next\n        return elements\n\n# Example usage of the Deque class:\n\ndeque = Deque()\n\n# Adding elements to the front and rear\ndeque.add_front(10)\ndeque.add_rear(20)\ndeque.add_front(5)\ndeque.add_rear(30)\n\n# Displaying the deque\nprint(\"Deque elements:\", deque.display())  # Output: [5, 10, 20, 30]\n\n# Peeking at the front and rear\nprint(\"Front element:\", deque.peek_front())  # Output: 5\nprint(\"Rear element:\", deque.peek_rear())    # Output: 30\n\n# Removing elements from the front and rear\nremoved_front = deque.remove_front()\nremoved_rear = deque.remove_rear()\n\n# Displaying the deque after removals\nprint(\"Deque after removals:\", deque.display())  # Output: [10, 20]\n\n# Displaying the removed elements\nprint(\"Removed from front:\", removed_front)  # Output: 5\nprint(\"Removed from rear:\", removed_rear)    # Output: 30\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#reverse-deque","title":"Reverse Deque","text":"<pre><code>def reverse_deque(deque):\n    left, right = deque.front, deque.rear\n    while left != right and left.prev != right:\n        # Swap left and right values\n        left.value, right.value = right.value, left.value\n        # Move pointers towards the center\n        left = left.next\n        right = right.prev\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#rotate-clockwise","title":"Rotate Clockwise","text":"<pre><code>def rotate_clockwise(deque):\n    if deque.is_empty():\n        return\n    # Remove element from rear and add it to the front\n    value = deque.remove_rear()\n    deque.add_front(value)\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#rotate-counterclockwise","title":"Rotate Counterclockwise","text":"<pre><code>def rotate_counterclockwise(deque):\n    if deque.is_empty():\n        return\n    # Remove element from front and add it to the rear\n    value = deque.remove_front()\n    deque.add_rear(value)\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#palindrome-check","title":"Palindrome Check","text":"<pre><code>def is_palindrome(deque):\n    while deque.get_size() &gt; 1:\n        if deque.remove_front() != deque.remove_rear():\n            return False\n    return True\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#merge-two-deques","title":"Merge Two Deques","text":"<pre><code>def merge_deques(deque1, deque2):\n    while not deque2.is_empty():\n        deque1.add_rear(deque2.remove_front())\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#using-list","title":"Using List","text":"<pre><code>class Deque:\n    def __init__(self):\n        self.deque = []\n\n    def is_empty(self):\n        \"\"\"Returns True if the deque is empty, otherwise False.\"\"\"\n        return len(self.deque) == 0\n\n    def get_size(self):\n        \"\"\"Returns the number of elements in the deque.\"\"\"\n        return len(self.deque)\n\n    def add_front(self, value):\n        \"\"\"Adds a value to the front of the deque.\"\"\"\n        self.deque.insert(0, value)\n\n    def add_rear(self, value):\n        \"\"\"Adds a value to the rear of the deque.\"\"\"\n        self.deque.append(value)\n\n    def remove_front(self):\n        \"\"\"Removes and returns the front element of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.deque.pop(0)\n\n    def remove_rear(self):\n        \"\"\"Removes and returns the rear element of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.deque.pop()\n\n    def peek_front(self):\n        \"\"\"Returns the value at the front of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.deque[0]\n\n    def peek_rear(self):\n        \"\"\"Returns the value at the rear of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self.deque[-1]\n\n    def display(self):\n        \"\"\"Returns a list of all elements in the deque.\"\"\"\n        return self.deque\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#reverse-deque_1","title":"Reverse Deque","text":"<pre><code>def reverse_deque(deque):\n    \"\"\"Reverses the elements in the deque.\"\"\"\n    left, right = 0, len(deque.deque) - 1\n    while left &lt; right:\n        # Swap left and right values\n        deque.deque[left], deque.deque[right] = deque.deque[right], deque.deque[left]\n        # Move pointers towards the center\n        left += 1\n        right -= 1\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#rotate-clockwise_1","title":"Rotate Clockwise","text":"<pre><code>def rotate_clockwise(deque):\n    \"\"\"Rotates the deque clockwise (moves the rear element to the front).\"\"\"\n    if deque.is_empty():\n        return\n    value = deque.remove_rear()\n    deque.add_front(value)\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#rotate-counterclockwise_1","title":"Rotate Counterclockwise","text":"<pre><code>def rotate_counterclockwise(deque):\n    \"\"\"Rotates the deque counterclockwise (moves the front element to the rear).\"\"\"\n    if deque.is_empty():\n        return\n    value = deque.remove_front()\n    deque.add_rear(value)\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#palindrome-check_1","title":"Palindrome Check","text":"<pre><code>def is_palindrome(deque):\n    \"\"\"Checks if the deque is a palindrome.\"\"\"\n    while deque.get_size() &gt; 1:\n        if deque.remove_front() != deque.remove_rear():\n            return False\n    return True\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#merge-two-deques_1","title":"Merge Two Deques","text":"<pre><code>def merge_deques(deque1, deque2):\n    \"\"\"Merges deque2 into deque1 by appending elements of deque2 to the rear of deque1.\"\"\"\n    while not deque2.is_empty():\n        deque1.add_rear(deque2.remove_front())\n</code></pre>"},{"location":"Programming/Data%20Structures/Deque/#deque-from-collections-module","title":"Deque from collections module","text":"<pre><code>from collections import deque\n\n# 1. Creating a Deque\nd = deque(range(1, 11))  # Initialize deque with 10 elements\nprint(\"Initial deque:\", d)\n\n# 2. Adding Elements\nd.append(11)            # Add to the right\nd.appendleft(0)         # Add to the left\nprint(\"After append and appendleft:\", d)\n\n# 3. Removing Elements\nd.pop()                 # Remove from the right\nd.popleft()             # Remove from the left\nprint(\"After pop and popleft:\", d)\n\n# 4. Extending a Deque\nd.extend(range(12, 16))       # Add multiple elements to the right\nd.extendleft([-3, -2, -1])    # Add multiple elements to the left (reversed order)\nprint(\"After extend and extendleft:\", d)\n\n# 5. Rotating the Deque\nd.rotate(5)  # Rotate right by 5\nprint(\"After rotating right by 5:\", d)\nd.rotate(-3)  # Rotate left by 3\nprint(\"After rotating left by 3:\", d)\n\n# 6. Accessing Elements\nprint(\"First element:\", d[0])\nprint(\"Last element:\", d[-1])\n\n# 7. Other Methods\nprint(\"Count of 5:\", d.count(5))  # Count occurrences of 5\nd.remove(5)                      # Remove the first occurrence of 5\nprint(\"After removing 5:\", d)\nd.clear()                        # Clear the deque\nprint(\"After clearing:\", d)\n\n# 8. Limiting the Size\nd = deque(maxlen=10)  # Create a deque with a maximum size of 10\nd.extend(range(1, 11))  # Fill the deque with 10 elements\nprint(\"Deque with maxlen=10:\", d)\n\n# Add more elements to demonstrate overflow behavior\nd.append(11)  # This will remove the oldest element (1)\nd.append(12)  # This will remove the next oldest element (2)\nprint(\"Deque after adding elements beyond maxlen:\", d)\n\n# 9. Initializing an Empty Deque\nempty_d = deque()\nprint(\"Empty deque:\", empty_d)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/","title":"Graph","text":""},{"location":"Programming/Data%20Structures/Graph/#terminologies","title":"Terminologies","text":""},{"location":"Programming/Data%20Structures/Graph/#graph-representation","title":"Graph Representation","text":""},{"location":"Programming/Data%20Structures/Graph/#adjecency-matrix","title":"Adjecency Matrix","text":"<pre><code>class GraphAdjMatrix:\n    def __init__(self, num_vertices, graph_type='directed'):\n        self.num_vertices = num_vertices\n        self.graph_type = graph_type.lower()\n        self.matrix = [[0] * num_vertices for _ in range(num_vertices)]\n\n    def add_edge(self, u, v):\n        if u &lt; 0 or v &lt; 0 or u &gt;= self.num_vertices or v &gt;= self.num_vertices:\n            print(f\"Invalid vertices: {u}, {v}\")\n            return\n        self.matrix[u][v] = 1\n        if self.graph_type == 'undirected':\n            self.matrix[v][u] = 1\n\n    def print_graph(self):\n        print(f\"Adjacency Matrix ({self.graph_type.capitalize()} Graph):\")\n        for row in self.matrix:\n            print(row)\n\ndirected_graph = GraphAdjMatrix(4, 'directed')\ndirected_graph.add_edge(0, 1)\ndirected_graph.add_edge(0, 2)\ndirected_graph.add_edge(1, 3)\ndirected_graph.add_edge(2, 3)\n\nprint(\"Directed Graph:\")\ndirected_graph.print_graph()\nprint(\"\\n\")\n\nundirected_graph = GraphAdjMatrix(4, 'undirected')\nundirected_graph.add_edge(0, 1)\nundirected_graph.add_edge(0, 2)\nundirected_graph.add_edge(1, 3)\nundirected_graph.add_edge(2, 3)\n\nprint(\"Undirected Graph:\")\nundirected_graph.print_graph()\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#adjecency-list","title":"Adjecency List","text":"<pre><code>class GraphAdjList:\n    def __init__(self, num_vertices, graph_type='directed'):\n        self.num_vertices = num_vertices\n        self.graph_type = graph_type.lower()\n        self.adj_list = {i: [] for i in range(num_vertices)}\n\n    def add_edge(self, u, v):\n        if u &lt; 0 or v &lt; 0 or u &gt;= self.num_vertices or v &gt;= self.num_vertices:\n            print(f\"Invalid vertices: {u}, {v}\")\n            return\n        self.adj_list[u].append(v)\n        if self.graph_type == 'undirected':\n            self.adj_list[v].append(u)\n\n    def print_graph(self):\n        print(f\"Adjacency List ({self.graph_type.capitalize()} Graph):\")\n        for node in self.adj_list:\n            print(f\"{node}: {self.adj_list[node]}\")\n\ndirected_graph = GraphAdjList(4, 'directed')\ndirected_graph.add_edge(0, 1)\ndirected_graph.add_edge(0, 2)\ndirected_graph.add_edge(1, 3)\ndirected_graph.add_edge(2, 3)\n\nprint(\"Directed Graph:\")\ndirected_graph.print_graph()\nprint(\"\\n\")\n\nundirected_graph = GraphAdjList(4, 'undirected')\nundirected_graph.add_edge(0, 1)\nundirected_graph.add_edge(0, 2)\nundirected_graph.add_edge(1, 3)\nundirected_graph.add_edge(2, 3)\n\nprint(\"Undirected Graph:\")\nundirected_graph.print_graph()\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#bfs","title":"BFS","text":""},{"location":"Programming/Data%20Structures/Graph/#bfs-for-undirected-graph-with-source","title":"BFS for Undirected graph with source","text":"<pre><code>from collections import deque\n\ndef bfs(graph, source):\n    visited = set()\n\n    queue = deque([source])\n\n    visited.add(source)\n\n    bfs_result = []\n\n    while queue:\n        current = queue.popleft()\n\n        bfs_result.append(current)\n\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return bfs_result\n\nif __name__ == \"__main__\":\n    graph = {\n        0: [1, 2],\n        1: [0, 3, 4],\n        2: [0],\n        3: [1],\n        4: [1]\n    }\n\n    source_vertex = 0\n    result = bfs(graph, source_vertex)\n    print(\"BFS Traversal:\", result)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#bfs-for-disconnected-graph","title":"BFS for Disconnected Graph","text":"<pre><code>from collections import deque\n\ndef bfs(graph, source, visited):\n    # Initialize the queue for BFS\n    queue = deque([source])\n\n    # Mark the source vertex as visited\n    visited.add(source)\n\n    # Result list to store the BFS traversal\n    bfs_result = []\n\n    # Perform BFS\n    while queue:\n        # Dequeue a vertex from the queue\n        current = queue.popleft()\n\n        # Add the current vertex to the result\n        bfs_result.append(current)\n\n        # Visit all the neighbors of the current vertex\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                # Mark as visited and enqueue the neighbor\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return bfs_result\n\ndef bfs_disconnected(graph):\n    # Create a visited set to track visited vertices\n    visited = set()\n    result = []\n\n    # Traverse through all vertices in the graph\n    for vertex in graph:\n        if vertex not in visited:\n            # Perform BFS from each unvisited vertex (handles disconnected components)\n            component_bfs = bfs(graph, vertex, visited)\n            result.append(component_bfs)\n\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example of a disconnected graph\n    graph = {\n        0: [1, 2],\n        1: [0, 3],\n        2: [0],\n        3: [1],\n        4: [5],\n        5: [4]\n    }\n\n    # Perform BFS for the entire graph\n    result = bfs_disconnected(graph)\n    print(\"BFS Traversal of each component:\", result)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#count-connected-components-with-bfs","title":"count connected components with BFS","text":"<pre><code>from collections import deque\n\ndef bfs(graph, source, visited):\n    # Initialize the queue for BFS\n    queue = deque([source])\n\n    # Mark the source vertex as visited\n    visited.add(source)\n\n    # Perform BFS\n    while queue:\n        # Dequeue a vertex from the queue\n        current = queue.popleft()\n\n        # Visit all the neighbors of the current vertex\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                # Mark as visited and enqueue the neighbor\n                visited.add(neighbor)\n                queue.append(neighbor)\n\ndef count_connected_components(graph):\n    # Create a visited set to track visited vertices\n    visited = set()\n\n    # Variable to store the count of connected components\n    component_count = 0\n\n    # Traverse through all vertices in the graph\n    for vertex in graph:\n        if vertex not in visited:\n            # Perform BFS to find the connected component for each unvisited vertex\n            bfs(graph, vertex, visited)\n            # After finishing BFS for a component, increment the component count\n            component_count += 1\n\n    return component_count\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example of a disconnected graph\n    graph = {\n        0: [1, 2],\n        1: [0, 3],\n        2: [0],\n        3: [1],\n        4: [5],\n        5: [4]\n    }\n\n    # Find and print the count of connected components\n    result = count_connected_components(graph)\n    print(\"Number of connected components:\", result)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#dfs","title":"DFS","text":""},{"location":"Programming/Data%20Structures/Graph/#dfs-for-undirected-graph-with-source","title":"DFS for Undirected Graph with Source","text":"<pre><code># DFS for Undirected Graph with Source\nfrom collections import defaultdict\n\ndef dfs(graph, source, visited, dfs_result):\n    # Mark the source vertex as visited\n    visited.add(source)\n\n    # Add the source vertex to the result\n    dfs_result.append(source)\n\n    # Visit all the neighbors of the current vertex\n    for neighbor in graph[source]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited, dfs_result)\n\nif __name__ == \"__main__\":\n    graph = {\n        0: [1, 2],\n        1: [0, 3, 4],\n        2: [0],\n        3: [1],\n        4: [1]\n    }\n\n    source_vertex = 0\n    visited = set()\n    dfs_result = []\n\n    # Perform DFS starting from the source vertex\n    dfs(graph, source_vertex, visited, dfs_result)\n    print(\"DFS Traversal:\", dfs_result)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#dfs-for-disconnected-graph","title":"DFS for Disconnected Graph","text":"<pre><code># DFS for Disconnected Graph\nfrom collections import defaultdict\n\ndef dfs(graph, source, visited, dfs_result):\n    # Mark the source vertex as visited\n    visited.add(source)\n\n    # Add the source vertex to the result\n    dfs_result.append(source)\n\n    # Visit all the neighbors of the current vertex\n    for neighbor in graph[source]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited, dfs_result)\n\ndef dfs_disconnected(graph):\n    visited = set()\n    result = []\n\n    # Traverse through all vertices in the graph\n    for vertex in graph:\n        if vertex not in visited:\n            # Perform DFS from each unvisited vertex (handles disconnected components)\n            component_dfs = []\n            dfs(graph, vertex, visited, component_dfs)\n            result.append(component_dfs)\n\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example of a disconnected graph\n    graph = {\n        0: [1, 2],\n        1: [0, 3],\n        2: [0],\n        3: [1],\n        4: [5],\n        5: [4]\n    }\n\n    # Perform DFS for the entire graph\n    result = dfs_disconnected(graph)\n    print(\"DFS Traversal of each component:\", result)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#count-connected-components-with-dfs","title":"Count Connected Components with DFS","text":"<pre><code># Count Connected Components with DFS\nfrom collections import defaultdict\n\ndef dfs(graph, source, visited):\n    # Mark the source vertex as visited\n    visited.add(source)\n\n    # Visit all the neighbors of the current vertex\n    for neighbor in graph[source]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n\ndef count_connected_components(graph):\n    visited = set()\n    component_count = 0\n\n    # Traverse through all vertices in the graph\n    for vertex in graph:\n        if vertex not in visited:\n            # Perform DFS to find the connected component for each unvisited vertex\n            dfs(graph, vertex, visited)\n            # After finishing DFS for a component, increment the component count\n            component_count += 1\n\n    return component_count\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example of a disconnected graph\n    graph = {\n        0: [1, 2],\n        1: [0, 3],\n        2: [0],\n        3: [1],\n        4: [5],\n        5: [4]\n    }\n\n    # Find and print the count of connected components\n    result = count_connected_components(graph)\n    print(\"Number of connected components:\", result)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#cycle-detection","title":"Cycle Detection","text":""},{"location":"Programming/Data%20Structures/Graph/#dfs-based-cycle-detection","title":"DFS Based Cycle Detection","text":"<pre><code>def has_cycle(graph, vertex, visited, parent):\n    visited.add(vertex)\n\n    for neighbor in graph[vertex]:\n        if neighbor not in visited:\n            if has_cycle(graph, neighbor, visited, vertex):\n                return True\n        elif neighbor != parent:\n            return True\n    return False\n\ndef cycle_detection(graph):\n    visited = set()\n    for vertex in graph:\n        if vertex not in visited:\n            if has_cycle(graph, vertex, visited, None):\n                return True\n    return False\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#union-based-cycle-detection-undirected-graph","title":"Union Based Cycle Detection (Undirected graph)","text":"<pre><code>class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # Path compression\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n\n        if rootX != rootY:\n            if self.rank[rootX] &gt; self.rank[rootY]:\n                self.parent[rootY] = rootX\n            elif self.rank[rootX] &lt; self.rank[rootY]:\n                self.parent[rootX] = rootY\n            else:\n                self.parent[rootY] = rootX\n                self.rank[rootX] += 1\n        else:\n            return True  # Cycle detected\n        return False\n\ndef cycle_detection(graph, num_vertices):\n    uf = UnionFind(num_vertices)\n    for u in graph:\n        for v in graph[u]:\n            if uf.union(u, v):  # If union returns True, a cycle exists\n                return True\n    return False\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#topological-sort-based-cycle-detection-directed-graph","title":"Topological Sort based cycle detection (Directed Graph)","text":"<pre><code>from collections import deque\n\ndef topological_sort(graph, num_vertices):\n    in_degree = [0] * num_vertices\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n\n    queue = deque([i for i in range(num_vertices) if in_degree[i] == 0])\n    sorted_list = []\n\n    while queue:\n        node = queue.popleft()\n        sorted_list.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    return sorted_list if len(sorted_list) == num_vertices else None  # None if cycle is detected\n\n# Example usage for cycle detection:\ngraph = {0: [1], 1: [2], 2: [0]}  # A graph with a cycle\nprint(\"Cycle detected:\", topological_sort(graph, 3) is None)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#topological-sort","title":"Topological Sort","text":""},{"location":"Programming/Data%20Structures/Graph/#kahns-algorithm-bfs-based","title":"Kahn's Algorithm (BFS-Based)","text":"<pre><code>from collections import deque, defaultdict\n\ndef topological_sort(graph, num_vertices):\n    in_degree = [0] * num_vertices\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n\n    queue = deque([i for i in range(num_vertices) if in_degree[i] == 0])\n    sorted_list = []\n\n    while queue:\n        node = queue.popleft()\n        sorted_list.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    return sorted_list if len(sorted_list) == num_vertices else None  # None if cycle detected\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#dfs-based-topological-sort","title":"DFS  based Topological Sort","text":"<pre><code>def dfs(graph, vertex, visited, stack):\n    visited.add(vertex)\n    for neighbor in graph[vertex]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited, stack)\n    stack.append(vertex)\n\ndef topological_sort(graph, num_vertices):\n    visited = set()\n    stack = []\n\n    for vertex in range(num_vertices):\n        if vertex not in visited:\n            dfs(graph, vertex, visited, stack)\n\n    return stack[::-1]  # Reverse the stack for correct topological order\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#dfs-based-with-cycle-detection","title":"DFS based with Cycle Detection","text":"<pre><code>def dfs(graph, vertex, visited, stack, temp_stack):\n    visited.add(vertex)\n    temp_stack.add(vertex)\n\n    for neighbor in graph[vertex]:\n        if neighbor in temp_stack:\n            return False  # Cycle detected\n        if neighbor not in visited:\n            if not dfs(graph, neighbor, visited, stack, temp_stack):\n                return False\n\n    stack.append(vertex)\n    temp_stack.remove(vertex)\n    return True\n\ndef topological_sort(graph, num_vertices):\n    visited = set()\n    stack = []\n    for vertex in range(num_vertices):\n        if vertex not in visited:\n            temp_stack = set()\n            if not dfs(graph, vertex, visited, stack, temp_stack):\n                return None  # Cycle detected\n    return stack[::-1]\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#flood-fill","title":"Flood Fill","text":""},{"location":"Programming/Data%20Structures/Graph/#dfs-based-flood-fill","title":"DFS based flood fill","text":"<pre><code>def flood_fill(grid, x, y, new_color, original_color):\n    if x &lt; 0 or x &gt;= len(grid) or y &lt; 0 or y &gt;= len(grid[0]):\n        return\n    if grid[x][y] != original_color:\n        return\n\n    grid[x][y] = new_color\n\n    flood_fill(grid, x+1, y, new_color, original_color)\n    flood_fill(grid, x-1, y, new_color, original_color)\n    flood_fill(grid, x, y+1, new_color, original_color)\n    flood_fill(grid, x, y-1, new_color, original_color)\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#bfs-based-flood-fill","title":"BFS Based Flood Fill","text":"<pre><code>from collections import deque\n\ndef flood_fill(grid, x, y, new_color, original_color):\n    if x &lt; 0 or x &gt;= len(grid) or y &lt; 0 or y &gt;= len(grid[0]):\n        return\n    if grid[x][y] != original_color:\n        return\n\n    queue = deque([(x, y)])\n    grid[x][y] = new_color\n\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 &lt;= nx &lt; len(grid) and 0 &lt;= ny &lt; len(grid[0]) and grid[nx][ny] == original_color:\n                grid[nx][ny] = new_color\n                queue.append((nx, ny))\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#dijsktra-algorithm","title":"Dijsktra Algorithm","text":""},{"location":"Programming/Data%20Structures/Graph/#minheap-based","title":"MinHeap Based","text":"<pre><code>import heapq\n\ndef dijkstra(graph, start):\n    pq = [(0, start)]\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n\n    while pq:\n        current_dist, current_vertex = heapq.heappop(pq)\n\n        if current_dist &gt; distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex]:\n            distance = current_dist + weight\n            if distance &lt; distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n\n    return distances\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#using-simple-array","title":"using simple array","text":"<pre><code>def dijkstra(graph, start):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) &lt; len(graph):\n        min_distance = float('inf')\n        min_vertex = None\n\n        for vertex in graph:\n            if vertex not in visited and distances[vertex] &lt; min_distance:\n                min_distance = distances[vertex]\n                min_vertex = vertex\n\n        visited.add(min_vertex)\n\n        for neighbor, weight in graph[min_vertex]:\n            if neighbor not in visited:\n                new_distance = distances[min_vertex] + weight\n                if new_distance &lt; distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#bellman-ford","title":"Bellman Ford","text":""},{"location":"Programming/Data%20Structures/Graph/#basic-with-iterative-cycle","title":"Basic with iterative cycle","text":"<pre><code>def bellman_ford(graph, vertices, start):\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n\n    for _ in range(len(vertices) - 1):\n        for u in graph:\n            for v, weight in graph[u]:\n                if distances[u] + weight &lt; distances[v]:\n                    distances[v] = distances[u] + weight\n\n    # Check for negative weight cycles\n    for u in graph:\n        for v, weight in graph[u]:\n            if distances[u] + weight &lt; distances[v]:\n                raise ValueError(\"Graph contains a negative weight cycle\")\n\n    return distances\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#bellman-ford-with-early-stopping","title":"Bellman ford with early stopping","text":"<pre><code>def bellman_ford(graph, vertices, start):\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n\n    for _ in range(len(vertices) - 1):\n        updated = False\n        for u in graph:\n            for v, weight in graph[u]:\n                if distances[u] + weight &lt; distances[v]:\n                    distances[v] = distances[u] + weight\n                    updated = True\n        if not updated:\n            break\n\n    # Check for negative weight cycles\n    for u in graph:\n        for v, weight in graph[u]:\n            if distances[u] + weight &lt; distances[v]:\n                raise ValueError(\"Graph contains a negative weight cycle\")\n\n    return distances\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#floyd-warshall","title":"Floyd Warshall","text":""},{"location":"Programming/Data%20Structures/Graph/#basic-floyd-warshall-algorithm","title":"Basic Floyd Warshall algorithm","text":"<pre><code>def floyd_warshall(graph, num_vertices):\n    dist = [[float('inf')] * num_vertices for _ in range(num_vertices)]\n\n    for u in range(num_vertices):\n        dist[u][u] = 0\n    for u in graph:\n        for v, weight in graph[u]:\n            dist[u][v] = weight\n\n    for k in range(num_vertices):\n        for i in range(num_vertices):\n            for j in range(num_vertices):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#floyd-warshall-with-path-tracking","title":"Floyd Warshall with path tracking","text":"<pre><code>def floyd_warshall(graph, num_vertices):\n    dist = [[float('inf')] * num_vertices for _ in range(num_vertices)]\n    next_node = [[-1] * num_vertices for _ in range(num_vertices)]\n\n    for u in range(num_vertices):\n        dist[u][u] = 0\n        next_node[u][u] = u\n    for u in graph:\n        for v, weight in graph[u]:\n            dist[u][v] = weight\n            next_node[u][v] = v\n\n    for k in range(num_vertices):\n        for i in range(num_vertices):\n            for j in range(num_vertices):\n                if dist[i][j] &gt; dist[i][k] + dist[k][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_node[i][j] = next_node[i][k]\n\n    return dist, next_node\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#travelling-salesman-problem","title":"Travelling Salesman Problem","text":""},{"location":"Programming/Data%20Structures/Graph/#dynamic-programming-held-karp","title":"Dynamic programming (Held-Karp)","text":"<pre><code>import itertools\n\ndef tsp(graph, num_vertices):\n    # dp[mask][i] represents the minimum cost to visit all nodes in mask and end at i\n    dp = [[float('inf')] * num_vertices for _ in range(1 &lt;&lt; num_vertices)]\n    dp[1][0] = 0  # Starting point\n\n    for mask in range(1, 1 &lt;&lt; num_vertices):\n        for u in range(num_vertices):\n            if (mask &amp; (1 &lt;&lt; u)) == 0:\n                continue\n            for v in range(num_vertices):\n                if (mask &amp; (1 &lt;&lt; v)) == 0:\n                    dp[mask | (1 &lt;&lt; v)][v] = min(dp[mask | (1 &lt;&lt; v)][v], dp[mask][u] + graph[u][v])\n\n    return min(dp[(1 &lt;&lt; num_vertices) - 1][i] for i in range(1, num_vertices))\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#greedy-approach","title":"Greedy Approach","text":"<pre><code>def tsp(graph, start=0):\n    visited = set([start])\n    total_cost = 0\n    current_vertex = start\n\n    while len(visited) &lt; len(graph):\n        next_vertex = None\n        min_cost = float('inf')\n        for neighbor, weight in graph[current_vertex]:\n            if neighbor not in visited and weight &lt; min_cost:\n                next_vertex = neighbor\n                min_cost = weight\n\n        visited.add(next_vertex)\n        total_cost += min_cost\n        current_vertex = next_vertex\n\n    return total_cost\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#disjoint-set-union","title":"Disjoint Set Union","text":""},{"location":"Programming/Data%20Structures/Graph/#basic-union-find","title":"Basic Union-Find","text":"<pre><code>class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            self.parent[rootY] = rootX\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#with-path-compression-and-union-by-rank","title":"With Path compression and union by rank","text":"<pre><code>class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] &gt; self.rank[rootY]:\n                self.parent[rootY] = rootX\n            elif self.rank[rootX] &lt; self.rank[rootY]:\n                self.parent[rootX] = rootY\n            else:\n                self.parent[rootY] = rootX\n                self.rank[rootX] += 1\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#minimum-spanning-tree","title":"Minimum Spanning Tree","text":""},{"location":"Programming/Data%20Structures/Graph/#kruskals-algorithm-with-union-find","title":"Kruskal's Algorithm with Union-Find","text":"<pre><code>class Edge:\n    def __init__(self, u, v, weight):\n        self.u = u\n        self.v = v\n        self.weight = weight\n\n    def __lt__(self, other):\n        return self.weight &lt; other.weight\n\ndef kruskal(graph, num_vertices):\n    edges = []\n    for u in graph:\n        for v, weight in graph[u]:\n            edges.append(Edge(u, v, weight))\n\n    edges.sort()\n\n    uf = UnionFind(num_vertices)\n    mst = []\n    mst_weight = 0\n\n    for edge in edges:\n        if uf.find(edge.u) != uf.find(edge.v):\n            uf.union(edge.u, edge.v)\n            mst.append((edge.u, edge.v, edge.weight))\n            mst_weight += edge.weight\n\n    return mst, mst_weight\n</code></pre>"},{"location":"Programming/Data%20Structures/Graph/#prims-algorithm-greedy","title":"Prims Algorithm (greedy)","text":"<pre><code>import heapq\n\ndef prim(graph, num_vertices):\n    min_heap = [(0, 0)]  # Start with vertex 0, cost 0\n    mst = []\n    in_mst = [False] * num_vertices\n    total_weight = 0\n\n    while min_heap:\n        weight, u = heapq.heappop(min_heap)\n        if in_mst[u]:\n            continue\n        in_mst[u] = True\n        total_weight += weight\n        if weight &gt; 0:\n            mst.append(u)\n\n        for v, w in graph[u]:\n            if not in_mst[v]:\n                heapq.heappush(min_heap, (w, v))\n\n    return mst, total_weight\n</code></pre>"},{"location":"Programming/Data%20Structures/Hashing/","title":"Hashing","text":""},{"location":"Programming/Data%20Structures/Hashing/#introduction","title":"Introduction","text":""},{"location":"Programming/Data%20Structures/Hashing/#hash-collisions","title":"Hash Collisions","text":""},{"location":"Programming/Data%20Structures/Hashing/#chaining","title":"Chaining","text":"<pre><code>class HashTableChaining:\n    def __init__(self, size=11):\n        self.size = size\n        self.table = [None] * self.size\n\n    # Hash function\n    def hash(self, key):\n        return hash(key) % self.size\n\n    # Insert a key-value pair (chaining)\n    def insert(self, key, value):\n        idx = self.hash(key)\n        if self.table[idx] is None:\n            self.table[idx] = [(key, value)]  # Initialize a new chain (linked list)\n        else:\n            self.table[idx].append((key, value))  # Append to the existing chain\n\n    # Retrieve a value by key (chaining)\n    def get(self, key):\n        idx = self.hash(key)\n        if self.table[idx] is not None:\n            for pair in self.table[idx]:\n                if pair[0] == key:\n                    return pair[1]\n        return None\n\n    # Remove a key-value pair (chaining)\n    def remove(self, key):\n        idx = self.hash(key)\n        if self.table[idx] is not None:\n            for i, pair in enumerate(self.table[idx]):\n                if pair[0] == key:\n                    del self.table[idx][i]\n                    return True\n        return False\n\n    # Display hash table\n    def display(self):\n        for idx, chain in enumerate(self.table):\n            if chain is not None:\n                print(f\"Index {idx}: {chain}\")\n            else:\n                print(f\"Index {idx}: Empty\")\n\n\n# Example Usage (Chaining)\nht_chaining = HashTableChaining()\nht_chaining.insert(\"apple\", 10)\nht_chaining.insert(\"banana\", 20)\nht_chaining.insert(\"cherry\", 30)\n\nprint(ht_chaining.get(\"apple\"))    # Output: 10\nprint(ht_chaining.get(\"banana\"))   # Output: 20\nprint(ht_chaining.get(\"cherry\"))   # Output: 30\n\nht_chaining.remove(\"banana\")\nprint(ht_chaining.get(\"banana\"))   # Output: None\n\nht_chaining.display()\n</code></pre>"},{"location":"Programming/Data%20Structures/Hashing/#open-addressing","title":"Open Addressing","text":""},{"location":"Programming/Data%20Structures/Hashing/#linear-probing","title":"Linear Probing","text":"<pre><code>class HashTableLinearProbing:\n    def __init__(self, size=11):\n        self.size = size\n        self.table = [None] * self.size\n        self.count = 0\n\n    # Primary hash function\n    def hash(self, key):\n        return hash(key) % self.size\n\n    # Insert using Linear Probing\n    def insert(self, key, value):\n        if self.count / self.size &gt;= 0.7:\n            self._resize()\n        idx = self.hash(key)\n        original_idx = idx\n        while self.table[idx] is not None:\n            if self.table[idx][0] == key:\n                self.table[idx] = (key, value)  # Update existing key\n                return\n            idx = (idx + 1) % self.size\n            if idx == original_idx:\n                raise Exception(\"Hash table is full!\")\n        self.table[idx] = (key, value)\n        self.count += 1\n\n    # Get value using Linear Probing\n    def get(self, key):\n        idx = self.hash(key)\n        original_idx = idx\n        while self.table[idx] is not None:\n            if self.table[idx][0] == key:\n                return self.table[idx][1]\n            idx = (idx + 1) % self.size\n            if idx == original_idx:\n                break\n        return None\n\n    # Remove a key-value pair using Linear Probing\n    def remove(self, key):\n        idx = self.hash(key)\n        original_idx = idx\n        while self.table[idx] is not None:\n            if self.table[idx][0] == key:\n                self.table[idx] = None\n                self.count -= 1\n                self._rehash_after_removal(idx)\n                return True\n            idx = (idx + 1) % self.size\n            if idx == original_idx:\n                break\n        return False\n\n    # Resize the table when load factor exceeds threshold\n    def _resize(self):\n        new_size = self._next_prime(self.size * 2)\n        new_table = [None] * new_size\n        old_table = self.table\n        self.table = new_table\n        self.size = new_size\n        self.count = 0\n\n        for item in old_table:\n            if item is not None:\n                key, value = item\n                self.insert(key, value)\n\n    # Helper functions for resizing\n    def _rehash_after_removal(self, idx):\n        next_idx = (idx + 1) % self.size\n        while self.table[next_idx] is not None:\n            key, value = self.table[next_idx]\n            self.table[next_idx] = None\n            self.count -= 1\n            self.insert(key, value)  # Rehash the removed items\n            next_idx = (next_idx + 1) % self.size\n\n    def _next_prime(self, n):\n        while not self._is_prime(n):\n            n += 1\n        return n\n\n    def _is_prime(self, num):\n        if num &lt; 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n\n# Example Usage (Linear Probing)\nht_linear = HashTableLinearProbing()\nht_linear.insert(\"apple\", 10)\nht_linear.insert(\"banana\", 20)\nprint(ht_linear.get(\"apple\"))    # Output: 10\nprint(ht_linear.get(\"banana\"))   # Output: 20\nht_linear.remove(\"apple\")\nprint(ht_linear.get(\"apple\"))    # Output: None\n</code></pre>"},{"location":"Programming/Data%20Structures/Hashing/#quadratic-probing","title":"Quadratic Probing","text":"<pre><code>class HashTableQuadraticProbing:\n    def __init__(self, size=11):\n        self.size = size\n        self.table = [None] * self.size\n        self.count = 0\n\n    # Primary hash function\n    def hash(self, key):\n        return hash(key) % self.size\n\n    # Insert using Quadratic Probing\n    def insert(self, key, value):\n        if self.count / self.size &gt;= 0.7:\n            self._resize()\n        idx = self.hash(key)\n        i = 0\n        while self.table[(idx + i * i) % self.size] is not None:\n            if self.table[(idx + i * i) % self.size][0] == key:\n                self.table[(idx + i * i) % self.size] = (key, value)\n                return\n            i += 1\n        self.table[(idx + i * i) % self.size] = (key, value)\n        self.count += 1\n\n    # Get value using Quadratic Probing\n    def get(self, key):\n        idx = self.hash(key)\n        i = 0\n        while self.table[(idx + i * i) % self.size] is not None:\n            if self.table[(idx + i * i) % self.size][0] == key:\n                return self.table[(idx + i * i) % self.size][1]\n            i += 1\n        return None\n\n    # Remove a key-value pair using Quadratic Probing\n    def remove(self, key):\n        idx = self.hash(key)\n        i = 0\n        while self.table[(idx + i * i) % self.size] is not None:\n            if self.table[(idx + i * i) % self.size][0] == key:\n                self.table[(idx + i * i) % self.size] = None\n                self.count -= 1\n                self._rehash_after_removal((idx + i * i) % self.size)\n                return True\n            i += 1\n        return False\n\n    # Resize the table when load factor exceeds threshold\n    def _resize(self):\n        new_size = self._next_prime(self.size * 2)\n        new_table = [None] * new_size\n        old_table = self.table\n        self.table = new_table\n        self.size = new_size\n        self.count = 0\n\n        for item in old_table:\n            if item is not None:\n                key, value = item\n                self.insert(key, value)\n\n    # Helper functions for resizing\n    def _rehash_after_removal(self, idx):\n        next_idx = (idx + 1) % self.size\n        while self.table[next_idx] is not None:\n            key, value = self.table[next_idx]\n            self.table[next_idx] = None\n            self.count -= 1\n            self.insert(key, value)  # Rehash the removed items\n            next_idx = (next_idx + 1) % self.size\n\n    def _next_prime(self, n):\n        while not self._is_prime(n):\n            n += 1\n        return n\n\n    def _is_prime(self, num):\n        if num &lt; 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n\n# Example Usage (Quadratic Probing)\nht_quadratic = HashTableQuadraticProbing()\nht_quadratic.insert(\"apple\", 10)\nht_quadratic.insert(\"banana\", 20)\nprint(ht_quadratic.get(\"apple\"))    # Output: 10\nprint(ht_quadratic.get(\"banana\"))   # Output: 20\nht_quadratic.remove(\"apple\")\nprint(ht_quadratic.get(\"apple\"))    # Output: None\n</code></pre>"},{"location":"Programming/Data%20Structures/Hashing/#double-hashing","title":"Double Hashing","text":"<pre><code>class HashTableDoubleHashing:\n    def __init__(self, size=11):\n        self.size = size\n        self.table = [None] * self.size\n        self.count = 0\n\n    # Primary hash function\n    def hash(self, key):\n        return hash(key) % self.size\n\n    # Secondary hash function (used for double hashing)\n    def secondary_hash(self, key):\n        return 7 - (hash(key) % 7)  # A prime number for secondary hash\n\n    # Insert using Double Hashing\n    def insert(self, key, value):\n        if self.count / self.size &gt;= 0.7:\n            self._resize()\n        idx = self.hash(key)\n        step = self.secondary_hash(key)\n        original_idx = idx\n        while self.table[idx] is not None:\n            if self.table[idx][0] == key:\n                self.table[idx] = (key, value)\n                return\n            idx = (idx + step) % self.size\n            if idx == original_idx:\n                raise Exception(\"Hash table is full!\")\n        self.table[idx] = (key, value)\n        self.count += 1\n\n    # Get value using Double Hashing\n    def get(self, key):\n        idx = self.hash(key)\n        step = self.secondary_hash(key)\n        original_idx = idx\n        while self.table[idx] is not None:\n            if self.table[idx][0] == key:\n                return self.table[idx][1]\n            idx = (idx + step) % self.size\n            if idx == original_idx:\n                break\n        return None\n\n    # Remove a key-value pair using Double Hashing\n    def remove(self, key):\n        idx = self.hash(key)\n        step = self.secondary_hash(key)\n        original_idx = idx\n        while self.table[idx] is not None:\n            if self.table[idx][0] == key:\n                self.table[idx] = None\n                self.count -= 1\n                self._rehash_after_removal(idx)\n                return True\n            idx = (idx + step) % self.size\n            if idx == original_idx:\n                break\n        return False\n\n    # Resize the table when load factor exceeds threshold\n    def _resize(self):\n        new_size = self._next_prime(self.size * 2)\n        new_table = [None] * new_size\n        old_table = self.table\n        self.table = new_table\n        self.size = new_size\n        self.count = 0\n\n        for item in old_table:\n            if item is not None:\n                key, value = item\n                self.insert(key, value)\n\n    # Helper functions for resizing\n    def _rehash_after_removal(self, idx):\n        next_idx = (idx + 1) % self.size\n        while self.table[next_idx] is not None:\n            key, value = self.table[next_idx]\n            self.table[next_idx] = None\n            self.count -= 1\n            self.insert(key, value)  # Rehash the removed items\n            next_idx = (next_idx + 1) % self.size\n\n    def _next_prime(self, n):\n        while not self._is_prime(n):\n            n += 1\n        return n\n\n    def _is_prime(self, num):\n        if num &lt; 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n\n# Example Usage (Double Hashing)\nht_double = HashTableDoubleHashing()\nht_double.insert(\"apple\", 10)\nht_double.insert(\"banana\", 20)\nprint(ht_double.get(\"apple\"))    # Output: 10\nprint(ht_double.get(\"banana\"))   # Output: 20\nht_double.remove(\"apple\")\nprint(ht_double.get(\"apple\"))    # Output: None\n</code></pre>"},{"location":"Programming/Data%20Structures/Heap/","title":"Heap","text":""},{"location":"Programming/Data%20Structures/Heap/#minheap-implementation","title":"MinHeap Implementation","text":"<pre><code>class MinHeap:\n    def __init__(self, array=None):\n        self.arr = []\n        if array:\n            self.buildHeap(array)\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def leftChild(self, i):\n        return 2 * i + 1\n\n    def rightChild(self, i):\n        return 2 * i + 2\n\n    def insert(self, x):\n        self.arr.append(x)\n        i = len(self.arr) - 1\n        while i &gt; 0 and self.arr[self.parent(i)] &gt; self.arr[i]:\n            self.arr[self.parent(i)], self.arr[i] = self.arr[i], self.arr[self.parent(i)]\n            i = self.parent(i)\n\n    def minHeapify(self, i):\n        left = self.leftChild(i)\n        right = self.rightChild(i)\n        smallest = i\n\n        if left &lt; len(self.arr) and self.arr[left] &lt; self.arr[smallest]:\n            smallest = left\n        if right &lt; len(self.arr) and self.arr[right] &lt; self.arr[smallest]:\n            smallest = right\n\n        if smallest != i:\n            self.arr[i], self.arr[smallest] = self.arr[smallest], self.arr[i]\n            self.minHeapify(smallest)\n\n    def extractMin(self):\n        if len(self.arr) == 0:\n            raise IndexError(\"extractMin from empty heap\")\n\n        min_elem = self.arr[0]\n        self.arr[0] = self.arr[-1]\n        self.arr.pop()\n        self.minHeapify(0)\n\n        return min_elem\n\n    def decreaseKey(self, i, x):\n        if x &gt; self.arr[i]:\n            raise ValueError(\"New key is greater than the current key\")\n        self.arr[i] = x\n        while i &gt; 0 and self.arr[self.parent(i)] &gt; self.arr[i]:\n            self.arr[self.parent(i)], self.arr[i] = self.arr[i], self.arr[self.parent(i)]\n            i = self.parent(i)\n\n    def delete(self, i):\n        self.decreaseKey(i, float('-inf'))\n        self.extractMin()\n\n    def buildHeap(self, array):\n        self.arr = array\n        # Start from the last non-leaf node and apply minHeapify to each node\n        start_index = (len(self.arr) // 2) - 1\n        for i in range(start_index, -1, -1):\n            self.minHeapify(i)\n\n    def __str__(self):\n        return str(self.arr)\n\n# Example usage:\n\n# Step 1: Create a MinHeap instance with an unsorted array\narr = [10, 4, 15, 1, 7]\nheap = MinHeap(arr)\n\n# Step 2: Print the heap after building it\nprint(\"Heap after building:\", heap.arr)\n\n# Step 3: Insert more elements into the heap\nheap.insert(5)\nprint(\"Heap after inserting 5:\", heap.arr)\n\n# Step 4: Extract the minimum element\nmin_val = heap.extractMin()\nprint(\"Extracted min:\", min_val)\n\n# Step 5: Decrease a key (reduce the value at index 2 to 3)\nheap.decreaseKey(2, 3)\nprint(\"Heap after decreasing key:\", heap.arr)\n\n# Step 6: Delete an element at index 1\nheap.delete(1)\nprint(\"Heap after deleting element at index 1:\", heap.arr)\n</code></pre>"},{"location":"Programming/Data%20Structures/Heap/#maxheap-implementation","title":"MaxHeap Implementation","text":"<pre><code>class MaxHeap:\n    def __init__(self, array=None):\n        self.arr = []\n        if array:\n            self.buildHeap(array)\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def leftChild(self, i):\n        return 2 * i + 1\n\n    def rightChild(self, i):\n        return 2 * i + 2\n\n    def insert(self, x):\n        self.arr.append(x)\n        i = len(self.arr) - 1\n        while i &gt; 0 and self.arr[self.parent(i)] &lt; self.arr[i]:\n            self.arr[self.parent(i)], self.arr[i] = self.arr[i], self.arr[self.parent(i)]\n            i = self.parent(i)\n\n    def maxHeapify(self, i):\n        left = self.leftChild(i)\n        right = self.rightChild(i)\n        largest = i\n\n        if left &lt; len(self.arr) and self.arr[left] &gt; self.arr[largest]:\n            largest = left\n        if right &lt; len(self.arr) and self.arr[right] &gt; self.arr[largest]:\n            largest = right\n\n        if largest != i:\n            self.arr[i], self.arr[largest] = self.arr[largest], self.arr[i]\n            self.maxHeapify(largest)\n\n    def extractMax(self):\n        if len(self.arr) == 0:\n            raise IndexError(\"extractMax from empty heap\")\n\n        max_elem = self.arr[0]\n        self.arr[0] = self.arr[-1]\n        self.arr.pop()\n        self.maxHeapify(0)\n\n        return max_elem\n\n    def increaseKey(self, i, x):\n        if x &lt; self.arr[i]:\n            raise ValueError(\"New key is smaller than the current key\")\n        self.arr[i] = x\n        while i &gt; 0 and self.arr[self.parent(i)] &lt; self.arr[i]:\n            self.arr[self.parent(i)], self.arr[i] = self.arr[i], self.arr[self.parent(i)]\n            i = self.parent(i)\n\n    def delete(self, i):\n        self.increaseKey(i, float('inf'))\n        self.extractMax()\n\n    def buildHeap(self, array):\n        self.arr = array\n        # Start from the last non-leaf node and apply maxHeapify to each node\n        start_index = (len(self.arr) // 2) - 1\n        for i in range(start_index, -1, -1):\n            self.maxHeapify(i)\n\n    def __str__(self):\n        return str(self.arr)\n\n# Example usage:\n\n# Step 1: Create a MaxHeap instance with an unsorted array\narr = [10, 4, 15, 1, 7]\nheap = MaxHeap(arr)\n\n# Step 2: Print the heap after building it\nprint(\"Heap after building:\", heap.arr)\n\n# Step 3: Insert more elements into the heap\nheap.insert(20)\nprint(\"Heap after inserting 20:\", heap.arr)\n\n# Step 4: Extract the maximum element\nmax_val = heap.extractMax()\nprint(\"Extracted max:\", max_val)\n\n# Step 5: Increase a key (increase the value at index 2 to 18)\nheap.increaseKey(2, 18)\nprint(\"Heap after increasing key:\", heap.arr)\n\n# Step 6: Delete an element at index 1\nheap.delete(1)\nprint(\"Heap after deleting element at index 1:\", heap.arr)\n</code></pre>"},{"location":"Programming/Data%20Structures/Heap/#heapq-in-python","title":"heapq in python","text":"<pre><code>import heapq\n\n# 1. heapq.heappush(heap, item)\n# Adds item to the heap while maintaining heap property\nheap = [1, 3, 5, 7, 9, 2]\nheapq.heappush(heap, 4)\nprint(\"After heappush:\", heap)\n# Output: [1, 3, 2, 7, 9, 5, 4]\n\n# 2. heapq.heappop(heap)\n# Removes and returns the smallest item from the heap\nsmallest = heapq.heappop(heap)\nprint(\"Popped smallest:\", smallest)  # Output: 1\nprint(\"After heappop:\", heap)        # Output: [2, 3, 5, 7, 9]\n\n# 3. heapq.heappushpop(heap, item)\n# Pushes item to heap and pops and returns the smallest item\nresult = heapq.heappushpop(heap, 4)\nprint(\"Pushed and popped:\", result)  # Output: 2\nprint(\"After heappushpop:\", heap)    # Output: [3, 4, 5, 7, 9]\n\n# 4. heapq.heapreplace(heap, item)\n# Pops the smallest item and pushes item to heap\nsmallest = heapq.heapreplace(heap, 4)\nprint(\"Heap replace popped:\", smallest)  # Output: 3\nprint(\"After heapreplace:\", heap)        # Output: [4, 4, 5, 7, 9]\n\n# 5. heapq.nlargest(n, iterable, key=None)\n# Returns the n largest elements from the iterable\nnumbers = [1, 3, 5, 7, 9, 2]\nlargest = heapq.nlargest(3, numbers)\nprint(\"3 largest numbers:\", largest)  # Output: [9, 7, 5]\n\n# 6. heapq.nsmallest(n, iterable, key=None)\n# Returns the n smallest elements from the iterable\nsmallest = heapq.nsmallest(3, numbers)\nprint(\"3 smallest numbers:\", smallest)  # Output: [1, 2, 3]\n\n# 7. heapq.merge(*iterables, key=None, reverse=False)\n# Merges multiple sorted iterables into a single sorted iterator\nlist1 = [1, 3, 5]\nlist2 = [2, 4, 6]\nmerged = heapq.merge(list1, list2)\nprint(\"Merged lists:\", list(merged))  # Output: [1, 2, 3, 4, 5, 6]\n\n# Simulating a Max-Heap (by negating the values)\nheap = []\nheapq.heappush(heap, -10)\nheapq.heappush(heap, -5)\nheapq.heappush(heap, -15)\nprint(\"Max heap simulation:\", [-x for x in heap])  # Output: [15, 5, 10]\n\n# Popping the largest element in the simulated max-heap\nmax_value = -heapq.heappop(heap)\nprint(\"Popped max value:\", max_value)  # Output: 15\nprint(\"After popping:\", [-x for x in heap])  # Output: [10, 5]\n\n# Explanation of heapq functions:\n# - heapq.heappush(heap, item) - Push item onto heap\n# - heapq.heappop(heap) - Pop smallest item from heap\n# - heapq.heappushpop(heap, item) - Push item, then pop smallest item\n# - heapq.heapreplace(heap, item) - Pop smallest item, then push item\n# - heapq.nlargest(n, iterable) - Get the n largest elements\n# - heapq.nsmallest(n, iterable) - Get the n smallest elements\n# - heapq.merge(*iterables) - Merge multiple sorted iterables into one\n</code></pre>"},{"location":"Programming/Data%20Structures/Linked%20List/","title":"Linked List","text":""},{"location":"Programming/Data%20Structures/Linked%20List/#singly-linked-list","title":"Singly Linked List","text":"<pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        \"\"\"Add a new node to the end of the linked list.\"\"\"\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = new_node\n\n    def prepend(self, data):\n        \"\"\"Add a new node to the beginning of the linked list.\"\"\"\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def insert_at_position(self, data, position):\n        \"\"\"Insert a new node at the specified position.\"\"\"\n        new_node = Node(data)\n        if position == 0:\n            new_node.next = self.head\n            self.head = new_node\n            return\n        current = self.head\n        index = 0\n        while current and index &lt; position - 1:\n            current = current.next\n            index += 1\n        if not current:\n            raise IndexError(\"Position out of bounds\")\n        new_node.next = current.next\n        current.next = new_node\n\n    def delete(self, data):\n        \"\"\"Delete a node with the specified value.\"\"\"\n        if not self.head:\n            return\n        if self.head.data == data:\n            self.head = self.head.next\n            return\n        current = self.head\n        while current.next and current.next.data != data:\n            current = current.next\n        if current.next:\n            current.next = current.next.next\n\n    def search(self, data):\n        \"\"\"Search for a node with the specified value and return its index.\"\"\"\n        current = self.head\n        index = 0\n        while current:\n            if current.data == data:\n                return index\n            current = current.next\n            index += 1\n        return -1\n\n    def reverse(self):\n        \"\"\"Reverse the linked list.\"\"\"\n        prev = None\n        current = self.head\n        while current:\n            next_node = current.next  # Store the next node\n            current.next = prev      # Reverse the pointer\n            prev = current           # Move prev to the current node\n            current = next_node      # Move to the next node\n        self.head = prev             # Update the head to the new first node\n\n    def display(self):\n        \"\"\"Display the linked list as a sequence of nodes.\"\"\"\n        nodes = []\n        current = self.head\n        while current:\n            nodes.append(str(current.data))\n            current = current.next\n        print(\" -&gt; \".join(nodes))\n\n    def size(self):\n        \"\"\"Return the number of nodes in the linked list.\"\"\"\n        current = self.head\n        count = 0\n        while current:\n            count += 1\n            current = current.next\n        return count\n\n    def is_empty(self):\n        \"\"\"Check if the linked list is empty.\"\"\"\n        return self.head is None\n\n    def get_first(self):\n        \"\"\"Return the first node (head) of the list.\"\"\"\n        if self.head:\n            return self.head.data\n        return None\n\n    def get_last(self):\n        \"\"\"Return the last node (tail) of the list.\"\"\"\n        if not self.head:\n            return None\n        current = self.head\n        while current.next:\n            current = current.next\n        return current.data\n\n    def remove_duplicates(self):\n        \"\"\"Remove duplicate values from the linked list.\"\"\"\n        current = self.head\n        seen = set()\n        prev = None\n        while current:\n            if current.data in seen:\n                prev.next = current.next  # Bypass the duplicate\n            else:\n                seen.add(current.data)\n                prev = current\n            current = current.next\n\n    def clear(self):\n        \"\"\"Clear the entire linked list.\"\"\"\n        self.head = None\n\n    def get_node_at_index(self, index):\n        \"\"\"Return the node at a given index.\"\"\"\n        current = self.head\n        current_index = 0\n        while current:\n            if current_index == index:\n                return current.data\n            current = current.next\n            current_index += 1\n        return None  # Index out of range\n\n    def delete_at_index(self, index):\n        \"\"\"Delete a node at the given index.\"\"\"\n        if index == 0:\n            if self.head:\n                self.head = self.head.next\n            return\n        current = self.head\n        current_index = 0\n        while current and current.next:\n            if current_index == index - 1:\n                current.next = current.next.next\n                return\n            current = current.next\n            current_index += 1\n        raise IndexError(\"Index out of bounds\")\n\n    def to_list(self):\n        \"\"\"Convert the linked list to a Python list.\"\"\"\n        result = []\n        current = self.head\n        while current:\n            result.append(current.data)\n            current = current.next\n        return result\n\n    def sort(self):\n        \"\"\"Sort the linked list.\"\"\"\n        if not self.head or not self.head.next:\n            return\n        # Implementing merge sort or any sorting algorithm\n        self.head = self._merge_sort(self.head)\n\n    def _merge_sort(self, head):\n        \"\"\"Helper function for merge sort.\"\"\"\n        if not head or not head.next:\n            return head\n        middle = self._get_middle(head)\n        next_to_middle = middle.next\n        middle.next = None\n        left = self._merge_sort(head)\n        right = self._merge_sort(next_to_middle)\n        sorted_list = self._merge(left, right)\n        return sorted_list\n\n    def _get_middle(self, head):\n        \"\"\"Find the middle node of the list.\"\"\"\n        if not head:\n            return head\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n    def _merge(self, left, right):\n        \"\"\"Merge two sorted linked lists.\"\"\"\n        if not left:\n            return right\n        if not right:\n            return left\n        if left.data &lt;= right.data:\n            left.next = self._merge(left.next, right)\n            return left\n        else:\n            right.next = self._merge(left, right.next)\n            return right\n\n# Example usage\nll = LinkedList()\nll.append(10)\nll.append(20)\nll.append(30)\nll.display()  # Output: 10 -&gt; 20 -&gt; 30\n\nll.prepend(5)\nll.display()  # Output: 5 -&gt; 10 -&gt; 20 -&gt; 30\n\nll.insert_at_position(15, 2)\nll.display()  # Output: 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30\n\nll.insert_at_position(35, 5)\nll.display()  # Output: 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30 -&gt; 35\n\nll.insert_at_position(0, 0)\nll.display()  # Output: 0 -&gt; 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30 -&gt; 35\n\n# Reverse the linked list\nll.reverse()\nll.display()  # Output: 35 -&gt; 30 -&gt; 20 -&gt; 15 -&gt; 10 -&gt; 5 -&gt; 0\n\n# Size of the list\nprint(f\"Size: {ll.size()}\")  # Output: Size: 7\n\n# Search for an element\nprint(f\"Search 15: {ll.search(15)}\")  # Output: Search 15: 3\n\n# Remove duplicates (if any)\nll.remove_duplicates()\n\n# Clear the linked list\nll.clear()\nll.display()  # Output: (empty list)\n\n# Add some nodes again\nll.append(100)\nll.append(200)\nll.append(300)\nll.display()  # Output: 100 -&gt; 200 -&gt; 300\n\n# Convert to Python list\nprint(f\"List as Python list: {ll.to_list()}\")  # Output: List as Python list: [100, 200, 300]\n\n# Delete at index 1\nll.delete_at_index(1)\nll.display()  # Output: 100 -&gt; 300\n\n# Sort the list\nll.sort()\nll.display()  # Output: 100 -&gt; 300 (already sorted in this case)\n</code></pre>"},{"location":"Programming/Data%20Structures/Linked%20List/#doubly-linked-list","title":"Doubly Linked List","text":"<pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append(self, data):\n        \"\"\"Add a new node to the end of the doubly linked list.\"\"\"\n        new_node = Node(data)\n        if not self.head:\n            self.head = self.tail = new_node\n            return\n        self.tail.next = new_node\n        new_node.prev = self.tail\n        self.tail = new_node\n\n    def prepend(self, data):\n        \"\"\"Add a new node to the beginning of the doubly linked list.\"\"\"\n        new_node = Node(data)\n        if not self.head:\n            self.head = self.tail = new_node\n            return\n        new_node.next = self.head\n        self.head.prev = new_node\n        self.head = new_node\n\n    def insert_at_position(self, data, position):\n        \"\"\"Insert a new node at the specified position.\"\"\"\n        new_node = Node(data)\n        if position == 0:\n            self.prepend(data)\n            return\n        current = self.head\n        index = 0\n        while current and index &lt; position - 1:\n            current = current.next\n            index += 1\n        if not current:\n            raise IndexError(\"Position out of bounds\")\n        new_node.next = current.next\n        if current.next:\n            current.next.prev = new_node\n        current.next = new_node\n        new_node.prev = current\n\n    def delete(self, data):\n        \"\"\"Delete a node with the specified value.\"\"\"\n        current = self.head\n        while current:\n            if current.data == data:\n                if current.prev:\n                    current.prev.next = current.next\n                else:\n                    self.head = current.next  # If deleting the head\n                if current.next:\n                    current.next.prev = current.prev\n                else:\n                    self.tail = current.prev  # If deleting the tail\n                return\n            current = current.next\n\n    def search(self, data):\n        \"\"\"Search for a node with the specified value and return its index.\"\"\"\n        current = self.head\n        index = 0\n        while current:\n            if current.data == data:\n                return index\n            current = current.next\n            index += 1\n        return -1\n\n    def reverse(self):\n        \"\"\"Reverse the doubly linked list.\"\"\"\n        current = self.head\n        while current:\n            current.prev, current.next = current.next, current.prev\n            current = current.prev\n        self.head, self.tail = self.tail, self.head\n\n    def display(self):\n        \"\"\"Display the doubly linked list as a sequence of nodes.\"\"\"\n        nodes = []\n        current = self.head\n        while current:\n            nodes.append(str(current.data))\n            current = current.next\n        print(\" &lt;-&gt; \".join(nodes))\n\n    def size(self):\n        \"\"\"Return the number of nodes in the doubly linked list.\"\"\"\n        current = self.head\n        count = 0\n        while current:\n            count += 1\n            current = current.next\n        return count\n\n    def is_empty(self):\n        \"\"\"Check if the doubly linked list is empty.\"\"\"\n        return self.head is None\n\n    def get_first(self):\n        \"\"\"Return the first node (head) of the list.\"\"\"\n        if self.head:\n            return self.head.data\n        return None\n\n    def get_last(self):\n        \"\"\"Return the last node (tail) of the list.\"\"\"\n        if self.tail:\n            return self.tail.data\n        return None\n\n    def remove_duplicates(self):\n        \"\"\"Remove duplicate values from the doubly linked list.\"\"\"\n        current = self.head\n        seen = set()\n        while current:\n            if current.data in seen:\n                self.delete(current.data)\n            else:\n                seen.add(current.data)\n            current = current.next\n\n    def clear(self):\n        \"\"\"Clear the entire doubly linked list.\"\"\"\n        self.head = self.tail = None\n\n    def get_node_at_index(self, index):\n        \"\"\"Return the node at a given index.\"\"\"\n        current = self.head\n        current_index = 0\n        while current:\n            if current_index == index:\n                return current.data\n            current = current.next\n            current_index += 1\n        return None  # Index out of range\n\n    def delete_at_index(self, index):\n        \"\"\"Delete a node at the given index.\"\"\"\n        if index == 0:\n            if self.head:\n                self.head = self.head.next\n                if self.head:\n                    self.head.prev = None\n            return\n        current = self.head\n        current_index = 0\n        while current and current.next:\n            if current_index == index - 1:\n                if current.next:\n                    current.next = current.next.next\n                    if current.next:\n                        current.next.prev = current\n                return\n            current = current.next\n            current_index += 1\n        raise IndexError(\"Index out of bounds\")\n\n    def to_list(self):\n        \"\"\"Convert the doubly linked list to a Python list.\"\"\"\n        result = []\n        current = self.head\n        while current:\n            result.append(current.data)\n            current = current.next\n        return result\n\n    def sort(self):\n        \"\"\"Sort the doubly linked list.\"\"\"\n        if not self.head or not self.head.next:\n            return\n        # Implementing merge sort or any sorting algorithm\n        self.head = self._merge_sort(self.head)\n\n    def _merge_sort(self, head):\n        \"\"\"Helper function for merge sort.\"\"\"\n        if not head or not head.next:\n            return head\n        middle = self._get_middle(head)\n        next_to_middle = middle.next\n        middle.next = None\n        left = self._merge_sort(head)\n        right = self._merge_sort(next_to_middle)\n        sorted_list = self._merge(left, right)\n        return sorted_list\n\n    def _get_middle(self, head):\n        \"\"\"Find the middle node of the list.\"\"\"\n        if not head:\n            return head\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n    def _merge(self, left, right):\n        \"\"\"Merge two sorted doubly linked lists.\"\"\"\n        if not left:\n            return right\n        if not right:\n            return left\n        if left.data &lt;= right.data:\n            left.next = self._merge(left.next, right)\n            if left.next:\n                left.next.prev = left\n            return left\n        else:\n            right.next = self._merge(left, right.next)\n            if right.next:\n                right.next.prev = right\n            return right\n\n# Example usage\ndll = DoublyLinkedList()\ndll.append(10)\ndll.append(20)\ndll.append(30)\ndll.display()  # Output: 10 &lt;-&gt; 20 &lt;-&gt; 30\n\ndll.prepend(5)\ndll.display()  # Output: 5 &lt;-&gt; 10 &lt;-&gt; 20 &lt;-&gt; 30\n\ndll.insert_at_position(15, 2)\ndll.display()  # Output: 5 &lt;-&gt; 10 &lt;-&gt; 15 &lt;-&gt; 20 &lt;-&gt; 30\n\ndll.insert_at_position(35, 5)\ndll.display()  # Output: 5 &lt;-&gt; 10 &lt;-&gt; 15 &lt;-&gt; 20 &lt;-&gt; 30 &lt;-&gt; 35\n\ndll.insert_at_position(0, 0)\ndll.display()  # Output: 0 &lt;-&gt; 5 &lt;-&gt; 10 &lt;-&gt; 15 &lt;-&gt; 20 &lt;-&gt; 30 &lt;-&gt; 35\n\n# Reverse the doubly linked list\ndll.reverse()\ndll.display()  # Output: 35 &lt;-&gt; 30 &lt;-&gt; 20 &lt;-&gt; 15 &lt;-&gt; 10 &lt;-&gt; 5 &lt;-&gt; 0\n\n# Size of the list\nprint(f\"Size: {dll.size()}\")  # Output: Size: 7\n\n# Search for an element\nprint(f\"Search 15: {dll.search(15)}\")  # Output: Search 15: 3\n\n# Remove duplicates (if any)\ndll.remove_duplicates()\n\n# Clear the doubly linked list\ndll.clear()\ndll.display()  # Output: (empty list)\n\n# Add some nodes again\ndll.append(100)\ndll.append(200)\ndll.append(300)\ndll.display()  # Output: 100 &lt;-&gt; 200 &lt;-&gt; 300\n\n# Convert to Python list\nprint(f\"List as Python list: {dll.to_list()}\")  # Output: List as Python list: [100, 200, 300]\n\n# Delete at index 1\ndll.delete_at_index(1)\ndll.display()  # Output: 100 &lt;-&gt; 300\n\n# Sort the list\ndll.sort()\ndll.display()  # Output: 100 &lt;-&gt; 300 (already sorted in this case)\n</code></pre>"},{"location":"Programming/Data%20Structures/Linked%20List/#cicular-linked-list","title":"Cicular Linked List","text":"<pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        \"\"\"Add a new node to the end of the circular linked list.\"\"\"\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head  # Points to itself, forming a circle\n            return\n        current = self.head\n        while current.next != self.head:  # Traverse until we find the last node\n            current = current.next\n        current.next = new_node\n        new_node.next = self.head  # Complete the circle\n\n    def prepend(self, data):\n        \"\"\"Add a new node to the beginning of the circular linked list.\"\"\"\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head  # Points to itself\n            return\n        new_node.next = self.head\n        current = self.head\n        while current.next != self.head:  # Traverse until the last node\n            current = current.next\n        current.next = new_node  # Last node points to the new node\n        self.head = new_node  # Update head\n\n    def insert_at_position(self, data, position):\n        \"\"\"Insert a new node at the specified position in the circular linked list.\"\"\"\n        new_node = Node(data)\n        if position == 0:\n            self.prepend(data)\n            return\n        current = self.head\n        index = 0\n        while current and index &lt; position - 1:\n            current = current.next\n            index += 1\n            if current == self.head:  # Loop back to the start\n                raise IndexError(\"Position out of bounds\")\n        if not current:\n            raise IndexError(\"Position out of bounds\")\n        new_node.next = current.next\n        current.next = new_node\n\n    def delete(self, data):\n        \"\"\"Delete the node with the specified value.\"\"\"\n        if not self.head:\n            return\n        current = self.head\n        prev = None\n        while True:\n            if current.data == data:\n                if prev:  # If not the first node\n                    prev.next = current.next\n                    if current == self.head:  # If deleting the head node\n                        self.head = current.next\n                else:\n                    # Deleting the only node (head)\n                    if current.next == self.head:\n                        self.head = None\n                    else:\n                        self.head = current.next\n                        prev = self.head\n                        while prev.next != current:  # Update last node's next\n                            prev = prev.next\n                        prev.next = self.head\n                return\n            prev = current\n            current = current.next\n            if current == self.head:  # Loop back to the start\n                break\n\n    def search(self, data):\n        \"\"\"Search for a node with the specified value and return its index.\"\"\"\n        if not self.head:\n            return -1\n        current = self.head\n        index = 0\n        while True:\n            if current.data == data:\n                return index\n            current = current.next\n            index += 1\n            if current == self.head:  # Loop back to the start\n                break\n        return -1\n\n    def reverse(self):\n        \"\"\"Reverse the circular linked list.\"\"\"\n        if not self.head or self.head.next == self.head:\n            return  # No need to reverse if list is empty or has one node\n        prev = None\n        current = self.head\n        first_node = self.head\n        while True:\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n            if current == first_node:  # Loop back to the start\n                break\n        self.head.next = prev  # Complete the circular reference\n        self.head = prev  # New head is the last node in original list\n\n    def display(self):\n        \"\"\"Display the circular linked list.\"\"\"\n        if not self.head:\n            print(\"List is empty\")\n            return\n        nodes = []\n        current = self.head\n        while True:\n            nodes.append(str(current.data))\n            current = current.next\n            if current == self.head:  # Loop back to the start\n                break\n        print(\" -&gt; \".join(nodes))\n\n    def size(self):\n        \"\"\"Return the number of nodes in the circular linked list.\"\"\"\n        if not self.head:\n            return 0\n        count = 1\n        current = self.head.next\n        while current != self.head:\n            count += 1\n            current = current.next\n        return count\n\n    def is_empty(self):\n        \"\"\"Check if the circular linked list is empty.\"\"\"\n        return self.head is None\n\n    def get_first(self):\n        \"\"\"Return the first node (head) of the list.\"\"\"\n        if self.head:\n            return self.head.data\n        return None\n\n    def get_last(self):\n        \"\"\"Return the last node (tail) of the list.\"\"\"\n        if not self.head:\n            return None\n        current = self.head\n        while current.next != self.head:\n            current = current.next\n        return current.data\n\n    def remove_duplicates(self):\n        \"\"\"Remove duplicate values from the circular linked list.\"\"\"\n        if not self.head:\n            return\n        seen = set()\n        current = self.head\n        prev = None\n        while True:\n            if current.data in seen:\n                prev.next = current.next\n                if current == self.head:  # Update head if we deleted the first node\n                    self.head = current.next\n            else:\n                seen.add(current.data)\n                prev = current\n            current = current.next\n            if current == self.head:  # Loop back to the start\n                break\n\n    def clear(self):\n        \"\"\"Clear the entire circular linked list.\"\"\"\n        self.head = None\n\n    def get_node_at_index(self, index):\n        \"\"\"Return the node at a given index.\"\"\"\n        if not self.head:\n            return None\n        current = self.head\n        current_index = 0\n        while True:\n            if current_index == index:\n                return current.data\n            current = current.next\n            current_index += 1\n            if current == self.head:  # Loop back to the start\n                break\n        return None  # Index out of range\n\n    def delete_at_index(self, index):\n        \"\"\"Delete a node at the given index.\"\"\"\n        if not self.head:\n            raise IndexError(\"Index out of bounds\")\n        if index == 0:\n            self.delete(self.head.data)\n            return\n        current = self.head\n        prev = None\n        current_index = 0\n        while True:\n            if current_index == index:\n                if prev:\n                    prev.next = current.next\n                return\n            prev = current\n            current = current.next\n            current_index += 1\n            if current == self.head:  # Loop back to the start\n                break\n        raise IndexError(\"Index out of bounds\")\n\n    def to_list(self):\n        \"\"\"Convert the circular linked list to a Python list.\"\"\"\n        result = []\n        if not self.head:\n            return result\n        current = self.head\n        while True:\n            result.append(current.data)\n            current = current.next\n            if current == self.head:  # Loop back to the start\n                break\n        return result\n\n    def sort(self):\n        \"\"\"Sort the circular linked list.\"\"\"\n        if not self.head or self.head.next == self.head:\n            return  # No need to sort if list is empty or has one node\n        nodes = self.to_list()\n        nodes.sort()\n        self.clear()\n        for node in nodes:\n            self.append(node)\n\n# Example usage\ncll = CircularLinkedList()\ncll.append(10)\ncll.append(20)\ncll.append(30)\ncll.display()  # Output: 10 -&gt; 20 -&gt; 30\n\ncll.prepend(5)\ncll.display()  # Output: 5 -&gt; 10 -&gt; 20 -&gt; 30\n\ncll.insert_at_position(15, 2)\ncll.display()  # Output: 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30\n\ncll.insert_at_position(35, 5)\ncll.display()  # Output: 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30 -&gt; 35\n\ncll.insert_at_position(0, 0)\ncll.display()  # Output: 0 -&gt; 5 -&gt; 10 -&gt; 15 -&gt; 20 -&gt; 30 -&gt; 35\n\n# Reverse the circular linked list\ncll.reverse()\ncll.display()  # Output: 35 -&gt; 30 -&gt; 20 -&gt; 15 -&gt; 10 -&gt; 5 -&gt; 0\n\n# Size of the list\nprint(f\"Size: {cll.size()}\")  # Output: Size: 7\n\n# Search for an element\nprint(f\"Search 15: {cll.search(15)}\")  # Output: Search 15: 3\n\n# Remove duplicates (if any)\ncll.remove_duplicates()\n\n# Clear the circular linked list\ncll.clear()\ncll.display()  # Output: (empty list)\n\n# Add some nodes again\ncll.append(100)\ncll.append(200)\ncll.append(300)\ncll.display()  # Output: 100 -&gt; 200 -&gt; 300\n\n# Convert to Python list\nprint(f\"List as Python list: {cll.to_list()}\")  # Output: List as Python list: [100, 200, 300]\n\n# Delete at index 1\ncll.delete_at_index(1)\ncll.display()  # Output: 100 -&gt; 300\n\n# Sort the list\ncll.sort()\ncll.display()  # Output: 100 -&gt; 300 (already sorted in this case)\n</code></pre>"},{"location":"Programming/Data%20Structures/List/","title":"List","text":""},{"location":"Programming/Data%20Structures/List/#python-way","title":"Python way","text":"<pre><code># 1. Creating Lists\nmy_list = [1, 2, 3, 4, 5]\nempty_list = []\n\n# 2. Accessing elements\nfirst_item = my_list[0]  # First element\nlast_item = my_list[-1]  # Last element\nsub_list = my_list[1:4]  # Slice from index 1 to 3 (4 exclusive)\n\n# 3. Basic List Operations\n# Concatenation\nconcatenated_list = my_list + [6, 7, 8]\n\n# Repetition\nrepeated_list = [1, 2] * 3  # Output: [1, 2, 1, 2, 1, 2]\n\n# Length of a list\nlength = len(my_list)\n\n# Membership Test\nis_present = 3 in my_list  # Returns True if 3 is in my_list\n\n# 4. List Methods\n# append()\nmy_list.append(6)  # List becomes [1, 2, 3, 4, 5, 6]\n\n# extend()\nmy_list.extend([7, 8, 9])  # List becomes [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# insert()\nmy_list.insert(2, 10)  # List becomes [1, 2, 10, 3, 4, 5, 6, 7, 8, 9]\n\n# remove()\nmy_list.remove(10)  # List becomes [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# pop()\npopped_item = my_list.pop()  # Removes and returns last element (9)\n\n# index()\nindex_of_4 = my_list.index(4)  # Returns index of first occurrence of 4\n\n# count()\ncount_of_3 = my_list.count(3)  # Returns number of times 3 appears\n\n# sort() and reverse()\nmy_list.sort()  # Sorts the list in ascending order\nmy_list.reverse()  # Reverses the list\n\n# copy()\nmy_list_copy = my_list.copy()  # Copies the list\n\n# clear()\nmy_list.clear()  # Empties the list\n\n# 5. List Comprehensions\n# Basic list comprehension\nsquared_numbers = [x**2 for x in range(5)]  # Output: [0, 1, 4, 9, 16]\n\n# List comprehension with condition\neven_numbers = [x for x in range(10) if x % 2 == 0]  # Output: [0, 2, 4, 6, 8]\n\n# Nested list comprehension\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflattened = [item for sublist in matrix for item in sublist]  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 6. Built-in Functions\n# map() \u2013 Applies a function to each item\nsquared = list(map(lambda x: x**2, [1, 2, 3]))  # Output: [1, 4, 9]\n\n# filter() \u2013 Filters elements based on a condition\neven_numbers = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4]))  # Output: [2, 4]\n\n# sorted() \u2013 Returns a new sorted list\nsorted_list = sorted([5, 3, 9, 1])  # Output: [1, 3, 5, 9]\n\n# min() and max() \u2013 Return the smallest and largest element\nsmallest = min([5, 3, 9, 1])  # Output: 1\nlargest = max([5, 3, 9, 1])   # Output: 9\n\n# sum() \u2013 Sums all elements in the list\ntotal = sum([1, 2, 3, 4])  # Output: 10\n\n# any() \u2013 Returns True if any element is True (non-zero, non-empty)\nany_true = any([0, 1, 2])  # Output: True\n\n# all() \u2013 Returns True if all elements are True\nall_true = all([1, 2, 3])  # Output: True\n\n# 7. Advanced List Operations\n# Flatten a list of lists\nlist_of_lists = [[1, 2], [3, 4], [5, 6]]\nflattened = [item for sublist in list_of_lists for item in sublist]  # Output: [1, 2, 3, 4, 5, 6]\n\n# Find intersection of two lists\nlist1 = [1, 2, 3, 4]\nlist2 = [3, 4, 5, 6]\nintersection = list(set(list1) &amp; set(list2))  # Output: [3, 4]\n\n# Find union of two lists\nunion = list(set(list1) | set(list2))  # Output: [1, 2, 3, 4, 5, 6]\n\n# 8. More Complex Operations\n# Zipping two lists\nlist_a = [1, 2, 3]\nlist_b = ['a', 'b', 'c']\nzipped = list(zip(list_a, list_b))  # Output: [(1, 'a'), (2, 'b'), (3, 'c')]\n\n# Unzipping a list of tuples\nunzipped_a, unzipped_b = zip(*zipped)  # Output: (1, 2, 3), ('a', 'b', 'c')\n</code></pre>"},{"location":"Programming/Data%20Structures/List/#implementation-of-basic-functions","title":"Implementation of basic functions","text":"<pre><code>class CustomList:\n    def __init__(self, elements=None):\n        self.elements = elements if elements else []\n\n    def append(self, item):\n        \"\"\"Add an item to the end of the list.\"\"\"\n        self.elements += [item]\n\n    def extend(self, iterable):\n        \"\"\"Extend the list by appending all the items from the iterable.\"\"\"\n        for item in iterable:\n            self.append(item)\n\n    def insert(self, index, item):\n        \"\"\"Insert an item at a given position.\"\"\"\n        self.elements = self.elements[:index] + [item] + self.elements[index:]\n\n    def remove(self, item):\n        \"\"\"Remove the first occurrence of a value.\"\"\"\n        index = 0\n        found = False\n        for value in self.elements:\n            if value == item:\n                found = True\n                break\n            index += 1\n        if found:\n            self.elements = self.elements[:index] + self.elements[index+1:]\n        else:\n            raise ValueError(f\"{item} not in list\")\n\n    def pop(self, index=-1):\n        \"\"\"Remove the item at the given position in the list and return it.\"\"\"\n        if index &lt; 0:\n            index += self._length()\n        if 0 &lt;= index &lt; self._length():\n            item = self.elements[index]\n            self.elements = self.elements[:index] + self.elements[index+1:]\n            return item\n        raise IndexError(\"pop index out of range\")\n\n    def clear(self):\n        \"\"\"Remove all items from the list.\"\"\"\n        self.elements = []\n\n    def index(self, item, start=0, end=None):\n        \"\"\"Return the index of the first occurrence of the value.\"\"\"\n        end = end if end is not None else self._length()\n        current_index = 0\n        for value in self.elements:\n            if start &lt;= current_index &lt; end and value == item:\n                return current_index\n            current_index += 1\n        raise ValueError(f\"{item} not in list\")\n\n    def count(self, item):\n        \"\"\"Return the number of occurrences of the value.\"\"\"\n        count = 0\n        for value in self.elements:\n            if value == item:\n                count += 1\n        return count\n\n    def reverse(self):\n        \"\"\"Reverse the list in place.\"\"\"\n        self.elements = self.elements[::-1]\n\n    def sort(self, key=None, reverse=False):\n        \"\"\"Sort the list in ascending order.\"\"\"\n        def default_key(x): return x\n        key = key if key else default_key\n\n        # Implement bubble sort as an example\n        n = self._length()\n        for i in range(n):\n            for j in range(0, n-i-1):\n                if (key(self.elements[j]) &gt; key(self.elements[j+1])) == (not reverse):\n                    self.elements[j], self.elements[j+1] = self.elements[j+1], self.elements[j]\n\n    def copy(self):\n        \"\"\"Return a shallow copy of the list.\"\"\"\n        return CustomList(self.elements[:])\n\n    def _length(self):\n        \"\"\"Calculate the length of the list.\"\"\"\n        count = 0\n        for _ in self.elements:\n            count += 1\n        return count\n\n    def __getitem__(self, index):\n        \"\"\"Get an item by its index.\"\"\"\n        return self.elements[index]\n\n    def __setitem__(self, index, value):\n        \"\"\"Set an item at the specified index.\"\"\"\n        self.elements[index] = value\n\n    def __delitem__(self, index):\n        \"\"\"Delete an item at the specified index.\"\"\"\n        self.elements = self.elements[:index] + self.elements[index+1:]\n\n    def __repr__(self):\n        \"\"\"Return a string representation of the list.\"\"\"\n        return repr(self.elements)\n\n    def __len__(self):\n        \"\"\"Override len() to use our custom _length method.\"\"\"\n        return self._length()\n\n\n# Example usage\ncustom_list = CustomList([1, 2, 3])\ncustom_list.append(4)\ncustom_list.extend([5, 6])\ncustom_list.insert(2, 10)\ncustom_list.remove(2)\npopped_item = custom_list.pop()\nprint(\"Popped Item:\", popped_item)\ncustom_list.clear()\nprint(custom_list)  # Output: []\n</code></pre>"},{"location":"Programming/Data%20Structures/Queue/","title":"Queue","text":""},{"location":"Programming/Data%20Structures/Queue/#using-list","title":"Using List","text":"<pre><code>class QueueList:\n    def __init__(self):\n        self.queue = []\n\n    def enqueue(self, item):\n        self.queue.append(item)\n\n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError(\"Dequeue from empty queue\")\n        return self.queue.pop(0)\n\n    def front(self):\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self.queue[0]\n\n    def is_empty(self):\n        return len(self.queue) == 0\n\n    def size(self):\n        return len(self.queue)\n\n    def __str__(self):\n        return str(self.queue)\n\n# Example usage\nq1 = QueueList()\nq1.enqueue(1)\nq1.enqueue(2)\nq1.enqueue(3)\nprint(q1)  # Output: [1, 2, 3]\nq1.dequeue()\nprint(q1)  # Output: [2, 3]\n</code></pre>"},{"location":"Programming/Data%20Structures/Queue/#using-linked-list","title":"Using Linked list","text":"<pre><code>class Node:\n    def __init__(self, data=None):\n        self.data = data\n        self.next = None\n\nclass QueueLinkedList:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n        self.size = 0\n\n    def enqueue(self, item):\n        new_node = Node(item)\n        if self.rear:\n            self.rear.next = new_node\n        self.rear = new_node\n        if self.front is None:\n            self.front = new_node\n        self.size += 1\n\n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError(\"Dequeue from empty queue\")\n        removed_data = self.front.data\n        self.front = self.front.next\n        if self.front is None:\n            self.rear = None\n        self.size -= 1\n        return removed_data\n\n    def front_value(self):\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self.front.data\n\n    def is_empty(self):\n        return self.front is None\n\n    def queue_size(self):\n        return self.size\n\n    def __str__(self):\n        elements = []\n        current = self.front\n        while current:\n            elements.append(current.data)\n            current = current.next\n        return str(elements)\n\n# Example usage\nq2 = QueueLinkedList()\nq2.enqueue(1)\nq2.enqueue(2)\nq2.enqueue(3)\nprint(q2)  # Output: [1, 2, 3]\nq2.dequeue()\nprint(q2)  # Output: [2, 3]\n</code></pre>"},{"location":"Programming/Data%20Structures/Stack/","title":"Stack","text":""},{"location":"Programming/Data%20Structures/Stack/#using-list","title":"Using List","text":"<pre><code>class StackList:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, item):\n        \"\"\"Push item onto the stack.\"\"\"\n        self.stack.append(item)\n\n    def pop(self):\n        \"\"\"Pop item from the stack and return it.\"\"\"\n        if not self.is_empty():\n            return self.stack.pop()\n        return None\n\n    def peek(self):\n        \"\"\"Return the top item of the stack.\"\"\"\n        if not self.is_empty():\n            return self.stack[-1]\n        return None\n\n    def is_empty(self):\n        \"\"\"Check if the stack is empty.\"\"\"\n        return len(self.stack) == 0\n\n    def size(self):\n        \"\"\"Return the size of the stack.\"\"\"\n        return len(self.stack)\n\n    def balanced_parentheses(self, expression):\n        \"\"\"Evaluate balanced parentheses.\"\"\"\n        for char in expression:\n            if char == '(':\n                self.push(char)\n            elif char == ')':\n                if self.is_empty():\n                    return False\n                self.pop()\n        return self.is_empty()\n\n    def infix_to_postfix(self, expression):\n        \"\"\"Convert infix to postfix.\"\"\"\n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        output = []\n        for char in expression:\n            if char.isalnum():  # Operand\n                output.append(char)\n            elif char == '(':  # Left Parenthesis\n                self.push(char)\n            elif char == ')':  # Right Parenthesis\n                while not self.is_empty() and self.peek() != '(':\n                    output.append(self.pop())\n                self.pop()  # Pop '('\n            else:  # Operator\n                while (not self.is_empty() and self.peek() != '(' and\n                       precedence[char] &lt;= precedence.get(self.peek(), 0)):\n                    output.append(self.pop())\n                self.push(char)\n        while not self.is_empty():\n            output.append(self.pop())\n        return ''.join(output)\n\n    def evaluate_postfix(self, expression):\n        \"\"\"Evaluate a postfix expression.\"\"\"\n        for char in expression:\n            if char.isdigit():  # Operand\n                self.push(int(char))\n            else:  # Operator\n                right = self.pop()\n                left = self.pop()\n                if char == '+':\n                    self.push(left + right)\n                elif char == '-':\n                    self.push(left - right)\n                elif char == '*':\n                    self.push(left * right)\n                elif char == '/':\n                    self.push(left / right)\n                elif char == '^':\n                    self.push(left ** right)\n        return self.pop()\n\n    def infix_to_prefix(self, expression):\n        \"\"\"Convert infix to prefix.\"\"\"\n        # Reverse the infix expression\n        expression = expression[::-1]\n        expression = expression.replace('(', 'temp').replace(')', '(').replace('temp', ')')\n        postfix = self.infix_to_postfix(expression)\n        return postfix[::-1]\n\n    def evaluate_prefix(self, expression):\n        \"\"\"Evaluate a prefix expression.\"\"\"\n        # Reverse the expression to handle it from left to right\n        expression = expression[::-1]\n        for char in expression:\n            if char.isdigit():  # Operand\n                self.push(int(char))\n            else:  # Operator\n                left = self.pop()\n                right = self.pop()\n                if char == '+':\n                    self.push(left + right)\n                elif char == '-':\n                    self.push(left - right)\n                elif char == '*':\n                    self.push(left * right)\n                elif char == '/':\n                    self.push(left / right)\n                elif char == '^':\n                    self.push(left ** right)\n        return self.pop()\n\nexpression = \"3 + 5 * (2 - 8)\"\n\n# Using Stack with List\nstack_list = StackList()\npostfix = stack_list.infix_to_postfix(expression)\nprint(\"Postfix:\", postfix)  # Postfix conversion\npostfix_eval = stack_list.evaluate_postfix(postfix)\nprint(\"Postfix evaluation:\", postfix_eval)\n\nprefix = stack_list.infix_to_prefix(expression)\nprint(\"Prefix:\", prefix)  # Prefix conversion\nprefix_eval = stack_list.evaluate_prefix(prefix)\nprint(\"Prefix evaluation:\", prefix_eval)\n</code></pre>"},{"location":"Programming/Data%20Structures/Stack/#using-linked-list","title":"Using Linked List","text":"<pre><code>class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass StackLinkedList:\n    def __init__(self):\n        self.top = None\n\n    def push(self, item):\n        \"\"\"Push item onto the stack.\"\"\"\n        new_node = Node(item)\n        new_node.next = self.top\n        self.top = new_node\n\n    def pop(self):\n        \"\"\"Pop item from the stack and return it.\"\"\"\n        if self.is_empty():\n            return None\n        popped_node = self.top\n        self.top = self.top.next\n        return popped_node.data\n\n    def peek(self):\n        \"\"\"Return the top item of the stack.\"\"\"\n        if self.is_empty():\n            return None\n        return self.top.data\n\n    def is_empty(self):\n        \"\"\"Check if the stack is empty.\"\"\"\n        return self.top is None\n\n    def size(self):\n        \"\"\"Return the size of the stack.\"\"\"\n        current = self.top\n        count = 0\n        while current:\n            count += 1\n            current = current.next\n        return count\n\n    def balanced_parentheses(self, expression):\n        \"\"\"Evaluate balanced parentheses.\"\"\"\n        for char in expression:\n            if char == '(':\n                self.push(char)\n            elif char == ')':\n                if self.is_empty():\n                    return False\n                self.pop()\n        return self.is_empty()\n\n    def infix_to_postfix(self, expression):\n        \"\"\"Convert infix to postfix.\"\"\"\n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}\n        output = []\n        for char in expression:\n            if char.isalnum():  # Operand\n                output.append(char)\n            elif char == '(':  # Left Parenthesis\n                self.push(char)\n            elif char == ')':  # Right Parenthesis\n                while not self.is_empty() and self.peek() != '(':\n                    output.append(self.pop())\n                self.pop()  # Pop '('\n            else:  # Operator\n                while (not self.is_empty() and self.peek() != '(' and\n                       precedence[char] &lt;= precedence.get(self.peek(), 0)):\n                    output.append(self.pop())\n                self.push(char)\n        while not self.is_empty():\n            output.append(self.pop())\n        return ''.join(output)\n\n    def evaluate_postfix(self, expression):\n        \"\"\"Evaluate a postfix expression.\"\"\"\n        for char in expression:\n            if char.isdigit():  # Operand\n                self.push(int(char))\n            else:  # Operator\n                right = self.pop()\n                left = self.pop()\n                if char == '+':\n                    self.push(left + right)\n                elif char == '-':\n                    self.push(left - right)\n                elif char == '*':\n                    self.push(left * right)\n                elif char == '/':\n                    self.push(left / right)\n                elif char == '^':\n                    self.push(left ** right)\n        return self.pop()\n\n    def infix_to_prefix(self, expression):\n        \"\"\"Convert infix to prefix.\"\"\"\n        # Reverse the infix expression\n        expression = expression[::-1]\n        expression = expression.replace('(', 'temp').replace(')', '(').replace('temp', ')')\n        postfix = self.infix_to_postfix(expression)\n        return postfix[::-1]\n\n    def evaluate_prefix(self, expression):\n        \"\"\"Evaluate a prefix expression.\"\"\"\n        # Reverse the expression to handle it from left to right\n        expression = expression[::-1]\n        for char in expression:\n            if char.isdigit():  # Operand\n                self.push(int(char))\n            else:  # Operator\n                left = self.pop()\n                right = self.pop()\n                if char == '+':\n                    self.push(left + right)\n                elif char == '-':\n                    self.push(left - right)\n                elif char == '*':\n                    self.push(left * right)\n                elif char == '/':\n                    self.push(left / right)\n                elif char == '^':\n                    self.push(left ** right)\n        return self.pop()\n\nexpression = \"3 + 5 * (2 - 8)\"\n\n# Using Stack with Linked List\nstack_linked_list = StackLinkedList()\npostfix = stack_linked_list.infix_to_postfix(expression)\nprint(\"Postfix:\", postfix)  # Postfix conversion\npostfix_eval = stack_linked_list.evaluate_postfix(postfix)\nprint(\"Postfix evaluation:\", postfix_eval)\n\nprefix = stack_linked_list.infix_to_prefix(expression)\nprint(\"Prefix:\", prefix)  # Prefix conversion\nprefix_eval = stack_linked_list.evaluate_prefix(prefix)\nprint(\"Prefix evaluation:\", prefix_eval)\n</code></pre>"},{"location":"Programming/Data%20Structures/Tree/","title":"Tree","text":""},{"location":"Programming/Data%20Structures/Tree/#tree","title":"Tree","text":""},{"location":"Programming/Data%20Structures/Tree/#terminologies","title":"Terminologies","text":""},{"location":"Programming/Data%20Structures/Tree/#implementation","title":"Implementation","text":"<pre><code>class Node:\n    def __init__(self, value):\n        self.value = value  # Node's value\n        self.left = None    # Left child\n        self.right = None   # Right child\n\nclass BinaryTree:\n    def __init__(self, root_value):\n        self.root = Node(root_value)  # Root node of the binary tree\n\n    def insert_left(self, parent, value):\n        if parent.left is None:\n            parent.left = Node(value)\n        else:\n            new_node = Node(value)\n            new_node.left = parent.left\n            parent.left = new_node\n\n    def insert_right(self, parent, value):\n        if parent.right is None:\n            parent.right = Node(value)\n        else:\n            new_node = Node(value)\n            new_node.right = parent.right\n            parent.right = new_node\n\n    # In-order Traversal: Left -&gt; Root -&gt; Right\n    def inorder_traversal(self, node):\n        if node:\n            self.inorder_traversal(node.left)\n            print(node.value, end=\" \")\n            self.inorder_traversal(node.right)\n\n    # Pre-order Traversal: Root -&gt; Left -&gt; Right\n    def preorder_traversal(self, node):\n        if node:\n            print(node.value, end=\" \")\n            self.preorder_traversal(node.left)\n            self.preorder_traversal(node.right)\n\n    # Post-order Traversal: Left -&gt; Right -&gt; Root\n    def postorder_traversal(self, node):\n        if node:\n            self.postorder_traversal(node.left)\n            self.postorder_traversal(node.right)\n            print(node.value, end=\" \")\n\n    # Function to get the size of the tree (number of nodes)\n    def size(self, node):\n        if node is None:\n            return 0\n        else:\n            return 1 + self.size(node.left) + self.size(node.right)\n\n    # Function to get the maximum value in the tree\n    def max_value(self, node):\n        if node is None:\n            return float('-inf')  # Negative infinity as base case\n        else:\n            left_max = self.max_value(node.left)\n            right_max = self.max_value(node.right)\n            return max(node.value, left_max, right_max)\n\n    # Function to check if a given key is present in the tree\n    def contains(self, node, key):\n        if node is None:\n            return False\n        if node.value == key:\n            return True\n        return self.contains(node.left, key) or self.contains(node.right, key)\n\n    # Function to calculate the height of the tree\n    def height(self, node):\n        if node is None:\n            return -1  # For an empty tree, return -1 (or 0, based on convention)\n        else:\n            # Get the height of the left and right subtrees and return the larger one + 1\n            left_height = self.height(node.left)\n            right_height = self.height(node.right)\n            return 1 + max(left_height, right_height)\n\n    def iterative_inorder_traversal(self, root):\n        stack = []\n        current = root\n\n        while stack or current:\n            # Reach the leftmost node\n            while current:\n                stack.append(current)\n                current = current.left\n\n            # Pop from stack and visit the node\n            current = stack.pop()\n            print(current.value, end=\" \")\n\n            # Move to the right subtree\n            current = current.right\n\n    def iterative_preorder_traversal(self, root):\n        if root is None:\n            return\n\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            print(node.value, end=\" \")\n\n            # Push right child first so that left child is processed first\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n\n    # Iterative Post-order Traversal (using a stack)\n    def iterative_postorder_traversal(self, root):\n        if root is None:\n            return\n\n        stack = []\n        last_visited_node = None\n        current = root\n\n        while stack or current:\n            if current:\n                stack.append(current)\n                current = current.left\n            else:\n                peek_node = stack[-1]\n                # If the right child is None or already processed\n                if peek_node.right is None or peek_node.right == last_visited_node:\n                    print(peek_node.value, end=\" \")\n                    last_visited_node = stack.pop()\n                else:\n                    # Move to the right subtree\n                    current = peek_node.right\n\n# Example usage of the BinaryTree class:\nif __name__ == \"__main__\":\n    # Creating the root of the binary tree\n    tree = BinaryTree(1)\n\n    # Inserting left and right children\n    tree.insert_left(tree.root, 2)\n    tree.insert_right(tree.root, 3)\n\n    # Inserting more nodes\n    tree.insert_left(tree.root.left, 4)\n    tree.insert_right(tree.root.left, 5)\n\n    # Traversals\n    print(\"In-order Traversal:\")\n    tree.inorder_traversal(tree.root)\n    print(\"\\nPre-order Traversal:\")\n    tree.preorder_traversal(tree.root)\n    print(\"\\nPost-order Traversal:\")\n    tree.postorder_traversal(tree.root)\n\n    # Get size of the tree\n    print(\"\\nSize of the tree:\", tree.size(tree.root))\n\n    # Get maximum value in the tree\n    print(\"Maximum value in the tree:\", tree.max_value(tree.root))\n\n    # Check if a key is present in the tree\n    key = 5\n    print(f\"Is {key} present in the tree? {tree.contains(tree.root, key)}\")\n\n    key = 10\n    print(f\"Is {key} present in the tree? {tree.contains(tree.root, key)}\")\n\n    # Calculate the height of the tree\n    print(\"Height of the tree:\", tree.height(tree.root))\n\n    # Iterative Traversals\n    print(\"\\nIn-order Traversal (Iterative):\")\n    tree.iterative_inorder_traversal(tree.root)\n\n    print(\"\\nPre-order Traversal (Iterative):\")\n    tree.iterative_preorder_traversal(tree.root)\n\n    print(\"\\nPost-order Traversal (Iterative):\")\n    tree.iterative_postorder_traversal(tree.root)\n</code></pre>"},{"location":"Programming/Data%20Structures/Trie/","title":"Trie","text":""},{"location":"Programming/Data%20Structures/Trie/#implemntation","title":"Implemntation","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}  # A dictionary to store child nodes\n        self.is_end_of_word = False  # Flag to mark the end of a word\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()  # The root of the Trie is an empty node\n\n    def insert(self, word):\n        \"\"\"Insert a word into the Trie.\"\"\"\n        current = self.root\n        for char in word:\n            # If the character is not in the current node's children, add it\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        current.is_end_of_word = True  # Mark the end of the word\n\n    def search(self, word):\n        \"\"\"Search for a word in the Trie.\"\"\"\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                return False  # Word not found\n            current = current.children[char]\n        return current.is_end_of_word  # Return True if it's the end of a word\n\n    def starts_with(self, prefix):\n        \"\"\"Check if there is any word in the Trie that starts with the given prefix.\"\"\"\n        current = self.root\n        for char in prefix:\n            if char not in current.children:\n                return False  # Prefix not found\n            current = current.children[char]\n        return True  # Prefix exists in the Trie\n\n    def delete(self, word):\n        \"\"\"Delete a word from the Trie.\"\"\"\n        def _delete(node, word, index):\n            if index == len(word):\n                # If we've reached the end of the word, mark this node as not end of a word\n                if node.is_end_of_word:\n                    node.is_end_of_word = False\n                return len(node.children) == 0  # Return True if the node has no children\n            char = word[index]\n            if char not in node.children:\n                return False  # Word not found\n            can_delete = _delete(node.children[char], word, index + 1)\n\n            # If can delete is True, remove the child node\n            if can_delete:\n                del node.children[char]\n                return len(node.children) == 0  # Return True if the current node has no children\n            return False\n\n        _delete(self.root, word, 0)\n\n    def display(self):\n        \"\"\"Display all words in the Trie.\"\"\"\n        def _display(node, prefix):\n            if node.is_end_of_word:\n                print(prefix)  # Print the word when we reach the end of a word\n            for char, child in node.children.items():\n                _display(child, prefix + char)\n\n        _display(self.root, \"\")\n\n# Example usage\ntrie = Trie()\ntrie.insert(\"apple\")\ntrie.insert(\"app\")\ntrie.insert(\"bat\")\ntrie.insert(\"ball\")\ntrie.insert(\"batman\")\n\n# Search for words\nprint(trie.search(\"apple\"))  # Output: True\nprint(trie.search(\"app\"))    # Output: True\nprint(trie.search(\"bat\"))    # Output: True\nprint(trie.search(\"ball\"))   # Output: True\nprint(trie.search(\"batman\")) # Output: True\nprint(trie.search(\"banana\")) # Output: False\n\n# Prefix search\nprint(trie.starts_with(\"ba\"))  # Output: True\nprint(trie.starts_with(\"app\")) # Output: True\nprint(trie.starts_with(\"ban\")) # Output: False\n\n# Delete a word\ntrie.delete(\"bat\")\ntrie.display()  # Output: app, apple, ball, batman\n\n# Delete a word that doesn't exist\ntrie.delete(\"banana\")\ntrie.display()  # Output: app, apple, ball, batman\n</code></pre>"},{"location":"Programming/Design%20Patterns/Behavioural/","title":"Behavioural Design Patterns","text":"<p>Behavioral patterns focus on the interaction between objects, their communication, and the responsibilities of objects. These patterns help make complex communication between objects more flexible and efficient.</p>"},{"location":"Programming/Design%20Patterns/Behavioural/#memento-pattern","title":"Memento Pattern","text":"<p>Purpose</p> <p>Primary Purpose of Memento Pattern is to save and store previous state of an object. The Caretaker is responsible for storing and restoring the Memento without modifying it.  In this blog, we will explore how the Memento Pattern is implemented in Java through an example of a simple Graphic Editor that can save and undo shape modifications.</p> Key Components of the Memento Pattern: <p><code>Originator</code>: This is the object whose state is being saved or restored. In our case, it\u2019s the GraphicEditor class. <code>Memento</code>: This object stores the state of the Originator. In our example, it is the EditorMemento class. <code>Caretaker</code>: This class keeps the history of mementos and is responsible for saving and restoring states. In our example, the Caretaker class handles the history of shapes.</p> The GraphicEditor Class <p>The GraphicEditor class represents the originator. It stores information about the shape being drawn, such as its type, position, color, and size. It also has methods to save and restore its state using the EditorMemento class.</p> JavaPython GraphicEditor.java<pre><code>// The GraphicEditor class manages the properties of shapes and provides functionality to save and restore their state using the Memento pattern.\n\npackage Memento;\n\npublic class GraphicEditor {\n\n    private String shapeType;\n    private int x;\n    private int y;\n    private String color;\n    private int size;\n\n    public EditorMemento save() {\n        // TODO: Create and return a new memento that captures the current state of the shape attributes.\n        return new EditorMemento(shapeType, x, y, color, size);\n\n    }\n\n    public void restore(EditorMemento memento) {\n        // TODO: Restore the shape attributes from the provided memento, updating the graphic editor's state.\n        shapeType = memento.getShapeType();\n        x = memento.getX();\n        y = memento.getY();\n        color = memento.getColor();\n        size = memento.getSize();\n    }\n\n    public String getShape() {\n        return \"Shape: \" + shapeType + \", Position: (\" + x + \", \" + y + \"), Color: \" + color + \", Size: \" + size;\n    }\n\n    public void setShape(String shapeType, int x, int y, String color, int size) {\n        this.shapeType = shapeType;\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.size = size;\n    }\n}\n</code></pre> GraphicEditor.py<pre><code>from EditorMemento import EditorMemento\n\nclass GraphicEditor:\n    def __init__(self):\n        self.shape_type = None\n        self.x = 0\n        self.y = 0\n        self.color = None\n        self.size = 0\n\n    def save(self):\n        # Create and return a new memento capturing the current state\n        return EditorMemento(self.shape_type, self.x, self.y, self.color, self.size)\n\n    def restore(self, memento):\n        # Restore the state from the provided memento\n        self.shape_type = memento.shape_type\n        self.x = memento.x\n        self.y = memento.y\n        self.color = memento.color\n        self.size = memento.size\n\n    def get_shape(self):\n        return f\"Shape: {self.shape_type}, Position: ({self.x}, {self.y}), Color: {self.color}, Size: {self.size}\"\n\n    def set_shape(self, shape_type, x, y, color, size):\n        self.shape_type = shape_type\n        self.x = x\n        self.y = y\n        self.color = color\n        self.size = size\n</code></pre> The EditorMemento Class <p>The EditorMemento class captures the state of a shape. It is an immutable object that holds the shape's properties and provides getter methods to retrieve these values.</p> JavaPython EditorMemento.Java<pre><code>// The EditorMemento class stores the state of a shape, allowing for the preservation and restoration of its attributes in the Memento pattern.\n\npackage Memento;\n\npublic class EditorMemento {\n\n    private final String shapeType;\n    private final int x;\n    private final int y;\n    private final String color;\n    private final int size;\n\n    public EditorMemento(String shapeType, int x, int y, String color, int size) {\n        // TODO: Initialize the shape's attributes with the provided parameters.\n        this.shapeType = shapeType;\n        this.x = x ;\n        this.y = y ;\n        this.color = color;\n        this.size = size;\n\n\n    }\n\n    public String getShapeType() {\n        return shapeType;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public int getSize() {\n        return size;\n    }\n}\n</code></pre> EditorMemento.py<pre><code>class EditorMemento:\ndef __init__(self, shape_type, x, y, color, size):\n    # Store the shape's attributes\n    self.shape_type = shape_type\n    self.x = x\n    self.y = y\n    self.color = color\n    self.size = size\n</code></pre> The Caretaker Class <p>The Caretaker class is responsible for managing the history of saved states. It uses a Stack to keep track of the mementos. The caretaker does not modify the state of the memento, it only stores and retrieves it when necessary.</p> JavaPython Caretaker.Java<pre><code>// The Caretaker class manages the history of shape states, allowing for saving and undoing changes in the Memento pattern.\n\npackage Memento;\n\nimport java.util.Stack;\n\npublic class Caretaker {\n\n    private final Stack&lt;EditorMemento&gt; history = new Stack&lt;&gt;();\n\n    public void saveState(GraphicEditor graphicEditor) {\n        // TODO: Save the current state of the graphic editor by pushing its memento onto the history stack.\n        history.push(graphicEditor.save());\n\n    }\n\n    public void undo(GraphicEditor graphicEditor){\n        // TODO: Restore the last saved state of the graphic editor if history is not empty.\n        if (!history.empty()){\n            history.pop();\n            graphicEditor.restore(history.pop());\n        }\n\n    }\n}\n</code></pre> Caretaker.py<pre><code>class Caretaker:\ndef __init__(self):\n    # Stack to maintain history of states\n    self.history = []\n\ndef save_state(self, graphic_editor):\n    # Save the current state by appending its memento to the history\n    self.history.append(graphic_editor.save())\n\ndef undo(self, graphic_editor):\n    # Restore the last saved state if history is not empty\n    if self.history:\n        self.history.pop()  # Discard the latest state\n        if self.history:  # Check if there\u2019s another state to revert to\n            graphic_editor.restore(self.history[-1])\n</code></pre> The Exercise Class (Main Application) <p>The Exercise class is responsible for interacting with the user. It collects the shape's attributes and uses the GraphicEditor and Caretaker to manage and save the state.</p> JavaPython Exercise.java<pre><code>// The Exercise class allows users to input shape attributes and provides functionality to manage these shapes using the Memento pattern.\n\npackage Memento;\nimport java.util.Scanner;\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to gather user input and manage shape states.\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        GraphicEditor graphicEditor = new GraphicEditor();\n        Caretaker caretaker = new Caretaker();\n\n        for (int i = 0; i &lt; 3; i++) {\n            String shape = sc.next(); \n            int x = sc.nextInt();     \n            int y = sc.nextInt();     \n            String color = sc.next(); \n            int size = sc.nextInt(); \n\n            // TODO: Update the graphic editor with the new shape attributes from user input.\n            graphicEditor.setShape(shape, x, y, color, size);\n\n            // TODO: Save the current state of the graphic editor to the history\n            caretaker.saveState(graphicEditor);\n        }\n        sc.close();\n\n        // TODO: Implement the undo operation to revert to the previous shape state\n        caretaker.undo(graphicEditor);\n        // TODO: Output the current shape attributes after the undo operation to verify the restored state.\n        System.out.println(graphicEditor.getShape());\n\n    }\n}\n</code></pre> Exercise.py<pre><code>from GraphicEditor import GraphicEditor\nfrom Caretaker import Caretaker\n\nclass Exercise:\n    def run(self):\n        graphic_editor = GraphicEditor()\n        caretaker = Caretaker()\n\n        for _ in range(3):\n            # Take input from the user\n            shape = input(\"Enter shape type: \")  \n            x = int(input(\"Enter x-coordinate: \"))  \n            y = int(input(\"Enter y-coordinate: \"))  \n            color = input(\"Enter color: \")  \n            size = int(input(\"Enter size: \"))  \n\n            # Update the graphic editor with new shape attributes\n            graphic_editor.set_shape(shape, x, y, color, size)\n\n            # Save the current state to the history\n            caretaker.save_state(graphic_editor)\n\n        # Undo the last operation\n        caretaker.undo(graphic_editor)\n\n        # Print the current state after undo\n        print(graphic_editor.get_shape())\n\nif __name__ == \"__main__\":\n    Exercise().run()\n</code></pre>  How the Memento Pattern Works in This Example  <p><code>Setting the Shape:</code> The user inputs the shape's attributes (type, position, color, and size). These attributes are set in the GraphicEditor object. <code>Saving State:</code> Each time the user changes the shape, the current state is saved by calling the saveState method of the Caretaker class. This stores the state in a Stack. <code>Undo Operation:</code> The user can undo the changes by calling the undo method of the Caretaker class. This restores the previous shape state from the stack, effectively rolling back to an earlier state.</p>  Benefits of Using the Memento Pattern  <p><code>Encapsulation Preservation:</code> The state of an object is captured and stored outside of the object, allowing for state restoration without exposing the internal structure. <code>Undo/Redo Operations:</code> The Memento Pattern provides an easy way to implement undo and redo functionality. <code>Separation of Concerns:</code> The Caretaker class is responsible for managing the state history, allowing the GraphicEditor class to focus solely on the editing functionality.</p>"},{"location":"Programming/Design%20Patterns/Behavioural/#observer-pattern","title":"Observer Pattern","text":"Exercise.java<pre><code>// The Exercise class simulates stock price updates, registers investors, and removes an observer after the 4th update.\n\npackage Observer;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user input, manage stock price updates, and control the observer notification process.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        double priceChangeThreshold = sc.nextDouble();\n        StockMarket stockMarket = new StockMarket(priceChangeThreshold);\n\n        InvestorA investorA = new InvestorA();\n        InvestorB investorB = new InvestorB();\n\n        // TODO: Register Investor A as an observer to receive stock updates.\n        stockMarket.registerObserver(investorA);\n\n\n        // TODO: Register Investor B as an observer to receive stock updates.\n        stockMarket.registerObserver(investorB);\n\n        int updates = sc.nextInt();\n\n        for (int i = 1; i &lt;= updates; i++) {\n\n            if(i == 5) {\n                // TODO: Remove Investor B from receiving notifications after the 4th update.\n                stockMarket.removeObserver(investorB);\n\n            }\n\n            String stockSymbol = sc.next();\n            double newPrice = sc.nextDouble();\n            double oldPrice = sc.nextDouble();\n\n            // TODO: Update the stock price and notify observers.\n            stockMarket.setStockPrice(stockSymbol, newPrice, oldPrice);\n\n\n        }\n        sc.close();\n    }\n}\n</code></pre> StockMarket.java<pre><code>// The StockMarket class tracks stock price changes and notifies observers if the change exceeds a threshold.\n\npackage Observer;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StockMarket implements Subject {\n\n    private final List&lt;Observer&gt; observers;\n    private final double priceChangeThreshold;\n\n    public StockMarket(double priceChangeThreshold) {\n        // TODO: Initialize the list of observers to keep track of registered observers.\n        observers = new ArrayList&lt;&gt;();\n\n\n        this.priceChangeThreshold = priceChangeThreshold;\n    }\n\n    @Override\n    public void registerObserver(Observer o) {\n        // TODO: Add observer to the list of observers\n        observers.add(o);\n\n    }\n\n    @Override\n    public void removeObserver(Observer o) {\n        // TODO: Remove observer from the list of observers\n        observers.remove(o);\n\n    }\n\n    @Override\n    public void notifyObservers(String stockSymbol, double newPrice) {\n        for (Observer observer : observers) {\n            // TODO: Inform each observer about the updated stock price.\n            observer.update(stockSymbol, newPrice);\n\n        }\n    }\n\n    public void setStockPrice(String stockSymbol, double newPrice, double oldPrice) {\n        double priceChange = Math.abs(newPrice - oldPrice) / oldPrice * 100;\n        if (priceChange &gt;= priceChangeThreshold) {\n            // TODO: Notify observers if the price change exceeds the threshold\n            notifyObservers(stockSymbol, newPrice);\n\n        }\n    }\n}\n</code></pre> InvestorA.java<pre><code>// The InvestorA class implements the Observer interface and receives stock price updates.\n\npackage Observer;\n\npublic class InvestorA implements Observer {\n\n    @Override\n    public void update(String stockSymbol, double newPrice) {\n        System.out.println(\"Investor A notified: Stock \" + stockSymbol + \" has a new price: $\" + newPrice);\n    }\n}\n</code></pre> InvestorB.java<pre><code>// The InvestorB class implements the Observer interface and receives stock price updates.\n\npackage Observer;\n\npublic class InvestorB implements Observer {\n\n    @Override\n    public void update(String stockSymbol, double newPrice) {\n        System.out.println(\"Investor B notified: Stock \" + stockSymbol + \" has a new price: $\" + newPrice);\n    }\n}\n</code></pre> Subject.java<pre><code>// The Subject interface defines methods for registering, removing, and notifying observers about stock price changes.\n\npackage Observer;\n\npublic interface Subject {\n    void registerObserver(Observer o);\n    void removeObserver(Observer o);\n    void notifyObservers(String stockSymbol, double newPrice);\n}\n</code></pre> observer.java<pre><code>// The Observer interface defines the update method for receiving stock price change notifications.\n\npackage Observer;\n\npublic interface Observer {\n    void update(String stockSymbol, double newPrice);\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Behavioural/#strategy-pattern","title":"Strategy Pattern","text":"Exercise.java<pre><code>// Exercise.java\n// This class manages the formatting process of a document using various text formatting strategies.\n\npackage Strategy;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It facilitates the formatting process of a document using different formatting strategies.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n        Document document = new Document();\n\n        String userInput = sc.nextLine();\n        document.setContent(userInput);\n\n        // Using PlainTextFormatter\n        // TODO: Set the formatter for the document to PlainTextFormatter.\n        PlainTextFormatter plainText = new PlainTextFormatter();\n        document.setFormatter(plainText);\n\n        System.out.println(\"Plain Text:\");\n        document.display();\n\n        // Using HTMLFormatter\n        // TODO: Set the formatter for the document to HTMLFormatter.\n        HTMLFormatter htmlText = new HTMLFormatter();\n        document.setFormatter(htmlText);\n\n\n        System.out.println(\"HTML Format:\");\n        document.display();\n\n        // Using MarkdownFormatter\n        // TODO: Set the formatter for the document to MarkdownFormatter.\n        MarkdownFormatter markdownText = new MarkdownFormatter();\n        document.setFormatter(markdownText);\n\n\n        System.out.println(\"Markdown Format:\");\n        document.display(); \n\n        sc.close();\n    }\n}\n</code></pre> Document.java<pre><code>// Document.java\n// This class represents a document that can have its content formatted using different strategies.\n\npackage Strategy;\n\npublic class Document {\n\n    private String content;\n    private TextFormatter formatter;\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public void setFormatter(TextFormatter formatter) {\n        this.formatter = formatter;\n    }\n\n    public void display() {\n        // TODO: Print the formatted content using the chosen formatter.\n        System.out.println(formatter.format(this.content));\n\n    }\n}\n</code></pre> PlainTextFormatter.java<pre><code>// PlainTextFormatter.java\n// This class implements the TextFormatter interface to format text as plain text.\n\npackage Strategy;\n\npublic class PlainTextFormatter implements TextFormatter {\n\n    @Override\n    public String format(String text) {\n        // TODO: Return the input text without any formatting.\n        return text;\n\n    }\n}\n</code></pre> HTMLFormatter.java<pre><code>// HTMLFormatter.java\n// This class implements the TextFormatter interface to format the text as HTML.\n\npackage Strategy;\n\npublic class HTMLFormatter implements TextFormatter {\n\n    @Override\n    public String format(String text) {\n        // TODO: Wrap the input text in HTML tags: \"&lt;html&gt;&lt;body&gt;\" and \"&lt;/body&gt;&lt;/html&gt;\".\n        return \"&lt;html&gt;&lt;body&gt;\" + text + \"&lt;/body&gt;&lt;/html&gt;\";\n    }\n}\n</code></pre> MarkdownFormatter.java<pre><code>// MarkdownFormatter.java\n// This class implements the TextFormatter interface to format text using Markdown syntax.\n\npackage Strategy;\n\npublic class MarkdownFormatter implements TextFormatter {\n\n    @Override\n    public String format(String text) {\n        // TODO: Wrap the input text in Markdown syntax: \"**\" and \"**\".\n        return \"**\" + text + \"**\";\n\n    }\n}\n</code></pre> TextFormatter.java<pre><code>// TextFormatter.java\n// This Interface defines a contract for text formatting strategies.\n\npackage Strategy;\n\npublic interface TextFormatter {\n    String format(String text);\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Behavioural/#command-pattern","title":"Command Pattern","text":"Exercise.java<pre><code>// This class is responsible for creating devices, commands, and a remote control to demonstrate the command pattern functionality.\n\npackage Command;\n\npublic class Exercise {\n\n    //Do not modify the run method; it is designed to manage command execution and control the devices.\n    public void run () {\n\n        // Create devices\n        Light light = new Light();\n        Fan fan = new Fan();\n\n        // Create commands\n        Command lightOn = new LightCommands.LightOnCommand(light);\n        Command lightOff = new LightCommands.LightOffCommand(light);\n        Command fanOn = new FanCommands.FanOnCommand(fan);\n        Command fanOff = new FanCommands.FanOffCommand(fan);\n\n        // Create remote control\n        // TODO: Instantiate the RemoteControl object to manage commands.\n        RemoteControl remoteControl = new RemoteControl();\n\n\n        // TODO: Set the command for turning the light on using the LightOnCommand using remoteControl object.\n        remoteControl.setLightOnCommand(lightOn);\n\n\n        // TODO: Set the command for turning off the light using LightOffCommand using remoteControl object.\n        remoteControl.setLightOffCommand(lightOff);\n\n\n        // TODO: Set the command for turning on the fan using FanOnCommand using remoteControl object.\n        remoteControl.setFanOnCommand(fanOn);\n\n\n        // TODO: Set the command for turning off the fan using FanOffCommand using remoteControl object.\n        remoteControl.setFanOffCommand(fanOff);\n\n\n        // Test the functionality\n        // TODO: Press the button to turn on the light and verify the output.\n        remoteControl.pressLightOnButton();\n\n\n        // TODO: Press the button to turn off the light and verify the output.\n        remoteControl.pressLightOffButton();\n\n        // TODO: Press the button to turn on the fan and verify the output.\n        remoteControl.pressFanOnButton();\n\n        // TODO: Press the button to turn off the fan and verify the output.\n        remoteControl.pressFanOffButton();\n\n    }\n}\n</code></pre> RemoteControl.java<pre><code>// This class acts as a remote control, allowing the execution of commands for controlling devices like lights and fans.\n\npackage Command;\n\npublic class RemoteControl {\n\n    private Command lightOnCommand;\n    private Command lightOffCommand;\n    private Command fanOnCommand;\n    private Command fanOffCommand;\n\n    public void setLightOnCommand(Command command) {\n        this.lightOnCommand = command;\n    }\n\n    public void setLightOffCommand(Command command) {\n        this.lightOffCommand = command;\n    }\n\n    public void setFanOnCommand(Command command) {\n        this.fanOnCommand = command;\n    }\n\n    public void setFanOffCommand(Command command) {\n        this.fanOffCommand = command;\n    }\n\n    public void pressLightOnButton() {\n        if (lightOnCommand != null) {\n            lightOnCommand.execute();\n        }\n    }\n\n    public void pressLightOffButton() {\n        if (lightOffCommand != null) {\n            lightOffCommand.execute();\n        }\n    }\n\n    public void pressFanOnButton() {\n        if (fanOnCommand != null) {\n            fanOnCommand.execute();\n        }\n    }\n\n    public void pressFanOffButton() {\n        if (fanOffCommand != null) {\n            fanOffCommand.execute();\n        }\n    }\n}\n</code></pre> LightCommands.java<pre><code>// This class contains command implementations for controlling the light, including turning it on and off.\n\npackage Command;\n\npublic class LightCommands {\n\n    public static class LightOnCommand implements Command {\n\n        private Light light;\n\n        public LightOnCommand(Light light) {\n            this.light = light;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn on the light when this command is executed.\n        public void execute(){\n            light.turnOn();\n        }\n\n\n    }\n\n    public static class LightOffCommand implements Command {\n\n        private Light light;\n\n        public LightOffCommand(Light light) {\n            this.light = light;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn off the light when this command is executed.\n        public void execute(){\n            light.turnOff();\n        }\n\n    }\n}\n</code></pre> FanCommands.java<pre><code>// This class contains command implementations for controlling the fan, including turning it on and off.\n\npackage Command;\n\npublic class FanCommands {\n\n    public static class FanOnCommand implements Command {\n\n        private Fan fan;\n\n        public FanOnCommand(Fan fan) {\n            this.fan = fan;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn on the fan when this command is executed.\n        public void execute(){\n            fan.turnOn();\n        }\n\n\n    }\n\n    public static class FanOffCommand implements Command {\n\n        private Fan fan;\n\n        public FanOffCommand(Fan fan) {\n            this.fan = fan;\n        }\n\n        //TODO: Override the execute() method from the Command interface and Implement the logic to turn off the fan when this command is executed.\n\n        public void execute(){\n            fan.turnOff();\n        }\n    }\n}\n</code></pre> Light.java<pre><code>// This class represents a light that can be turned on or off, providing the corresponding output.\n\npackage Command;\n\npublic class Light {\n\n    public void turnOn() {\n        System.out.println(\"The light is on.\");\n    }\n\n    public void turnOff() {\n        System.out.println(\"The light is off.\");\n    }\n}\n</code></pre> Fan.java<pre><code>// This class represents a fan that can be turned on or off, providing the corresponding output.\n\npackage Command;\n\npublic class Fan {\n\n    public void turnOn() {\n        System.out.println(\"The fan is on.\");\n    }\n\n    public void turnOff() {\n        System.out.println(\"The fan is off.\");\n    }\n}\n</code></pre> Command.java<pre><code>// This interface defines a command that can be executed, requiring an implementation of the execute method.\n\npackage Command;\n\npublic interface Command {\n    void execute();\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Behavioural/#template-method-pattern","title":"Template Method Pattern","text":"Exercise.java<pre><code>// This class is responsible for executing the report generation process using different report types.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It manages the report generation process for various report types.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        // Generate Sales Report\n        ReportTemplate salesReport = new SalesReport(sc);\n        System.out.println(\"Generating Sales Report:\");\n\n        // TODO: Generate the Sales Report by calling the generateReport() method.\n        salesReport.generateReport();\n\n\n        // Generate Employee Report\n        ReportTemplate employeeReport = new EmployeeReport(sc);\n        System.out.println(\"Generating Employee Report:\");\n\n        // TODO: Generate the Employee Report by calling the generateReport() method.\n        employeeReport.generateReport();\n\n        // Generate Inventory Report\n        ReportTemplate inventoryReport = new InventoryReport(sc);\n        System.out.println(\"Generating Inventory Report:\");\n\n        // TODO: Generate the Inventory Report by calling the generateReport() method.\n        inventoryReport.generateReport();\n\n\n    }\n}\n</code></pre> SalesReport.java<pre><code>// This class represents a Sales Report, gathering and processing sales data from user input.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class SalesReport extends ReportTemplate {\n\n    private Scanner sc;\n\n    public SalesReport(Scanner sc) {\n        this.sc = sc;\n    }\n\n    @Override\n    protected void gatherData() {\n        String gatherData = sc.nextLine();\n        System.out.println(gatherData);\n    }\n\n    @Override\n    protected void processData() {\n        String processData = sc.nextLine();\n        System.out.println(processData);\n    }\n}\n</code></pre> EmployeeReport.java<pre><code>// This class represents a Employee Report, gathering and processing sales data from user input.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class EmployeeReport extends ReportTemplate {\n\n    private Scanner sc;\n\n    public EmployeeReport(Scanner sc) {\n        this.sc = sc;\n    }\n\n    @Override\n    protected void gatherData() {\n        String gatherData = sc.nextLine();\n        System.out.println(gatherData);\n    }\n\n    @Override\n    protected void processData() {\n        String processData = sc.nextLine();\n        System.out.println(processData);\n    }\n}\n</code></pre> InventoryReport.java<pre><code>// This class represents a Inventory Report, gathering and processing sales data from user input.\n\npackage Template;\n\nimport java.util.Scanner;\n\npublic class InventoryReport extends ReportTemplate {\n\n    private Scanner sc;\n\n    public InventoryReport(Scanner sc) {\n        this.sc = sc;\n    }\n\n    @Override\n    protected void gatherData() {\n        String gatherData = sc.nextLine();\n        System.out.println(gatherData);\n    }\n\n    @Override\n    protected void processData() {\n        String processData = sc.nextLine();\n        System.out.println(processData);\n    }\n}\n</code></pre> ReportTemplate.java<pre><code>// Abstract class defining the template for report generation, enforcing the structure while allowing specific implementations for each report type.\n\npackage Template;\n\npublic abstract class ReportTemplate {\n\n    // Template method defining the skeleton of the report generation\n    public final void generateReport() {\n        gatherData(); // Specific to each report\n        processData(); // Specific to each report\n        formatReport(); // Common across all reports\n        printReport(); // Common across all reports\n    }\n\n    // Steps to be implemented by subclasses\n    protected abstract void gatherData();\n    protected abstract void processData();\n\n    // Default methods that can be common across all reports\n    protected void formatReport() {\n        System.out.println(\"Formatting the report with appropriate layout and style.\");\n    }\n\n    protected void printReport() {\n        System.out.println(\"Printing the report for final review and distribution.\");\n    }\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Behavioural/#iterator-pattern","title":"Iterator Pattern","text":"Exercise.java<pre><code>// This class allows users to input various types of notifications and then displays them.\n\npackage Iterator;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user input and manage the notification workflow.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n        NotificationManager notificationManager = new NotificationManager();\n\n        // Add Notifications\n        for(int i=0;i &lt; 2;i++) {\n            String emailNotification = sc.nextLine();\n            String smsNotification = sc.nextLine();\n            String pushNotification = sc.nextLine();\n\n            notificationManager.addEmailNotification(emailNotification);\n            notificationManager.addSMSNotification(smsNotification);\n            notificationManager.addPushNotification(pushNotification);\n        }\n\n        // Print all notifications\n        // TODO: Use notificationManager to display all the added notifications by invoking the method that prints them.\n            notificationManager.printAllNotifications();\n\n\n        sc.close();\n    }\n}\n</code></pre> NotificationManager.java<pre><code>// This class manages different types of notifications (email, SMS, push) and provides methods to add notifications and print them using an iterator pattern.\n\npackage Iterator;\n\nimport java.util.Iterator;\n\npublic class NotificationManager {\n\n    private NotificationCollection emailNotifications;\n    private NotificationCollection smsNotifications;\n    private NotificationCollection pushNotifications;\n\n    public NotificationManager() {\n\n        // TODO: Initialize Email Notifications using the class responsible for handling Email Notifications.\n        this.emailNotifications = new EmailNotification();\n\n\n        // TODO: Initialize SMS Notifications using the class responsible for handling SMS Notifications.\n        this.smsNotifications = new SMSNotification();\n\n        // TODO: Initialize Push Notifications using the class responsible for handling Push Notifications.\n        this.pushNotifications = new PushNotification();\n\n\n    }\n\n    public void addEmailNotification(String message) {\n        ((EmailNotification) emailNotifications).addNotification(message);\n    }\n\n    public void addSMSNotification(String message) {\n        ((SMSNotification) smsNotifications).addNotification(message);\n    }\n\n    public void addPushNotification(String message) {\n        ((PushNotification) pushNotifications).addNotification(message);\n    }\n\n    public void printAllNotifications() {\n        printNotifications(emailNotifications.createIterator(), \"Email\");\n        printNotifications(smsNotifications.createIterator(), \"SMS\");\n        printNotifications(pushNotifications.createIterator(), \"Push\");\n    }\n\n    private void printNotifications(Iterator&lt;Notification&gt; iterator, String type) {\n        System.out.println(type + \" Notifications:\");\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next().getMessage());\n        }\n    }\n}\n</code></pre> EmailNotification.java<pre><code>// This class represents a collection of Email notifications and provides functionality to add notifications and create an iterator for traversing through them.\n\npackage Iterator;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class EmailNotification implements NotificationCollection {\n\n    private List&lt;Notification&gt; emailNotifications;\n\n    public EmailNotification() {\n        emailNotifications = new ArrayList&lt;&gt;();\n    }\n\n    public void addNotification(String message) {\n        emailNotifications.add(new Notification(message));\n    }\n\n    @Override\n    public Iterator&lt;Notification&gt; createIterator() {\n        // TODO: Return a new iterator for the Email Notifications using the EmailNotificationIterator class.\n        return new EmailNotificationIterator(this.emailNotifications);\n\n    }\n\n    private class EmailNotificationIterator implements Iterator&lt;Notification&gt; {\n        private int position = 0;\n        private List&lt;Notification&gt; notifications;\n\n        public EmailNotificationIterator(List&lt;Notification&gt; notifications) {\n            this.notifications = notifications;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return position &lt; notifications.size();\n        }\n\n        @Override\n        public Notification next() {\n            return notifications.get(position++);\n        }\n    }\n}\n</code></pre> SMSNotification.java<pre><code>// This class represents a collection of SMS notifications and provides functionality to add notifications and create an iterator for traversing through them.\n\npackage Iterator;\n\nimport java.util.Iterator;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class SMSNotification implements NotificationCollection {\n\n    private Queue&lt;Notification&gt; smsNotifications;\n\n    public SMSNotification() {\n        smsNotifications = new ArrayDeque&lt;&gt;();\n    }\n\n    public void addNotification(String message) {\n        smsNotifications.add(new Notification(message));\n    }\n\n    @Override\n    public Iterator&lt;Notification&gt; createIterator() {\n        // TODO: Return a new iterator for the SMS Notifications using the SMSNotificationIterator class.\n        return new SMSNotificationIterator(this.smsNotifications);\n\n    }\n\n    private class SMSNotificationIterator implements Iterator&lt;Notification&gt; {\n        private Queue&lt;Notification&gt; notifications;\n\n        public SMSNotificationIterator(Queue&lt;Notification&gt; notifications) {\n            this.notifications = new ArrayDeque&lt;&gt;(notifications);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return !notifications.isEmpty();\n        }\n\n        @Override\n        public Notification next() {\n            return notifications.poll();\n        }\n    }\n}\n</code></pre> PushNotification.java<pre><code>// This class represents a collection of Push notifications and provides functionality to add notifications and create an iterator for traversing through them.\n\npackage Iterator;\n\nimport java.util.LinkedHashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class PushNotification implements NotificationCollection {\n\n    private Set&lt;Notification&gt; pushNotifications;\n\n    public PushNotification() {\n        pushNotifications = new LinkedHashSet&lt;&gt;();\n    }\n\n    public void addNotification(String message) {\n        pushNotifications.add(new Notification(message));\n    }\n\n    @Override\n    public Iterator&lt;Notification&gt; createIterator() {\n        // TODO: Return a new iterator for the Push Notifications using the PushNotificationIterator class.\n        return new PushNotificationIterator(this.pushNotifications);\n\n    }\n\n    private class PushNotificationIterator implements Iterator&lt;Notification&gt; {\n        private Iterator&lt;Notification&gt; iterator;\n\n        public PushNotificationIterator(Set&lt;Notification&gt; notifications) {\n            this.iterator = notifications.iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public Notification next() {\n            return iterator.next();\n        }\n    }\n}\n</code></pre> Notification.java<pre><code>// This class represents a notification with a message for managing notifications.\n\npackage Iterator;\n\npublic class Notification {\n    private String message;\n\n    public Notification(String message) {\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\n</code></pre> NotificationCollection.java<pre><code>// This defines an interface for collections that provide an iterator for notifications.\n\npackage Iterator;\n\nimport java.util.Iterator;\n\npublic interface NotificationCollection {\n    public Iterator&lt;Notification&gt; createIterator();\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Behavioural/#state-pattern","title":"State pattern","text":"Exercise.java<pre><code>// The Exercise class demonstrates the State Design Pattern for a Media Player.\n\npackage State;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user commands (Play, Pause, stop) for the Media Player. \n    public void run() {\n\n        MediaPlayer mediaPlayer = new MediaPlayer();\n        Scanner sc = new Scanner(System.in);\n\n        String choice = sc.next();\n\n        switch (choice) {\n            case \"Play\":\n                mediaPlayer.play();\n                break;\n            case \"Pause\":\n                // TODO: Set the Media Player state to PausedState\n                mediaPlayer.setState(new PausedState());\n\n                mediaPlayer.pause();\n                break;\n            case \"Stop\":\n                // TODO: Set the Media Player state to StoppedState\n                mediaPlayer.setState(new StoppedState());\n\n                mediaPlayer.stop();\n                break;\n            default:\n                System.out.println(\"Invalid choice.\");\n        }\n\n        // TODO: Display the current state of the Media Player\n        mediaPlayer.displayState();\n\n        sc.close();\n    }\n}\n</code></pre> MediaPlayer.java<pre><code>// The MediaPlayer class manages the current state of the Media Player using the State Design Pattern.\n\npackage State;\n\npublic class MediaPlayer {\n\n    private State state;\n\n    public MediaPlayer() {\n        // TODO: Set the initial state of the Media Player to PlayingState\n        state = new PlayingState();\n\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void play() {\n        // TODO: Implement the functionality for pressing play\n        state.pressPlay();\n    }\n\n    public void stop() {\n        // TODO: Implement the functionality for pressing stop\n        state.pressStop();\n    }\n\n    public void pause() {\n        // TODO: Implement the functionality for pressing pause\n        state.pressPause();\n    }\n\n    public void displayState() {\n        // TODO: Implement the functionality to display the current state\n        state.display();\n    }\n}\n</code></pre> PlayingState.java<pre><code>// The PlayingState class represents the playing state of the Media Player. \n\npackage State;\n\npublic class PlayingState implements State {\n\n    @Override\n    public void pressPlay() {\n        System.out.println(\"Starting playback\");\n    }\n\n    @Override\n    public void pressStop() {\n        System.out.println(\"Stopping playback\");\n    }\n\n    @Override\n    public void pressPause() {\n        System.out.println(\"Pausing playback\");\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current State: Playing\");\n    }\n}\n</code></pre> PausedState.java<pre><code>// The PausedState class represents the playing state of the Media Player.\n\npackage State;\n\npublic class PausedState implements State {\n\n    @Override\n    public void pressPlay() {\n        System.out.println(\"Resuming playback\");\n    }\n\n    @Override\n    public void pressStop() {\n        System.out.println(\"Stopping playback from pause\");\n    }\n\n    @Override\n    public void pressPause() {\n        System.out.println(\"Pausing playback\");\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current State: Paused\");\n    }\n}\n</code></pre> StoppedState.java<pre><code>// The StoppedState class represents the playing state of the Media Player. \n\npackage State;\n\npublic class StoppedState implements State {\n\n    @Override\n    public void pressPlay() {\n        System.out.println(\"Starting playback\");\n    }\n\n    @Override\n    public void pressStop() {\n        System.out.println(\"Stopping playback\");\n    }\n\n    @Override\n    public void pressPause() {\n        System.out.println(\"Can't pause. Media is already stopped\");\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Current State: Stopped\");\n    }\n}\n</code></pre> State.java<pre><code>// The State interface defines the methods for different states of the Media Player. \n\npackage State;\n\npublic interface State {\n    void pressPlay();\n    void pressStop();\n    void pressPause();\n    void display();\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Behavioural/#mediator-pattern","title":"Mediator Pattern","text":"Exercise.java<pre><code>// This class simulates the flight control system, managing airplane takeoff and landing requests through a control tower mediator.\n\npackage Mediator;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It demonstrates the functionality of the Flight Control System using the Mediator design pattern.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        ControlTower controlTower = new ControlTower();\n\n        String airplaneId1 = sc.nextLine();\n        String airplaneId2 = sc.nextLine();\n        String airplaneId3 = sc.nextLine();\n        String airplaneId4 = sc.nextLine();\n\n        // TODO: Instantiate an airplane with the first provided ID\n        Airplane airplane1 = new Airplane(airplaneId1);\n\n        // TODO: Instantiate an airplane with the second provided ID\n        Airplane airplane2 = new Airplane(airplaneId2);\n\n        // TODO: Instantiate an airplane with the third provided ID\n        Airplane airplane3 = new Airplane(airplaneId3);\n\n        // TODO: Instantiate an airplane with the fourth provided ID\n        Airplane airplane4 = new Airplane(airplaneId4);\n\n\n        // TODO: Register the first airplane with the control tower\n        controlTower.registerAirplane(airplane1);\n\n\n        // TODO: Register the second airplane with the control tower\n        controlTower.registerAirplane(airplane2);\n\n\n        // TODO: Register the third airplane with the control tower\n        controlTower.registerAirplane(airplane3);\n\n\n        // TODO: Register the fourth airplane with the control tower\n        controlTower.registerAirplane(airplane4);\n\n        airplane1.requestTakeoff();\n        airplane2.requestTakeoff();\n        airplane3.requestTakeoff();\n        airplane4.requestTakeoff();\n\n        // TODO: Mark the first airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane1);\n\n\n        // TODO: Mark the second airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane2);\n\n\n        airplane3.requestTakeoff();\n        airplane4.requestTakeoff();\n\n        // TODO: Mark the third airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane3);\n\n        // TODO: Mark the fourth airplane as having completed takeoff and free a runway\n        controlTower.completeTakeoff(airplane4);\n\n        airplane1.requestLanding();\n        airplane2.requestLanding();\n\n        // TODO: Mark the first airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane1);\n\n\n        // TODO: Mark the second airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane2);\n\n\n        airplane3.requestLanding();\n        airplane4.requestLanding();\n\n        // TODO: Mark the third airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane3);\n\n\n        // TODO: Mark the fourth airplane as having completed landing and free a runway\n        controlTower.completeLanding(airplane4);\n\n\n\n        sc.close();\n    }\n}\n</code></pre> Airplane.java<pre><code>// This class represents an airplane that interacts with the Control Tower mediator for takeoff and landing requests.\n\npackage Mediator;\n\npublic class Airplane {\n    private String id;\n    private Mediator mediator;\n\n    public Airplane(String id) {\n        this.id = id;\n    }\n\n    public void setMediator(Mediator mediator) {\n        this.mediator = mediator;\n    }\n\n    public void requestTakeoff() {\n        System.out.println(\"Airplane \" + id + \" requesting takeoff\");\n\n        // TODO: Notify the mediator to handle the takeoff request for this airplane\n        mediator.handleTakeoffRequest(this);\n\n    }\n\n    public void requestLanding() {\n        System.out.println(\"Airplane \" + id + \" requesting landing\");\n\n        // TODO: Notify the mediator to handle the landing request for this airplane\n        mediator.handleLandingRequest(this);\n\n    }\n\n    public void receiveNotification(String message) {\n        System.out.println(\"Airplane \" + id + \": \" + message);\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n</code></pre> ControlTower.java<pre><code>// This class serves as the mediator, managing communication and runway allocation between airplanes for takeoff and landing.\n\npackage Mediator;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ControlTower implements Mediator {\n\n    private List&lt;Airplane&gt; airplanes;\n    private int takeoffRunways;\n    private int landingRunways;\n\n    public ControlTower() {\n        // TODO: Initialize the list of airplanes to manage communication\n        airplanes = new ArrayList&lt;&gt;();\n\n        this.takeoffRunways = 2;\n        this.landingRunways = 2;\n    }\n\n    @Override\n    public void registerAirplane(Airplane airplane) {\n        // TODO: Add the airplane to the list of registered airplanes\n        airplanes.add(airplane);\n\n        // TODO: Set the mediator for the airplane to enable communication\n        airplane.setMediator(this);\n\n\n    }\n\n    @Override\n    public void handleTakeoffRequest(Airplane airplane) {\n        if (takeoffRunways &gt; 0) {\n            takeoffRunways--; \n            notifyAirplane(airplane, \"Takeoff approved. Runways available: \" + takeoffRunways);\n        } else {\n            notifyAirplane(airplane, \"Takeoff denied. No runways available. Please wait\");\n        }\n    }\n\n    @Override\n    public void handleLandingRequest(Airplane airplane) {\n        if (landingRunways &gt; 0) {\n            landingRunways--;\n            notifyAirplane(airplane, \"Landing approved. Runways available: \" + landingRunways);\n        } else {\n            notifyAirplane(airplane, \"Landing denied. No runways available. Please wait\");\n        }\n    }\n\n    // Simulate the completion of takeoff and free the runway\n    public void completeTakeoff(Airplane airplane) {\n        System.out.println(\"Airplane \" + airplane.getId() + \" has taken off\");\n        takeoffRunways++;\n        System.out.println(\"Runway freed. Available takeoff runways: \" + takeoffRunways);\n    }\n\n    // Simulate the completion of landing and free the runway\n    public void completeLanding(Airplane airplane) {\n        System.out.println(\"Airplane \" + airplane.getId() + \" has landed\");\n        landingRunways++;\n        System.out.println(\"Runway freed. Available landing runways: \" + landingRunways);\n    }\n\n    private void notifyAirplane(Airplane airplane, String message) {\n        // TODO: Notify the airplane of the status message from the control tower\n        airplane.receiveNotification(message);\n    }\n}\n</code></pre> Mediator.java<pre><code>// This interface defines the contract for the mediator responsible for managing airplane communication and requests for takeoff and landing.\n\npackage Mediator;\n\npublic interface Mediator {\n    void registerAirplane(Airplane airplane);\n    void handleTakeoffRequest(Airplane airplane);\n    void handleLandingRequest(Airplane airplane);\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Creational/","title":"Creational Design Patterns","text":"<p>Creational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. These patterns help abstract the instantiation process, making it more flexible and dynamic.</p>"},{"location":"Programming/Design%20Patterns/Creational/#singleton-pattern","title":"Singleton Pattern","text":"Exercise.java<pre><code>// Exercise.java\n// The Exercise class demonstrates how to use the Logger class to log messages of different severity levels. \n\npackage Singleton;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It prompts the user for info, warning, and error messages and logs them accordingly. \n    public void run() {\n\n        Logger logger = Logger.getInstance();\n        Scanner sc = new Scanner(System.in);\n\n        // Get an info message from the user\n        System.out.print(\"Enter an info message: \");\n        String infoMessage = sc.nextLine();\n\n        // TODO: Log the info message using the appropriate logging method.\n        logger.info(infoMessage);\n\n\n        // Get a warning message from the user\n        System.out.print(\"Enter a warning message: \");\n        String warnMessage = sc.nextLine();\n\n        // TODO: Log the warn message using the appropriate logging method.\n        logger.warn(warnMessage);\n\n\n        // Get an error message from the user\n        System.out.print(\"Enter an error message: \");\n        String errorMessage = sc.nextLine();\n\n        // TODO: Log the error message using the appropriate logging method.\n        logger.error(errorMessage);\n\n\n\n        sc.close();\n    }\n}\n</code></pre> Logger.java<pre><code>// Logger.java\n// The Logger class implements the Singleton Pattern to provide a single point of access for logging messages throughout the application.\n\npackage Singleton;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class Logger {\n\n    private static Logger instance;\n\n    // Private constructor to prevent instantiation\n    private Logger() { \n\n    }\n\n    public static synchronized Logger getInstance() {\n        if (instance == null) {\n            instance = new Logger();\n\n        }\n        return instance;\n    }\n\n    public void info(String message) {\n        log(\"INFO\", message);\n    }\n\n    public void warn(String message) {\n        log(\"WARN\", message);\n    }\n\n    public void error(String message) {\n        log(\"ERROR\", message);\n    }\n\n    private void log(String level, String message) {\n        String timestamp = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n        System.out.println(String.format(\"%s [%s]: %s\", timestamp, level, message));\n    }\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Creational/#builder-pattern","title":"Builder Pattern","text":"Exercise.java<pre><code>// Exercise.java\n// This file gathers meal components from user input and constructs full and simple meals using the Builder design pattern.\n\npackage Builder;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It handles the meal construction process using user input and the Builder design pattern.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        // Get full meal components from user\n        String fullMainDish = sc.nextLine();\n\n        String fullSideDish = sc.nextLine();\n\n        String fullDrink = sc.nextLine();\n\n        String fullDessert = sc.nextLine();\n\n        String fullAppetizer = sc.nextLine();\n\n        // TODO: Construct a full meal using MealBuilder with the provided components.\n        Meal meal = new MealBuilder(fullMainDish, fullSideDish, fullDrink)\n                        .setDessert(fullDessert)\n                        .setAppetizer(fullAppetizer)\n                        .build();\n\n\n        System.out.println(\"Full Meal Summary:\");\n\n        // TODO: Print the summary of the constructed full meal.\n        meal.printMealSummary();\n\n\n        // Get simple meal components from user\n        String simpleMainDish = sc.nextLine();\n\n        String simpleSideDish = sc.nextLine();\n\n        String simpleDrink = sc.nextLine();\n\n        // TODO: Construct a simple meal using MealBuilder with the provided components.\n        Meal basic_meal = new MealBuilder(fullMainDish, fullSideDish, fullDrink)\n                        .build();\n\n        System.out.println(\"Simple Meal Summary:\");\n\n        // TODO: Print the summary of the constructed simple meal.\n        basic_meal.printMealSummary();\n\n\n        sc.close();\n    }\n}\n</code></pre> MealBuilder.java<pre><code>// MealBuilder.java\n// This file constructs a Meal object by setting mandatory components (main dish, side dish, drink) and optional components (dessert, appetizer) using the Builder design pattern.\n\npackage Builder;\n\npublic class MealBuilder {\n\n    public String mainDish;\n    public String sideDish;\n    public String drink;\n    public String dessert = \"Default Dessert\";\n    public String appetizer = \"Default Appetizer\";\n\n    public MealBuilder(String mainDish, String sideDish, String drink) {\n        // TODO: Initialize MealBuilder components using the provided parameters.\n        this.mainDish = mainDish;\n        this.sideDish = sideDish;\n        this.drink = drink;\n\n    }\n\n    public MealBuilder setDessert(String dessert) {\n        // TODO: Initialize the MealBuilder dessert field with the provided dessert parameter.\n        this.dessert = dessert;\n\n        return this;\n    }\n\n    public MealBuilder setAppetizer(String appetizer) {\n        // TODO: Initialize the MealBuilder appetizer field with the provided dessert parameter.\n\n        this.appetizer = appetizer;\n        return this;\n    }\n\n    public Meal build() {\n        // TODO: Write the return statement to complete the object construction process.\n        return Meal.getInstance(this);\n    }\n}\n</code></pre> Meal.java<pre><code>// This file defines the Meal class, representing a meal's components and providing a method to print the summary.\n\npackage Builder;\n\npublic class Meal {\n\n    private String mainDish;\n    private String sideDish;\n    private String drink;\n    private String dessert;\n    private String appetizer;\n\n    private Meal(MealBuilder builder) {\n        // TODO: Implement the Meal constructor to initialize Meal components from the MealBuilder.\n            this.mainDish = builder.mainDish;\n            this.sideDish = builder.sideDish;\n            this.drink = builder.drink;\n            this.dessert = builder.dessert;\n            this.appetizer = builder.appetizer;\n    }\n\n    public static synchronized Meal getInstance(MealBuilder builder) {\n        //TODO: Return a new instance of Meal using the provided MealBuilder\n        return new Meal(builder);\n\n    }\n\n    public void printMealSummary() {\n        System.out.println(\"Main Dish: \" + mainDish);\n        System.out.println(\"Side Dish: \" + sideDish);\n        System.out.println(\"Drink: \" + drink);\n        System.out.println(\"Dessert: \" + dessert);\n        System.out.println(\"Appetizer: \" + appetizer);\n    }\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Creational/#factory-pattern","title":"Factory Pattern","text":"Exercise.java<pre><code>// This class handles the creation of document instances based on user input.\n\npackage Factory;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to handle user input for creating document instances based on user commands.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        String documentType = sc.nextLine();\n\n        try {\n            // TODO: Create a document instance using the DocumentFactory based on user input\n            Document document = DocumentFactory.createDocument(documentType);\n\n            // TODO: Display the type of the created document instance\n            document.displayType();\n\n\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n\n        sc.close();\n    }\n}\n</code></pre> DocumentFactory.java<pre><code>// This factory class is responsible for creating instances of different document types.\n\npackage Factory;\n\npublic class DocumentFactory {\n\n    public static Document createDocument(String type) {\n\n        switch (type.toLowerCase()) {\n            case \"pdf\":\n                // TODO: Return a new instance of PDFDocument\n\n                return new PDFDocument();\n            case \"word\":\n                // TODO: Return a new instance of WordDocument\n\n                return new WordDocument();\n            case \"html\":\n                // TODO: Return a new instance of HTMLDocument\n\n                return new HTMLDocument();\n            default:\n                throw new IllegalArgumentException(\"Unknown document type: \" + type);\n        }\n    }\n}\n</code></pre> PDFDocument.java<pre><code>// This class represents a PDF document type.\n\npackage Factory;\n\npublic class PDFDocument extends Document {\n\n    @Override\n    public void displayType() {\n        System.out.println(\"Creating a PDF Document\");\n    }\n}\n</code></pre> WordDocument.java<pre><code>// This class represents a Word document type.\n\npackage Factory;\n\npublic class WordDocument extends Document {\n\n    @Override\n    public void displayType() {\n        System.out.println(\"Creating a Word Document\");\n    }\n}\n</code></pre> HTMLDocument.java<pre><code>// This class represents a HTML document type.\n\npackage Factory;\n\npublic class HTMLDocument extends Document {\n\n    @Override\n    public void displayType() {\n        System.out.println(\"Creating an HTML Document\");\n    }\n}\n</code></pre> Document.java<pre><code>// This abstract class represents the structure for various document types.\n\npackage Factory;\n\npublic abstract class Document {\n    public abstract void displayType();\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Creational/#abstract-factory-pattern","title":"Abstract Factory Pattern","text":""},{"location":"Programming/Design%20Patterns/Creational/#prototype-pattern","title":"Prototype Pattern","text":"Exercise.java<pre><code>// This class demonstrates the use of the Prototype Design Pattern for cloning characters.\n\npackage Prototype;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to gather user input and manage character states.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        String warriorName = sc.nextLine();\n\n        int health = sc.nextInt();\n\n        int attackPower = sc.nextInt();\n\n        int defense = sc.nextInt();\n\n        Warrior warrior = new Warrior(warriorName, health, attackPower, defense);\n\n        // TODO: Clone the original warrior character to create a new instance.\n        Warrior clonedWarrior = warrior.clone();\n\n        int clonedHealth = sc.nextInt();\n\n        int clonedAttackPower = sc.nextInt();\n\n        int clonedDefense = sc.nextInt();\n\n        clonedWarrior.setHealth(clonedHealth);\n        clonedWarrior.setAttackPower(clonedAttackPower);\n        clonedWarrior.setDefense(clonedDefense);\n\n        System.out.println(\"Original Character:\");\n\n        // TODO: Display the original warrior's attributes\n       warrior.displayAttributes();\n\n\n\n        System.out.println(\"\\nCloned Character:\");\n\n        // TODO: Display the cloned warrior's attributes\n        clonedWarrior.displayAttributes();\n\n\n        sc.close();\n    }\n}\n</code></pre> Warrior.java<pre><code>// This class represents a Warrior character in the Prototype Design Pattern.\n\npackage Prototype;\n\npublic class Warrior implements Character {\n\n    private String name;\n    private int health;\n    private int attackPower;\n    private int defense;\n\n    public Warrior(String name, int health, int attackPower, int defense) {\n        this.name = name;\n        this.health = health;\n        this.attackPower = attackPower;\n        this.defense = defense;\n    }\n\n    @Override\n    public Warrior clone() {\n        // TODO: Return a new Warrior instance with the given set of attributes.\n        return new Warrior(name, health, attackPower, defense);\n\n    }\n\n    @Override\n    public void displayAttributes() {\n        System.out.println(\"Warrior - Name: \" + name + \", Health: \" + health + \", Attack Power: \" + attackPower + \", Defense: \" + defense);\n    }\n\n    // Getters\n    public String getName() {\n        return name;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getAttackPower() {\n        return attackPower;\n    }\n\n    public int getDefense() {\n        return defense;\n    }\n\n    // Setters\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setAttackPower(int attackPower) {\n        this.attackPower = attackPower;\n    }\n\n    public void setDefense(int defense) {\n        this.defense = defense;\n    }\n}\n</code></pre> Mage.java<pre><code>// This class represents a Mage character in the Prototype Design Pattern.\n\npackage Prototype;\n\npublic class Mage implements Character {\n\n    private String name;\n    private int health;\n    private int attackPower;\n    private int defense;\n\n    public Mage(String name, int health, int attackPower, int defense) {\n        this.name = name;\n        this.health = health;\n        this.attackPower = attackPower;\n        this.defense = defense;\n    }\n\n    @Override\n    public Mage clone() {\n        // TODO: Return a new Mage instance with the given set of attributes.\n        return new Mage(name, health, attackPower, defense);\n\n    }\n\n    @Override\n    public void displayAttributes() {\n        System.out.println(\"Mage - Name: \" + name + \", Health: \" + health + \", Attack Power: \" + attackPower + \", Defense: \" + defense);\n    }\n\n    // Getters\n    public String getName() {\n        return name;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getAttackPower() {\n        return attackPower;\n    }\n\n    public int getDefense() {\n        return defense;\n    }\n\n    // Setters\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setAttackPower(int attackPower) {\n        this.attackPower = attackPower;\n    }\n\n    public void setDefense(int defense) {\n        this.defense = defense;\n    }\n}\n</code></pre> Archer.java<pre><code>// This class represents a Archer character in the Prototype Design Pattern.\n\npackage Prototype;\n\npublic class Archer implements Character {\n\n    private String name;\n    private int health;\n    private int attackPower;\n    private int defense;\n\n    public Archer(String name, int health, int attackPower, int defense) {\n        this.name = name;\n        this.health = health;\n        this.attackPower = attackPower;\n        this.defense = defense;\n    }\n\n    @Override\n    public Archer clone() {\n        // TODO: Return a new Archer instance with the given set of attributes.\n        return new Archer(name, health, attackPower, defense);\n\n    }\n\n    @Override\n    public void displayAttributes() {\n        System.out.println(\"Archer - Name: \" + name + \", Health: \" + health + \", Attack Power: \" + attackPower + \", Defense: \" + defense);\n    }\n\n    // Getters\n    public String getName() {\n        return name;\n    }\n\n    public int getHealth() {\n        return health;\n    }\n\n    public int getAttackPower() {\n        return attackPower;\n    }\n\n    public int getDefense() {\n        return defense;\n    }\n\n    // Setters\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setHealth(int health) {\n        this.health = health;\n    }\n\n    public void setAttackPower(int attackPower) {\n        this.attackPower = attackPower;\n    }\n\n    public void setDefense(int defense) {\n        this.defense = defense;\n    }\n}\n</code></pre> Character.java<pre><code>// This interface defines the behavior for cloning and displaying attributes of character objects.\n\npackage Prototype;\n\npublic interface Character {\n    Character clone();\n    void displayAttributes();\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Structural/","title":"Structural Design Patterns","text":"<p>Structural patterns deal with object composition and how large structures are formed by combining classes and objects. These patterns focus on simplifying the structure by identifying relationships.</p>"},{"location":"Programming/Design%20Patterns/Structural/#adapter-pattern","title":"Adapter Pattern","text":"Exercise.java<pre><code>// This class demonstrates the usage of different weather services through the Adapter pattern.\n\npackage Adapter;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to demonstrate the usage of legacy and new weather services through the Adapter pattern.\n    public void run() {\n\n        Scanner sc = new Scanner(System.in);\n\n        String legacyTemperature = sc.nextLine();\n        String legacyCondition = sc.nextLine();\n\n        // Using the legacy weather service with user input\n        WeatherService legacyService = new LegacyWeatherService(legacyTemperature, legacyCondition);\n        System.out.println(\"Legacy Weather Service Data:\");\n\n        // TODO: Print the weather data retrieved from the Legacy weather service.\n        System.out.println(legacyService.getWeatherData());\n\n        String temperature = sc.nextLine();\n        String condition = sc.nextLine();\n\n        NewWeatherService newService = new NewWeatherService(temperature, condition);\n\n        // TODO: Create an adapter for the new weather service.\n\n\n        WeatherService adaptedService = new NewWeatherServiceAdapter(newService);\n        System.out.println(\"New Weather Service Data:\");\n\n        // TODO: Print the weather data retrieved from the new weather service.\n        System.out.println(adaptedService.getWeatherData());\n\n\n        sc.close();\n    }\n}\n</code></pre> LegacyWeatherService.java<pre><code>// The Legacy class that provides weather data in XML format.\n\npackage Adapter;\n\npublic class LegacyWeatherService implements WeatherService {\n\n    private String temperature;\n    private String condition;\n\n    public LegacyWeatherService(String temperature, String condition) {\n        this.temperature = temperature;\n        this.condition = condition;\n    }\n\n    @Override\n    public String getWeatherData() {\n        return \"&lt;weather&gt;&lt;temperature&gt;\" + temperature + \"&lt;/temperature&gt;&lt;condition&gt;\" + condition + \"&lt;/condition&gt;&lt;/weather&gt;\";\n    }\n}\n</code></pre> NewWeatherService.java<pre><code>// The New class that provides weather data in JSON format.\n\npackage Adapter;\n\npublic class NewWeatherService {\n\n    private String temperature;\n    private String condition;\n\n    public NewWeatherService(String temperature, String condition) {\n        this.temperature = temperature;\n        this.condition = condition;\n    }\n\n    public String fetchWeather() {\n        return \"{\\\"temperature\\\": \" + temperature + \", \\\"condition\\\": \\\"\" + condition + \"\\\"}\";\n    }\n}\n</code></pre> NewWeatherServiceAdapter.java<pre><code>// The Adapter class that adapts the new weather service to the WeatherService interface.\n\npackage Adapter;\n\npublic class NewWeatherServiceAdapter implements WeatherService {\n\n    private NewWeatherService newWeatherService;\n\n    public NewWeatherServiceAdapter(NewWeatherService newWeatherService) {\n        this.newWeatherService = newWeatherService;\n    }\n\n    @Override\n    public String getWeatherData() {\n        // TODO: Fetch weather data from the new weather service and return the formatted data\n        String data = newWeatherService.fetchWeather();\n        return data;\n\n    }\n}\n</code></pre> WeatherService.java<pre><code>// This interface defines a consistent contract for retrieving weather data from various weather services.\n\npackage Adapter;\n\npublic interface WeatherService {\n    String getWeatherData();\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Structural/#decorator-pattern","title":"Decorator Pattern","text":"Exercise.java<pre><code>// The Exercise class facilitates user interaction to create a customized coffee by allowing the selection of various ingredients and then outputs the final coffee description and total cost.\n\npackage Decorator;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It is designed to demonstrate the usage of the Decorator pattern for customizing coffee with various ingredients.\n    public void run(){\n\n        Scanner sc = new Scanner(System.in);\n\n        Coffee coffee = new BasicCoffee();\n\n        boolean addMoreIngredients = true;\n\n        while (addMoreIngredients) {\n\n            String choices = sc.nextLine();\n            String[] ingredients = choices.split(\" \");\n\n            for (String choice : ingredients) {\n\n                switch (choice) {\n                    case \"1\":\n                        // TODO: Complete the implementation for adding Milk to the coffee.\n                        coffee = new Milk(coffee);\n\n                        break;\n                    case \"2\":\n                        // TODO: Complete the implementation for adding Sugar to the coffee.\n                        coffee = new Sugar(coffee);\n\n                        break;\n                    case \"3\":\n                        // TODO: Complete the implementation for adding Whipped Cream to the coffee.\n\n                        coffee = new WhippedCream(coffee);\n                        break;\n                    case \"4\":\n                        addMoreIngredients = false;\n                        break;\n                    default:\n                        System.out.println(\"Invalid choice: \" + choice);\n                        break;\n                }\n            }\n\n            if (!addMoreIngredients) {\n                break;\n            }\n        }\n\n        System.out.println(\"Final Coffee Description: \" + coffee.getDescription());\n        System.out.println(\"Total Cost: $\" + coffee.getCost());\n\n        sc.close();\n    }\n}\n</code></pre> CoffeeDecorator.java<pre><code>// Abstract class for decorating Coffee objects, allowing additional features to be added while preserving core functionality.\n\npackage Decorator;\n\npublic abstract class CoffeeDecorator implements Coffee {\n    protected Coffee coffee;\n\n    public CoffeeDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n\n    @Override\n    public String getDescription() {\n        // TODO: Complete this method to return the description of the decorated coffee.\n        return coffee.getDescription();\n    }\n\n    @Override\n    public double getCost() {\n        // TODO: Complete this method to return the cost of the decorated coffee.\n        return coffee.getCost();\n    }\n}\n</code></pre> Milk.java<pre><code>// Concrete decorator class that adds Milk to a Coffee object, modifying its description and cost accordingly.\n\npackage Decorator;\n\npublic class Milk extends CoffeeDecorator {\n\n    public Milk(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Milk\";\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.50; \n    }\n}\n</code></pre> Sugar.java<pre><code>// Concrete decorator class that adds Sugar to a Coffee object, enhancing its description and adjusting its cost.\n\npackage Decorator;\n\npublic class Sugar extends CoffeeDecorator {\n\n    public Sugar(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Sugar\";\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.30; \n    }\n}\n</code></pre> WhippedCream.java<pre><code>// Concrete decorator class that adds Whipped Cream to a Coffee object, enhancing its description and adjusting its cost.\n\npackage Decorator;\n\npublic class WhippedCream extends CoffeeDecorator {\n\n    public WhippedCream(Coffee coffee) {\n        super(coffee);\n    }\n\n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Whipped Cream\";\n    }\n\n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.70; \n    }\n}\n</code></pre> BasicCoffee.java<pre><code>// This class represents implementation of the Coffee interface representing a basic coffee with a fixed description and cost.\n\npackage Decorator;\n\npublic class BasicCoffee implements Coffee {\n\n    @Override\n    public String getDescription() {\n        return \"Basic Coffee\";\n    }\n\n    @Override\n    public double getCost() {\n        return 3.00; \n    }\n}\n</code></pre> Coffee.java<pre><code>// This interface defines the contract for Coffee objects, requiring methods for obtaining the description and cost.\n\npackage Decorator;\n\npublic interface Coffee {\n    String getDescription();\n    double getCost();\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Structural/#proxy-pattern","title":"Proxy Pattern","text":"Exercise.java<pre><code>// This class demonstrates the use of the Proxy Design Pattern to manage access to a network service and cache responses.\n\npackage Proxy;\n\nimport java.util.Scanner;\n\npublic class Exercise {\n\n    // Do not modify the run method. It demonstrates the usage of the Proxy Design Pattern to manage access to a network service.\n    public void run() {\n\n        NetworkService networkService = new NetworkServiceProxy();\n        Scanner sc = new Scanner(System.in);\n\n        String userInput = sc.nextLine();\n\n        // TODO: Fetch data using the networkService and print the result\n        String fetch = networkService.fetchData(userInput);\n        System.out.println(fetch);\n\n\n        // TODO: Fetch data again using the networkService (should retrieve from cache) and print the result\n        String Refetch = networkService.fetchData(userInput);\n        System.out.println(Refetch);\n\n        sc.close();\n    }\n}\n</code></pre> NetworkServiceProxy.java<pre><code>// This class implements the Proxy Design Pattern to manage access to the RealNetworkService and cache responses.\n\npackage Proxy;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class NetworkServiceProxy implements NetworkService {\n\n    private RealNetworkService realNetworkService;\n    private Map&lt;String, String&gt; cache;\n\n    public NetworkServiceProxy() {\n        // TODO: Initialize the cache to store fetched data.\n        cache = new HashMap&lt;&gt;();\n    }\n\n    @Override\n    public String fetchData(String input) {\n\n        if (cache.containsKey(input)) {\n            System.out.println(\"Fetching data from cache\");\n\n            // TODO: Return the cached data for the given input.\n            return cache.get(input);\n\n        }\n\n        if (realNetworkService == null) {\n            // TODO: Initialize the RealNetworkService if it has not been created yet.\n            realNetworkService = new RealNetworkService();\n\n        }\n\n        // TODO: Fetch data from the real network service using the provided input.\n        String data = realNetworkService.fetchData(input);\n\n        // TODO: Cache the fetched data with the input as the key for future access.\n        cache.put(input, data);\n\n        // TODO: Return the fetched data to the client.\n        return data;\n\n    }\n}\n</code></pre> RealNetworkService.java<pre><code>// This class represents the actual network service that fetches data from a remote server.\n\npackage Proxy;\n\npublic class RealNetworkService implements NetworkService {\n\n    private String data;\n\n    @Override\n    public String fetchData(String input) {\n        data = \"Data fetched from remote server for input: \" + input;\n        return data;\n    }\n}\n</code></pre> NetworkService.java<pre><code>// This interface defines the contract for network services that fetch data based on user input.\n\npackage Proxy;\n\npublic interface NetworkService {\n    String fetchData(String input);\n}\n</code></pre>"},{"location":"Programming/Design%20Patterns/Structural/#composite-pattern","title":"Composite Pattern","text":""},{"location":"Programming/Design%20Patterns/Structural/#facade-pattern","title":"Facade Pattern","text":""},{"location":"Programming/Design%20Patterns/Structural/#flyweight-pattern","title":"Flyweight Pattern","text":""},{"location":"Programming/System%20Design/Introduction/","title":"Introduction","text":""},{"location":"Programming/System%20Design/Introduction/#overview","title":"Overview","text":""}]}